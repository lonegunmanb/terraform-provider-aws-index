package github.com/hashicorp/terraform-provider-aws/internal/verify
import (
	"encoding/json"
	"fmt"
	"net"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	basevalidation "github.com/hashicorp/aws-sdk-go-base/v2/validation"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	tfmaps "github.com/hashicorp/terraform-provider-aws/internal/maps"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/internal/types/timestamp"
)
func ValidIAMPolicyJSON(v any, k string) (ws []string, errors []error) {
	// IAM Policy documents need to be valid JSON, and pass legacy parsing
	value := v.(string)
	value = strings.TrimSpace(value)
	if len(value) < 1 {
		errors = append(errors, fmt.Errorf("%q is an empty string, which is not a valid JSON value", k))
		return //nolint:nakedret // Naked return due to legacy, non-idiomatic Go function, error handling
	}

	if first := value[:1]; first != "{" {
		switch first {
		case " ", "\t", "\r", "\n":
			errors = append(errors, fmt.Errorf("%q contains an invalid JSON policy: leading space characters are not allowed", k))
		case `"`:
			// There are some common mistakes that lead to strings appearing
			// here instead of objects, so we'll try some heuristics to
			// check for those so we might give more actionable feedback in
			// these situations.
			var hint string
			var content string
			var innerContent any
			if err := json.Unmarshal([]byte(value), &content); err == nil {
				if strings.HasSuffix(content, ".json") {
					hint = " (have you passed a JSON-encoded filename instead of the content of that file?)"
				} else if err := json.Unmarshal([]byte(content), &innerContent); err == nil {
					hint = " (have you double-encoded your JSON data?)"
				}
			}
			errors = append(errors, fmt.Errorf("%q contains an invalid JSON policy: contains a JSON-encoded string, not a JSON-encoded object%s", k, hint))
		case `[`:
			errors = append(errors, fmt.Errorf("%q contains an invalid JSON policy: contains a JSON array, not a JSON object", k))
		default:
			// Generic error for if we didn't find something more specific to say.
			errors = append(errors, fmt.Errorf("%q contains an invalid JSON policy: not a JSON object", k))
		}
		return //nolint:nakedret // Naked return due to legacy, non-idiomatic Go function, error handling
	}

	if _, err := structure.NormalizeJsonString(v); err != nil {
		errStr := err.Error()
		if err, ok := errs.As[*json.SyntaxError](err); ok {
			errStr = fmt.Sprintf("%s, at byte offset %d", errStr, err.Offset)
		}
		errors = append(errors, fmt.Errorf("%q contains an invalid JSON policy: %s", k, errStr))
		return //nolint:nakedret // Naked return due to legacy, non-idiomatic Go function, error handling
	}

	if err := basevalidation.JSONNoDuplicateKeys(value); err != nil {
		errors = append(errors, fmt.Errorf("%q contains duplicate JSON keys: %s", k, err))
		return //nolint:nakedret // Naked return due to legacy, non-idiomatic Go function, error handling
	}

	return //nolint:nakedret // Just a long function.
}
