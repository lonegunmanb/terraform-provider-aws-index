package github.com/hashicorp/terraform-provider-aws/internal/service/s3
import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"slices"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/feature/s3/manager"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/aws/aws-sdk-go-v2/service/s3/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/endpoints"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/provider/sdkv2/importer"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceBucketUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).S3Client(ctx)

	// Note: Order of argument updates below is important.

	//
	// Bucket Policy.
	//
	if d.HasChange(names.AttrPolicy) {
		policy, err := structure.NormalizeJsonString(d.Get(names.AttrPolicy).(string))
		if err != nil {
			return sdkdiag.AppendFromErr(diags, err)
		}

		if policy == "" {
			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.DeleteBucketPolicy(ctx, &s3.DeleteBucketPolicyInput{
					Bucket: aws.String(d.Id()),
				})
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting S3 Bucket (%s) policy: %s", d.Id(), err)
			}
		} else {
			input := &s3.PutBucketPolicyInput{
				Bucket: aws.String(d.Id()),
				Policy: aws.String(policy),
			}

			_, err = tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.PutBucketPolicy(ctx, input)
			}, errCodeMalformedPolicy, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) policy: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket CORS Configuration.
	//
	if d.HasChange("cors_rule") {
		if v, ok := d.GetOk("cors_rule"); !ok || len(v.([]any)) == 0 {
			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.DeleteBucketCors(ctx, &s3.DeleteBucketCorsInput{
					Bucket: aws.String(d.Id()),
				})
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting S3 Bucket (%s) CORS configuration: %s", d.Id(), err)
			}
		} else {
			input := &s3.PutBucketCorsInput{
				Bucket: aws.String(d.Id()),
				CORSConfiguration: &types.CORSConfiguration{
					CORSRules: expandBucketCORSRules(d.Get("cors_rule").([]any)),
				},
			}

			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.PutBucketCors(ctx, input)
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) CORS configuration: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket Website Configuration.
	//
	if d.HasChange("website") {
		if v, ok := d.GetOk("website"); !ok || len(v.([]any)) == 0 || v.([]any)[0] == nil {
			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.DeleteBucketWebsite(ctx, &s3.DeleteBucketWebsiteInput{
					Bucket: aws.String(d.Id()),
				})
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting S3 Bucket (%s) website configuration: %s", d.Id(), err)
			}
		} else {
			websiteConfig, err := expandBucketWebsiteConfiguration(v.([]any))
			if err != nil {
				return sdkdiag.AppendFromErr(diags, err)
			}

			input := &s3.PutBucketWebsiteInput{
				Bucket:               aws.String(d.Id()),
				WebsiteConfiguration: websiteConfig,
			}

			_, err = tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.PutBucketWebsite(ctx, input)
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) website configuration: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket Versioning.
	//
	if d.HasChange("versioning") {
		v := d.Get("versioning").([]any)
		var versioningConfig *types.VersioningConfiguration

		if d.IsNewResource() {
			versioningConfig = expandBucketVersioningConfigurationCreate(v)
		} else {
			versioningConfig = expandBucketVersioningConfigurationUpdate(v)
		}

		if versioningConfig != nil {
			input := &s3.PutBucketVersioningInput{
				Bucket:                  aws.String(d.Id()),
				VersioningConfiguration: versioningConfig,
			}

			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.PutBucketVersioning(ctx, input)
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) versioning: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket ACL.
	//
	if (d.HasChange("acl") && !d.IsNewResource()) || (d.HasChange("grant") && d.Get("grant").(*schema.Set).Len() == 0) {
		acl := types.BucketCannedACL(d.Get("acl").(string))
		if acl == "" {
			// Use default value previously available in v3.x of the provider.
			acl = types.BucketCannedACLPrivate
		}
		input := &s3.PutBucketAclInput{
			ACL:    acl,
			Bucket: aws.String(d.Id()),
		}

		_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
			return conn.PutBucketAcl(ctx, input)
		}, errCodeNoSuchBucket)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) ACL: %s", d.Id(), err)
		}
	}

	if d.HasChange("grant") && d.Get("grant").(*schema.Set).Len() > 0 {
		bucketACL, err := retryWhenNoSuchBucketError(ctx, d.Timeout(schema.TimeoutUpdate), func() (*s3.GetBucketAclOutput, error) {
			return findBucketACL(ctx, conn, d.Id(), "")
		})

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "reading S3 Bucket (%s) ACL: %s", d.Id(), err)
		}

		input := &s3.PutBucketAclInput{
			AccessControlPolicy: &types.AccessControlPolicy{
				Grants: expandBucketGrants(d.Get("grant").(*schema.Set).List()),
				Owner:  bucketACL.Owner,
			},
			Bucket: aws.String(d.Id()),
		}

		_, err = tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
			return conn.PutBucketAcl(ctx, input)
		}, errCodeNoSuchBucket)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) ACL: %s", d.Id(), err)
		}
	}

	//
	// Bucket Logging.
	//
	if d.HasChange("logging") {
		input := &s3.PutBucketLoggingInput{
			Bucket:              aws.String(d.Id()),
			BucketLoggingStatus: &types.BucketLoggingStatus{},
		}

		if v, ok := d.GetOk("logging"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
			tfMap := v.([]any)[0].(map[string]any)

			input.BucketLoggingStatus.LoggingEnabled = &types.LoggingEnabled{}

			if v, ok := tfMap["target_bucket"].(string); ok && v != "" {
				input.BucketLoggingStatus.LoggingEnabled.TargetBucket = aws.String(v)
			}

			if v, ok := tfMap["target_prefix"].(string); ok && v != "" {
				input.BucketLoggingStatus.LoggingEnabled.TargetPrefix = aws.String(v)
			}
		}

		_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
			return conn.PutBucketLogging(ctx, input)
		}, errCodeNoSuchBucket)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) logging: %s", d.Id(), err)
		}
	}

	//
	// Bucket Lifecycle Configuration.
	//
	if d.HasChange("lifecycle_rule") {
		if v, ok := d.GetOk("lifecycle_rule"); !ok || len(v.([]any)) == 0 {
			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.DeleteBucketLifecycle(ctx, &s3.DeleteBucketLifecycleInput{
					Bucket: aws.String(d.Id()),
				})
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting S3 Bucket (%s) lifecycle configuration: %s", d.Id(), err)
			}
		} else {
			input := &s3.PutBucketLifecycleConfigurationInput{
				Bucket: aws.String(d.Id()),
				LifecycleConfiguration: &types.BucketLifecycleConfiguration{
					Rules: expandBucketLifecycleRules(ctx, v.([]any)),
				},
			}

			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.PutBucketLifecycleConfiguration(ctx, input)
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) lifecycle configuration: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket Accelerate Configuration.
	//
	if d.HasChange("acceleration_status") {
		input := &s3.PutBucketAccelerateConfigurationInput{
			AccelerateConfiguration: &types.AccelerateConfiguration{
				Status: types.BucketAccelerateStatus(d.Get("acceleration_status").(string)),
			},
			Bucket: aws.String(d.Id()),
		}

		_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
			return conn.PutBucketAccelerateConfiguration(ctx, input)
		}, errCodeNoSuchBucket)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) accelerate configuration: %s", d.Id(), err)
		}
	}

	//
	// Bucket Request Payment Configuration.
	//
	if d.HasChange("request_payer") {
		input := &s3.PutBucketRequestPaymentInput{
			Bucket: aws.String(d.Id()),
			RequestPaymentConfiguration: &types.RequestPaymentConfiguration{
				Payer: types.Payer(d.Get("request_payer").(string)),
			},
		}

		_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
			return conn.PutBucketRequestPayment(ctx, input)
		}, errCodeNoSuchBucket)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) request payment configuration: %s", d.Id(), err)
		}
	}

	//
	// Bucket Replication Configuration.
	//
	if d.HasChange("replication_configuration") {
		if v, ok := d.GetOk("replication_configuration"); !ok || len(v.([]any)) == 0 || v.([]any)[0] == nil {
			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.DeleteBucketReplication(ctx, &s3.DeleteBucketReplicationInput{
					Bucket: aws.String(d.Id()),
				})
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting S3 Bucket (%s) replication configuration: %s", d.Id(), err)
			}
		} else {
			hasVersioning := false

			// Validate that bucket versioning is enabled.
			if v, ok := d.GetOk("versioning"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
				tfMap := v.([]any)[0].(map[string]any)

				if tfMap[names.AttrEnabled].(bool) {
					hasVersioning = true
				}
			}

			if !hasVersioning {
				return sdkdiag.AppendErrorf(diags, "versioning must be enabled on S3 Bucket (%s) to allow replication", d.Id())
			}

			input := &s3.PutBucketReplicationInput{
				Bucket:                   aws.String(d.Id()),
				ReplicationConfiguration: expandBucketReplicationConfiguration(ctx, v.([]any)),
			}

			_, err := tfresource.RetryWhen(ctx, d.Timeout(schema.TimeoutUpdate),
				func(ctx context.Context) (any, error) {
					return conn.PutBucketReplication(ctx, input)
				},
				func(err error) (bool, error) {
					if tfawserr.ErrCodeEquals(err, errCodeNoSuchBucket) || tfawserr.ErrMessageContains(err, errCodeInvalidRequest, "Versioning must be 'Enabled' on the bucket") {
						return true, err
					}

					return false, err
				},
			)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) replication configuration: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket Server-side Encryption Configuration.
	//
	if d.HasChange("server_side_encryption_configuration") {
		if v, ok := d.GetOk("server_side_encryption_configuration"); !ok || len(v.([]any)) == 0 {
			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.DeleteBucketEncryption(ctx, &s3.DeleteBucketEncryptionInput{
					Bucket: aws.String(d.Id()),
				})
			}, errCodeNoSuchBucket)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting S3 Bucket (%s) server-side encryption configuration: %s", d.Id(), err)
			}
		} else {
			input := &s3.PutBucketEncryptionInput{
				Bucket: aws.String(d.Id()),
				ServerSideEncryptionConfiguration: &types.ServerSideEncryptionConfiguration{
					Rules: expandBucketServerSideEncryptionRules(v.([]any)),
				},
			}

			_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
				return conn.PutBucketEncryption(ctx, input)
			}, errCodeNoSuchBucket, errCodeOperationAborted)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) server-side encryption configuration: %s", d.Id(), err)
			}
		}
	}

	//
	// Bucket Object Lock Configuration.
	//
	if d.HasChange("object_lock_configuration") {
		// S3 Object Lock configuration cannot be deleted, only updated.
		input := &s3.PutObjectLockConfigurationInput{
			Bucket:                  aws.String(d.Id()),
			ObjectLockConfiguration: expandBucketObjectLockConfiguration(d.Get("object_lock_configuration").([]any)),
		}

		_, err := tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutUpdate), func(ctx context.Context) (any, error) {
			return conn.PutObjectLockConfiguration(ctx, input)
		}, errCodeNoSuchBucket)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "putting S3 Bucket (%s) object lock configuration: %s", d.Id(), err)
		}
	}

	return append(diags, resourceBucketRead(ctx, d, meta)...)
}
