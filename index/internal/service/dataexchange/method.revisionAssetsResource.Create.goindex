package github.com/hashicorp/terraform-provider-aws/internal/service/dataexchange
import (
	"context"
	"crypto/md5" // nosemgrep: go/sast/internal/crypto/md5 -- AWS DataExchange API requires MD5 for asset upload integrity checking
	"errors"
	"fmt"
	"io"
	"iter"
	"net/http"
	"os"
	"slices"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/dataexchange"
	awstypes "github.com/aws/aws-sdk-go-v2/service/dataexchange/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/setvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/fwdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	"github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/names"
	"github.com/hashicorp/terraform-provider-aws/version"
)
func (r *revisionAssetsResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	conn := r.Meta().DataExchangeClient(ctx)

	var plan revisionAssetsResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	finalized := plan.Finalized.ValueBool()
	var input dataexchange.CreateRevisionInput
	resp.Diagnostics.Append(flex.Expand(ctx, plan, &input)...)
	if resp.Diagnostics.HasError() {
		return
	}
	input.Tags = getTagsIn(ctx)

	out, err := conn.CreateRevision(ctx, &input)
	if err != nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, plan.DataSetID.String(), err),
			err.Error(),
		)
		return
	}
	if out == nil {
		resp.Diagnostics.AddError(
			create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, plan.DataSetID.String(), nil),
			errors.New("empty output").Error(),
		)
		return
	}

	resp.Diagnostics.Append(flex.Flatten(ctx, out, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// NOTE: This is currently sequential, because there is no direct linkage between the Job and the Asset that it creates.
	// If unique names were enforced for each asset, they could be done in parallel, but alas.
	// Assets can be renamed *after* the Job that creates them is complete.
	// The `ImportAssetsFromSignedURL` Job technically requires a `Name` parameter, but I've defaulted to the name of the file.
	// This should probably be changed to explicitly require the `name`
	revisionID := aws.ToString(out.Id)
	assets := make([]assetModel, len(plan.Assets.Elements()))
	existingAssetIDs := make([]string, 0, len(plan.Assets.Elements()))
	for i, asset := range nestedObjectCollectionAllMust[assetModel](ctx, plan.Assets) {
		switch {
		case !asset.ImportAssetsFromS3.IsNull():
			importAssetsFromS3, d := asset.ImportAssetsFromS3.ToPtr(ctx)
			resp.Diagnostics.Append(d...)
			if d.HasError() {
				return
			}

			var importAssetsFromS3RequestDetails awstypes.ImportAssetsFromS3RequestDetails
			resp.Diagnostics.Append(flex.Expand(ctx, importAssetsFromS3, &importAssetsFromS3RequestDetails)...)
			if resp.Diagnostics.HasError() {
				return
			}
			importAssetsFromS3RequestDetails.DataSetId = plan.DataSetID.ValueStringPointer()
			importAssetsFromS3RequestDetails.RevisionId = plan.ID.ValueStringPointer()

			requestDetails := awstypes.RequestDetails{
				ImportAssetsFromS3: &importAssetsFromS3RequestDetails,
			}
			createJobInput := dataexchange.CreateJobInput{
				Type:    awstypes.TypeImportAssetsFromS3,
				Details: &requestDetails,
			}
			createJobOutput, err := conn.CreateJob(ctx, &createJobInput)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
				return
			}
			if createJobOutput == nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, nil),
					errors.New("empty output").Error(),
				)
				return
			}

			err = startJob(ctx, createJobOutput.Id, conn)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
				return
			}

			createTimeout := r.CreateTimeout(ctx, plan.Timeouts)
			_, err = waitJobCompleted(ctx, conn, aws.ToString(createJobOutput.Id), createTimeout)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
				return
			}

			listAssetsInput := dataexchange.ListRevisionAssetsInput{
				DataSetId:  plan.DataSetID.ValueStringPointer(),
				RevisionId: plan.ID.ValueStringPointer(),
			}
			newAsset, err := getRevisionAsset(ctx, conn, listAssetsInput, existingAssetIDs)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
			}

			resp.Diagnostics.Append(flex.Flatten(ctx, newAsset, asset)...)
			if resp.Diagnostics.HasError() {
				return
			}
			assets[i] = *asset // nosemgrep:ci.semgrep.aws.prefer-pointer-conversion-assignment
			existingAssetIDs = append(existingAssetIDs, aws.ToString(newAsset.Id))

		case !asset.ImportAssetsFromSignedURL.IsNull():
			/* calling defer functions directly in a loop is bad practice and can cause resource leaks
			by deferring all deferred actions until the end of the function.
			Wrapping execution in anonymous function to ensure deferred actions are executed at the end of each iteration.
			*/
			func() {
				importAssetsFromSignedURL, d := asset.ImportAssetsFromSignedURL.ToPtr(ctx)
				resp.Diagnostics.Append(d...)
				if d.HasError() {
					return
				}

				var importAssetFromSignedUrlRequestDetails awstypes.ImportAssetFromSignedUrlRequestDetails
				importAssetFromSignedUrlRequestDetails.DataSetId = plan.DataSetID.ValueStringPointer()
				importAssetFromSignedUrlRequestDetails.RevisionId = plan.ID.ValueStringPointer()
				// Default `AssetName` to last path component?
				importAssetFromSignedUrlRequestDetails.AssetName = importAssetsFromSignedURL.Filename.ValueStringPointer()
				// Stream MD5
				f, err := os.Open(importAssetsFromSignedURL.Filename.ValueString())
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				defer func() {
					err := f.Close()
					if err != nil {
						tflog.Warn(ctx, "error closing file", map[string]any{
							"file":  f.Name(),
							"error": err.Error(),
						})
					}
				}()

				hash, err := md5Reader(f)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				importAssetFromSignedUrlRequestDetails.Md5Hash = aws.String(hash)

				_, err = f.Seek(0, 0)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				requestDetails := awstypes.RequestDetails{
					ImportAssetFromSignedUrl: &importAssetFromSignedUrlRequestDetails,
				}
				createJobInput := dataexchange.CreateJobInput{
					Type:    awstypes.TypeImportAssetFromSignedUrl,
					Details: &requestDetails,
				}
				createJobOutput, err := conn.CreateJob(ctx, &createJobInput)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}
				if createJobOutput == nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, nil),
						errors.New("empty output").Error(),
					)
					return
				}

				// Upload file to URL with PUT operation
				info, err := f.Stat()
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				const (
					uploadTimeout = 1 * time.Minute
				)
				ctxUpload, cancel := context.WithTimeout(ctx, uploadTimeout)
				defer cancel()

				request, err := http.NewRequestWithContext(ctxUpload, http.MethodPut, *createJobOutput.Details.ImportAssetFromSignedUrl.SignedUrl, f)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}
				request.ContentLength = info.Size()
				request.Header.Set("Content-MD5", hash)
				request.Header.Set("Provider-Version", version.ProviderVersion)
				request.Header.Set("Terraform-Version", r.Meta().TerraformVersion(ctx))

				httpClient := r.Meta().AwsConfig(ctx).HTTPClient
				response, err := httpClient.Do(request)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				defer func() {
					err := response.Body.Close()
					if err != nil {
						tflog.Warn(ctx, "error closing file", map[string]any{
							"file":  f.Name(),
							"error": err.Error(),
						})
					}
				}()

				if !(response.StatusCode >= http.StatusOK && response.StatusCode <= http.StatusIMUsed) {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, nil),
						fmt.Sprintf("Uploading to %q\n\nUnexpected HTTP response: %s", *createJobOutput.Details.ImportAssetFromSignedUrl.SignedUrl, response.Status),
					)
					return
				}
				_, err = io.Copy(io.Discard, response.Body)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				// Start Job
				err = startJob(ctx, createJobOutput.Id, conn)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				createTimeout := r.CreateTimeout(ctx, plan.Timeouts)
				_, err = waitJobCompleted(ctx, conn, aws.ToString(createJobOutput.Id), createTimeout)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
					return
				}

				// List assets
				listAssetsInput := dataexchange.ListRevisionAssetsInput{
					DataSetId:  plan.DataSetID.ValueStringPointer(),
					RevisionId: plan.ID.ValueStringPointer(),
				}
				newAsset, err := getRevisionAsset(ctx, conn, listAssetsInput, existingAssetIDs)
				if err != nil {
					resp.Diagnostics.AddError(
						create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
						err.Error(),
					)
				}

				resp.Diagnostics.Append(flex.Flatten(ctx, newAsset, asset)...)
				if resp.Diagnostics.HasError() {
					return
				}
				assets[i] = *asset // nosemgrep:ci.semgrep.aws.prefer-pointer-conversion-assignment
				existingAssetIDs = append(existingAssetIDs, aws.ToString(newAsset.Id))
			}()
		case !asset.CreateS3DataAccessFromS3Bucket.IsNull():
			createS3DataAccessFromS3Bucket, d := asset.CreateS3DataAccessFromS3Bucket.ToPtr(ctx)
			resp.Diagnostics.Append(d...)
			if d.HasError() {
				return
			}

			var createS3DataAccessFromS3BucketRequestDetails awstypes.CreateS3DataAccessFromS3BucketRequestDetails
			resp.Diagnostics.Append(flex.Expand(ctx, createS3DataAccessFromS3Bucket, &createS3DataAccessFromS3BucketRequestDetails)...)
			if resp.Diagnostics.HasError() {
				return
			}
			createS3DataAccessFromS3BucketRequestDetails.DataSetId = plan.DataSetID.ValueStringPointer()
			createS3DataAccessFromS3BucketRequestDetails.RevisionId = plan.ID.ValueStringPointer()

			requestDetails := awstypes.RequestDetails{
				CreateS3DataAccessFromS3Bucket: &createS3DataAccessFromS3BucketRequestDetails,
			}
			createJobInput := dataexchange.CreateJobInput{
				Type:    awstypes.TypeCreateS3DataAccessFromS3Bucket,
				Details: &requestDetails,
			}
			createJobOutput, err := conn.CreateJob(ctx, &createJobInput)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
				return
			}
			if createJobOutput == nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, nil),
					errors.New("empty output").Error(),
				)
				return
			}

			err = startJob(ctx, createJobOutput.Id, conn)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
				return
			}

			createTimeout := r.CreateTimeout(ctx, plan.Timeouts)
			_, err = waitJobCompleted(ctx, conn, aws.ToString(createJobOutput.Id), createTimeout)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
				return
			}

			in := dataexchange.ListRevisionAssetsInput{
				DataSetId:  plan.DataSetID.ValueStringPointer(),
				RevisionId: plan.ID.ValueStringPointer(),
			}
			newAsset, err := getRevisionAsset(ctx, conn, in, existingAssetIDs)
			if err != nil {
				resp.Diagnostics.AddError(
					create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
					err.Error(),
				)
			}

			resp.Diagnostics.Append(flex.Flatten(ctx, newAsset, asset)...)
			if resp.Diagnostics.HasError() {
				return
			}

			createS3DataAccessFromS3Bucket.AccessPointARN = flex.StringToFramework(ctx, newAsset.AssetDetails.S3DataAccessAsset.S3AccessPointArn)
			createS3DataAccessFromS3Bucket.AccessPointAlias = flex.StringToFramework(ctx, newAsset.AssetDetails.S3DataAccessAsset.S3AccessPointAlias)
			asset.CreateS3DataAccessFromS3Bucket = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, createS3DataAccessFromS3Bucket)
			assets[i] = *asset // nosemgrep:ci.semgrep.aws.prefer-pointer-conversion-assignment
			existingAssetIDs = append(existingAssetIDs, aws.ToString(newAsset.Id))
		}
	}

	assetsVal, d := fwtypes.NewSetNestedObjectValueOfValueSlice(ctx, assets)
	resp.Diagnostics.Append(d...)
	if d.HasError() {
		return
	}
	plan.Assets = assetsVal

	// finalize asset if requested
	if finalized {
		err = finalizeAsset(ctx, conn, plan.DataSetID.ValueString(), plan.ID.ValueString(), finalized)
		if err != nil {
			resp.Diagnostics.AddError(
				create.ProblemStandardMessage(names.DataExchange, create.ErrActionCreating, ResNameRevisionAssets, revisionID, err),
				err.Error(),
			)
			return
		}
		plan.Finalized = types.BoolValue(finalized)
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, plan)...)
}
