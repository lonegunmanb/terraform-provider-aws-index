package github.com/hashicorp/terraform-provider-aws/internal/service/autoscaling
import ( // nosemgrep:ci.semgrep.aws.multiple-service-imports
	"context"
	"errors"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/autoscaling"
	awstypes "github.com/aws/aws-sdk-go-v2/service/autoscaling/types"
	"github.com/aws/aws-sdk-go-v2/service/elasticloadbalancing"
	"github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2"
	elasticloadbalancingv2types "github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2/types/nullable"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func statusGroupCapacity(ctx context.Context, conn *autoscaling.Client, elbconn *elasticloadbalancing.Client, elbv2conn *elasticloadbalancingv2.Client, name string, cb func(int, int) error, startTime time.Time, ignoreFailedScalingActivities bool) retry.StateRefreshFunc {
	return func() (any, string, error) {
		if !ignoreFailedScalingActivities {
			// Check for fatal error in activity logs.
			scalingActivities, err := findScalingActivitiesByName(ctx, conn, name, startTime)

			if err != nil {
				return nil, "", fmt.Errorf("reading scaling activities: %w", err)
			}

			var errs []error

			for _, v := range scalingActivities {
				if v.StatusCode == awstypes.ScalingActivityStatusCodeFailed && aws.ToInt32(v.Progress) == 100 {
					if strings.Contains(aws.ToString(v.StatusMessage), "Invalid IAM Instance Profile") {
						// the activity will likely be retried
						continue
					}
					errs = append(errs, fmt.Errorf("scaling activity (%s): %s: %s", aws.ToString(v.ActivityId), v.StatusCode, aws.ToString(v.StatusMessage)))
				}
			}

			err = errors.Join(errs...)

			if err != nil {
				return nil, "", err
			}
		}

		g, err := findGroupByName(ctx, conn, name)

		if err != nil {
			return nil, "", fmt.Errorf("reading Auto Scaling Group (%s): %w", name, err)
		}

		lbInstanceStates, err := findELBInstanceStates(ctx, elbconn, g)

		if err != nil {
			return nil, "", err
		}

		targetGroupInstanceStates, err := findELBV2InstanceStates(ctx, elbv2conn, g)

		if err != nil {
			return nil, "", err
		}

		nASG := 0
		nELB := 0

		for _, v := range g.Instances {
			instanceID := aws.ToString(v.InstanceId)
			if instanceID == "" {
				continue
			}

			if aws.ToString(v.HealthStatus) != InstanceHealthStatusHealthy {
				continue
			}

			if v.LifecycleState != awstypes.LifecycleStateInService {
				continue
			}

			increment := 1
			if v := aws.ToString(v.WeightedCapacity); v != "" {
				v, _ := strconv.Atoi(v)
				increment = v
			}

			nASG += increment

			inAll := true

			for _, v := range lbInstanceStates {
				if state, ok := v[instanceID]; ok && state != elbInstanceStateInService {
					inAll = false
					break
				}
			}

			if inAll {
				for _, v := range targetGroupInstanceStates {
					if state, ok := v[instanceID]; ok && state != string(elasticloadbalancingv2types.TargetHealthStateEnumHealthy) {
						inAll = false
						break
					}
				}
			}

			if inAll {
				nELB += increment
			}
		}

		err = cb(nASG, nELB)

		if err != nil {
			return struct{}{}, err.Error(), nil //nolint:nilerr // err is passed via the result State
		}

		return struct{}{}, "ok", nil
	}
}
