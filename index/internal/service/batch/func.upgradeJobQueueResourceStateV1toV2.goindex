package github.com/hashicorp/terraform-provider-aws/internal/service/batch
import (
	"context"

	"github.com/YakDriver/regexache"
	awstypes "github.com/aws/aws-sdk-go-v2/service/batch/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func upgradeJobQueueResourceStateV1toV2(ctx context.Context, request resource.UpgradeStateRequest, response *resource.UpgradeStateResponse) {
	var jobQueueDataV1 resourceJobQueueDataV1
	response.Diagnostics.Append(request.State.Get(ctx, &jobQueueDataV1)...)
	if response.Diagnostics.HasError() {
		return
	}

	jobQueueDataV2 := jobQueueResourceModel{
		ComputeEnvironmentOrder:  jobQueueDataV1.ComputeEnvironmentOrder,
		ID:                       jobQueueDataV1.ID,
		JobQueueARN:              jobQueueDataV1.JobQueueARN,
		JobQueueName:             jobQueueDataV1.JobQueueName,
		JobStateTimeLimitActions: jobQueueDataV1.JobStateTimeLimitActions,
		Priority:                 jobQueueDataV1.Priority,
		State:                    jobQueueDataV1.State,
		Tags:                     jobQueueDataV1.Tags,
		TagsAll:                  jobQueueDataV1.TagsAll,
		Timeouts:                 jobQueueDataV1.Timeouts,
		SchedulingPolicyARN:      jobQueueDataV1.SchedulingPolicyARN,
	}

	if !jobQueueDataV1.ComputeEnvironments.IsNull() {
		var computeEnvironments []string
		diags := jobQueueDataV1.ComputeEnvironments.ElementsAs(ctx, &computeEnvironments, false)
		response.Diagnostics.Append(diags...)
		if response.Diagnostics.HasError() {
			return
		}
		computeEnvironmentOrder := make([]*computeEnvironmentOrderModel, len(computeEnvironments))
		for i, env := range computeEnvironments {
			computeEnvironmentOrder[i] = &computeEnvironmentOrderModel{
				ComputeEnvironment: fwtypes.ARNValue(env),
				Order:              types.Int64Value(int64(i)),
			}
		}
		jobQueueDataV2.ComputeEnvironmentOrder = fwtypes.NewListNestedObjectValueOfSliceMust(ctx, computeEnvironmentOrder)
	}

	response.Diagnostics.Append(response.State.Set(ctx, jobQueueDataV2)...)
}
