package github.com/hashicorp/terraform-provider-aws/internal/service/batch
import (
	"context"
	"fmt"
	"log"
	"reflect"
	"strings"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/batch"
	awstypes "github.com/aws/aws-sdk-go-v2/service/batch/types"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/provider/sdkv2/importer"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func expandContainers(tfList []any) []awstypes.EksContainer {
	var apiObjects []awstypes.EksContainer

	for _, tfMapRaw := range tfList {
		tfMap := tfMapRaw.(map[string]any)
		apiObject := awstypes.EksContainer{}

		if v, ok := tfMap["args"]; ok {
			apiObject.Args = flex.ExpandStringValueList(v.([]any))
		}

		if v, ok := tfMap["command"]; ok {
			apiObject.Command = flex.ExpandStringValueList(v.([]any))
		}

		if v, ok := tfMap["env"].(*schema.Set); ok && v.Len() > 0 {
			apiObjects := []awstypes.EksContainerEnvironmentVariable{}

			for _, tfMapRaw := range v.List() {
				apiObject := awstypes.EksContainerEnvironmentVariable{}
				tfMap := tfMapRaw.(map[string]any)

				if v, ok := tfMap[names.AttrName].(string); ok && v != "" {
					apiObject.Name = aws.String(v)
				}

				if v, ok := tfMap[names.AttrValue].(string); ok && v != "" {
					apiObject.Value = aws.String(v)
				}

				apiObjects = append(apiObjects, apiObject)
			}

			apiObject.Env = apiObjects
		}

		if v, ok := tfMap["image"]; ok {
			apiObject.Image = aws.String(v.(string))
		}

		if v, ok := tfMap["image_pull_policy"].(string); ok && v != "" {
			apiObject.ImagePullPolicy = aws.String(v)
		}

		if v, ok := tfMap[names.AttrName].(string); ok && v != "" {
			apiObject.Name = aws.String(v)
		}

		if v, ok := tfMap[names.AttrResources].([]any); ok && len(v) > 0 {
			resources := &awstypes.EksContainerResourceRequirements{}
			tfMap := v[0].(map[string]any)

			if v, ok := tfMap["limits"]; ok {
				resources.Limits = flex.ExpandStringValueMap(v.(map[string]any))
			}

			if v, ok := tfMap["requests"]; ok {
				resources.Requests = flex.ExpandStringValueMap(v.(map[string]any))
			}

			apiObject.Resources = resources
		}

		if v, ok := tfMap["security_context"].([]any); ok && len(v) > 0 {
			securityContext := &awstypes.EksContainerSecurityContext{}
			tfMap := v[0].(map[string]any)

			if v, ok := tfMap["privileged"]; ok {
				securityContext.Privileged = aws.Bool(v.(bool))
			}

			if v, ok := tfMap["read_only_root_file_system"]; ok {
				securityContext.ReadOnlyRootFilesystem = aws.Bool(v.(bool))
			}

			if v, ok := tfMap["run_as_group"]; ok {
				securityContext.RunAsGroup = aws.Int64(int64(v.(int)))
			}

			if v, ok := tfMap["run_as_non_root"]; ok {
				securityContext.RunAsNonRoot = aws.Bool(v.(bool))
			}

			if v, ok := tfMap["run_as_user"]; ok {
				securityContext.RunAsUser = aws.Int64(int64(v.(int)))
			}

			apiObject.SecurityContext = securityContext
		}

		if v, ok := tfMap["volume_mounts"]; ok {
			apiObject.VolumeMounts = expandVolumeMounts(v.([]any))
		}

		apiObjects = append(apiObjects, apiObject)
	}

	return apiObjects
}
