package github.com/hashicorp/terraform-provider-aws/internal/service/events
import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/eventbridge"
	"github.com/aws/aws-sdk-go-v2/service/eventbridge/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceConnection() *schema.Resource {
	return &schema.Resource{
		CreateWithoutTimeout: resourceConnectionCreate,
		ReadWithoutTimeout:   resourceConnectionRead,
		UpdateWithoutTimeout: resourceConnectionUpdate,
		DeleteWithoutTimeout: resourceConnectionDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		SchemaFunc: func() map[string]*schema.Schema {
			connectionHttpParameters := func(parent string) *schema.Resource {
				element := func() *schema.Resource {
					return &schema.Resource{
						Schema: map[string]*schema.Schema{
							"is_value_secret": {
								Type:     schema.TypeBool,
								Optional: true,
								Default:  false,
							},
							names.AttrKey: {
								Type:     schema.TypeString,
								Optional: true,
							},
							names.AttrValue: {
								Type:      schema.TypeString,
								Optional:  true,
								Sensitive: true,
							},
						},
					}
				}
				atLeastOneOf := []string{
					fmt.Sprintf("%s.0.body", parent),
					fmt.Sprintf("%s.0.header", parent),
					fmt.Sprintf("%s.0.query_string", parent),
				}

				return &schema.Resource{
					Schema: map[string]*schema.Schema{
						"body": {
							Type:         schema.TypeList,
							Optional:     true,
							Elem:         element(),
							AtLeastOneOf: atLeastOneOf,
						},
						names.AttrHeader: {
							Type:         schema.TypeList,
							Optional:     true,
							Elem:         element(),
							AtLeastOneOf: atLeastOneOf,
						},
						"query_string": {
							Type:         schema.TypeList,
							Optional:     true,
							Elem:         element(),
							AtLeastOneOf: atLeastOneOf,
						},
					},
				}
			}

			return map[string]*schema.Schema{
				names.AttrARN: {
					Type:     schema.TypeString,
					Computed: true,
				},
				"auth_parameters": {
					Type:     schema.TypeList,
					Required: true,
					MaxItems: 1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"api_key": {
								Type:     schema.TypeList,
								Optional: true,
								MaxItems: 1,
								ExactlyOneOf: []string{
									"auth_parameters.0.api_key",
									"auth_parameters.0.basic",
									"auth_parameters.0.oauth",
								},
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										names.AttrKey: {
											Type:     schema.TypeString,
											Required: true,
											ValidateFunc: validation.All(
												validation.StringLenBetween(1, 512),
											),
										},
										names.AttrValue: {
											Type:      schema.TypeString,
											Required:  true,
											Sensitive: true,
											ValidateFunc: validation.All(
												validation.StringLenBetween(1, 512),
											),
										},
									},
								},
							},
							"basic": {
								Type:     schema.TypeList,
								Optional: true,
								MaxItems: 1,
								ExactlyOneOf: []string{
									"auth_parameters.0.api_key",
									"auth_parameters.0.basic",
									"auth_parameters.0.oauth",
								},
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										names.AttrPassword: {
											Type:      schema.TypeString,
											Required:  true,
											Sensitive: true,
											ValidateFunc: validation.All(
												validation.StringLenBetween(1, 512),
											),
										},
										names.AttrUsername: {
											Type:     schema.TypeString,
											Required: true,
											ValidateFunc: validation.All(
												validation.StringLenBetween(1, 512),
											),
										},
									},
								},
							},
							"invocation_http_parameters": {
								Type:     schema.TypeList,
								Optional: true,
								MaxItems: 1,
								Elem:     connectionHttpParameters("auth_parameters.0.invocation_http_parameters"),
							},
							"oauth": {
								Type:     schema.TypeList,
								Optional: true,
								MaxItems: 1,
								ExactlyOneOf: []string{
									"auth_parameters.0.api_key",
									"auth_parameters.0.basic",
									"auth_parameters.0.oauth",
								},
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"authorization_endpoint": {
											Type:     schema.TypeString,
											Required: true,
											ValidateFunc: validation.All(
												validation.StringLenBetween(1, 2048),
											),
										},
										"client_parameters": {
											Type:     schema.TypeList,
											Optional: true,
											MaxItems: 1,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													names.AttrClientID: {
														Type:     schema.TypeString,
														Required: true,
														ValidateFunc: validation.All(
															validation.StringLenBetween(1, 512),
														),
													},
													names.AttrClientSecret: {
														Type:      schema.TypeString,
														Required:  true,
														Sensitive: true,
														ValidateFunc: validation.All(
															validation.StringLenBetween(1, 512),
														),
													},
												},
											},
										},
										"http_method": {
											Type:             schema.TypeString,
											Required:         true,
											ValidateDiagFunc: enum.Validate[types.ConnectionOAuthHttpMethod](),
										},
										"oauth_http_parameters": {
											Type:     schema.TypeList,
											Required: true,
											MaxItems: 1,
											Elem:     connectionHttpParameters("auth_parameters.0.oauth.0.oauth_http_parameters"),
										},
									},
								},
							},
						},
					},
				},
				"authorization_type": {
					Type:             schema.TypeString,
					Required:         true,
					ValidateDiagFunc: enum.Validate[types.ConnectionAuthorizationType](),
				},
				names.AttrDescription: {
					Type:         schema.TypeString,
					Optional:     true,
					ValidateFunc: validation.StringLenBetween(0, 512),
				},
				"invocation_connectivity_parameters": {
					Type:     schema.TypeList,
					Optional: true,
					MaxItems: 1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"resource_parameters": {
								Type:     schema.TypeList,
								Required: true,
								MaxItems: 1,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"resource_association_arn": {
											Type:     schema.TypeString,
											Computed: true,
										},
										"resource_configuration_arn": {
											Type:         schema.TypeString,
											Required:     true,
											ValidateFunc: verify.ValidARN,
										},
									},
								},
							},
						},
					},
				},
				"kms_key_identifier": {
					Type:     schema.TypeString,
					Optional: true,
					ValidateFunc: validation.All(
						validation.StringLenBetween(0, 2048),
						validation.StringMatch(regexache.MustCompile(`^[a-zA-Z0-9_\-/:]*$`), ""),
					),
				},
				names.AttrName: {
					Type:     schema.TypeString,
					Required: true,
					ForceNew: true,
					ValidateFunc: validation.All(
						validation.StringLenBetween(1, 64),
						validation.StringMatch(regexache.MustCompile(`^[0-9A-Za-z_.-]+`), ""),
					),
				},
				"secret_arn": {
					Type:     schema.TypeString,
					Computed: true,
				},
			}
		},
	}
}
