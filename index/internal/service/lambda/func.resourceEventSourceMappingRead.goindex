package github.com/hashicorp/terraform-provider-aws/internal/service/lambda
import (
	"context"
	"errors"
	"log"
	"slices"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	awstypes "github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceEventSourceMappingRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).LambdaClient(ctx)

	output, err := findEventSourceMappingByID(ctx, conn, d.Id())

	if !d.IsNewResource() && tfresource.NotFound(err) {
		log.Printf("[WARN] Lambda Event Source Mapping (%s) not found, removing from state", d.Id())
		d.SetId("")
		return diags
	}

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "reading Lambda Event Source Mapping (%s): %s", d.Id(), err)
	}

	if output.AmazonManagedKafkaEventSourceConfig != nil {
		if err := d.Set("amazon_managed_kafka_event_source_config", []any{flattenAmazonManagedKafkaEventSourceConfig(output.AmazonManagedKafkaEventSourceConfig)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting amazon_managed_kafka_event_source_config: %s", err)
		}
	} else {
		d.Set("amazon_managed_kafka_event_source_config", nil)
	}
	d.Set(names.AttrARN, output.EventSourceMappingArn)
	d.Set("batch_size", output.BatchSize)
	d.Set("bisect_batch_on_function_error", output.BisectBatchOnFunctionError)
	if output.DestinationConfig != nil {
		if err := d.Set("destination_config", []any{flattenDestinationConfig(output.DestinationConfig)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting destination_config: %s", err)
		}
	} else {
		d.Set("destination_config", nil)
	}
	if output.DocumentDBEventSourceConfig != nil {
		if err := d.Set("document_db_event_source_config", []any{flattenDocumentDBEventSourceConfig(output.DocumentDBEventSourceConfig)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting document_db_event_source_config: %s", err)
		}
	} else {
		d.Set("document_db_event_source_config", nil)
	}
	d.Set("event_source_arn", output.EventSourceArn)
	if v := output.FilterCriteria; v != nil {
		if err := d.Set("filter_criteria", []any{flattenFilterCriteria(v)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting filter criteria: %s", err)
		}
	} else {
		d.Set("filter_criteria", nil)
	}
	d.Set(names.AttrFunctionARN, output.FunctionArn)
	d.Set("function_name", output.FunctionArn)
	d.Set("function_response_types", output.FunctionResponseTypes)
	d.Set(names.AttrKMSKeyARN, output.KMSKeyArn)
	if output.LastModified != nil {
		d.Set("last_modified", aws.ToTime(output.LastModified).Format(time.RFC3339))
	} else {
		d.Set("last_modified", nil)
	}
	d.Set("last_processing_result", output.LastProcessingResult)
	d.Set("maximum_batching_window_in_seconds", output.MaximumBatchingWindowInSeconds)
	d.Set("maximum_record_age_in_seconds", output.MaximumRecordAgeInSeconds)
	d.Set("maximum_retry_attempts", output.MaximumRetryAttempts)
	if v := output.MetricsConfig; v != nil {
		if err := d.Set("metrics_config", []any{flattenEventSourceMappingMetricsConfig(v)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting metrics_config: %s", err)
		}
	} else {
		d.Set("metrics_config", nil)
	}
	d.Set("parallelization_factor", output.ParallelizationFactor)
	if v := output.ProvisionedPollerConfig; v != nil {
		if err := d.Set("provisioned_poller_config", []any{flattenProvisionedPollerConfig(v)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting provisioned_poller_config: %s", err)
		}
	} else {
		d.Set("provisioned_poller_config", nil)
	}
	d.Set("queues", output.Queues)
	if v := output.ScalingConfig; v != nil {
		if err := d.Set("scaling_config", []any{flattenScalingConfig(v)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting scaling_config: %s", err)
		}
	} else {
		d.Set("scaling_config", nil)
	}
	if output.SelfManagedEventSource != nil {
		if err := d.Set("self_managed_event_source", []any{flattenSelfManagedEventSource(output.SelfManagedEventSource)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting self_managed_event_source: %s", err)
		}
	} else {
		d.Set("self_managed_event_source", nil)
	}
	if output.SelfManagedKafkaEventSourceConfig != nil {
		if err := d.Set("self_managed_kafka_event_source_config", []any{flattenSelfManagedKafkaEventSourceConfig(output.SelfManagedKafkaEventSourceConfig)}); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting self_managed_kafka_event_source_config: %s", err)
		}
	} else {
		d.Set("self_managed_kafka_event_source_config", nil)
	}
	if err := d.Set("source_access_configuration", flattenSourceAccessConfigurations(output.SourceAccessConfigurations)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting source_access_configuration: %s", err)
	}
	d.Set("starting_position", output.StartingPosition)
	if output.StartingPositionTimestamp != nil {
		d.Set("starting_position_timestamp", aws.ToTime(output.StartingPositionTimestamp).Format(time.RFC3339))
	} else {
		d.Set("starting_position_timestamp", nil)
	}
	d.Set(names.AttrState, output.State)
	d.Set("state_transition_reason", output.StateTransitionReason)
	d.Set("topics", output.Topics)
	d.Set("tumbling_window_in_seconds", output.TumblingWindowInSeconds)
	d.Set("uuid", output.UUID)

	switch state := d.Get(names.AttrState).(string); state {
	case eventSourceMappingStateEnabled, eventSourceMappingStateEnabling:
		d.Set(names.AttrEnabled, true)
	case eventSourceMappingStateDisabled, eventSourceMappingStateDisabling:
		d.Set(names.AttrEnabled, false)
	default:
		log.Printf("[WARN] Lambda Event Source Mapping (%s) is neither enabled nor disabled, but %s", d.Id(), state)
		d.Set(names.AttrEnabled, nil)
	}

	return diags
}
