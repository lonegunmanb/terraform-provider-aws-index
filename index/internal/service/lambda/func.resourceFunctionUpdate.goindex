package github.com/hashicorp/terraform-provider-aws/internal/service/lambda
import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	awstypes "github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/endpoints"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tfio "github.com/hashicorp/terraform-provider-aws/internal/io"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	tfec2 "github.com/hashicorp/terraform-provider-aws/internal/service/ec2"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceFunctionUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).LambdaClient(ctx)

	if d.HasChange("code_signing_config_arn") {
		if v, ok := d.GetOk("code_signing_config_arn"); ok {
			input := &lambda.PutFunctionCodeSigningConfigInput{
				CodeSigningConfigArn: aws.String(v.(string)),
				FunctionName:         aws.String(d.Id()),
			}

			_, err := conn.PutFunctionCodeSigningConfig(ctx, input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "setting Lambda Function (%s) code signing config: %s", d.Id(), err)
			}
		} else {
			_, err := conn.DeleteFunctionCodeSigningConfig(ctx, &lambda.DeleteFunctionCodeSigningConfigInput{
				FunctionName: aws.String(d.Id()),
			})

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting Lambda Function (%s) code signing config: %s", d.Id(), err)
			}
		}
	}

	configUpdate := needsFunctionConfigUpdate(d)
	if configUpdate {
		input := &lambda.UpdateFunctionConfigurationInput{
			FunctionName: aws.String(d.Id()),
		}

		if d.HasChange("dead_letter_config") {
			if v, ok := d.GetOk("dead_letter_config"); ok && len(v.([]any)) > 0 {
				if v.([]any)[0] == nil {
					return sdkdiag.AppendErrorf(diags, "nil dead_letter_config supplied for function: %s", d.Id())
				}

				input.DeadLetterConfig = &awstypes.DeadLetterConfig{
					TargetArn: aws.String(v.([]any)[0].(map[string]any)[names.AttrTargetARN].(string)),
				}
			} else {
				input.DeadLetterConfig = &awstypes.DeadLetterConfig{
					TargetArn: aws.String(""),
				}
			}
		}

		if d.HasChange(names.AttrDescription) {
			input.Description = aws.String(d.Get(names.AttrDescription).(string))
		}

		if d.HasChanges(names.AttrEnvironment, names.AttrKMSKeyARN) {
			input.Environment = &awstypes.Environment{
				Variables: map[string]string{},
			}

			if v, ok := d.GetOk(names.AttrEnvironment); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
				if v, ok := v.([]any)[0].(map[string]any)["variables"].(map[string]any); ok && len(v) > 0 {
					input.Environment = &awstypes.Environment{
						Variables: flex.ExpandStringValueMap(v),
					}
				}
			}
		}

		if d.HasChange("ephemeral_storage") {
			if v, ok := d.GetOk("ephemeral_storage"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
				input.EphemeralStorage = &awstypes.EphemeralStorage{
					Size: aws.Int32(int32(v.([]any)[0].(map[string]any)[names.AttrSize].(int))),
				}
			}
		}

		if d.HasChange("file_system_config") {
			if v, ok := d.GetOk("file_system_config"); ok && len(v.([]any)) > 0 {
				input.FileSystemConfigs = expandFileSystemConfigs(v.([]any))
			} else {
				input.FileSystemConfigs = []awstypes.FileSystemConfig{}
			}
		}

		if d.HasChange("handler") {
			input.Handler = aws.String(d.Get("handler").(string))
		}

		if d.HasChange("image_config") {
			if v, ok := d.GetOk("image_config"); ok && len(v.([]any)) > 0 {
				input.ImageConfig = expandImageConfigs(v.([]any))
			} else {
				input.ImageConfig = &awstypes.ImageConfig{}
			}
		}

		if d.HasChange(names.AttrKMSKeyARN) {
			input.KMSKeyArn = aws.String(d.Get(names.AttrKMSKeyARN).(string))
		}

		if d.HasChange("layers") {
			input.Layers = flex.ExpandStringValueList(d.Get("layers").([]any))
		}

		if d.HasChange("logging_config") {
			input.LoggingConfig = expandLoggingConfig(d.Get("logging_config").([]any))
		}

		if d.HasChange("memory_size") {
			input.MemorySize = aws.Int32(int32(d.Get("memory_size").(int)))
		}

		if d.HasChange(names.AttrRole) {
			input.Role = aws.String(d.Get(names.AttrRole).(string))
		}

		if d.HasChange("runtime") {
			input.Runtime = awstypes.Runtime(d.Get("runtime").(string))
		}

		if d.HasChange("snap_start") {
			input.SnapStart = expandSnapStart(d.Get("snap_start").([]any))
		}

		if d.HasChange(names.AttrTimeout) {
			input.Timeout = aws.Int32(int32(d.Get(names.AttrTimeout).(int)))
		}

		if d.HasChange("tracing_config") {
			if v, ok := d.GetOk("tracing_config"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
				input.TracingConfig = &awstypes.TracingConfig{
					Mode: awstypes.TracingMode(v.([]any)[0].(map[string]any)[names.AttrMode].(string)),
				}
			}
		}

		if d.HasChanges("vpc_config.0.security_group_ids", "vpc_config.0.subnet_ids", "vpc_config.0.ipv6_allowed_for_dual_stack") {
			if v, ok := d.GetOk(names.AttrVPCConfig); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
				tfMap := v.([]any)[0].(map[string]any)
				input.VpcConfig = &awstypes.VpcConfig{
					Ipv6AllowedForDualStack: aws.Bool(tfMap["ipv6_allowed_for_dual_stack"].(bool)),
					SecurityGroupIds:        flex.ExpandStringValueSet(tfMap[names.AttrSecurityGroupIDs].(*schema.Set)),
					SubnetIds:               flex.ExpandStringValueSet(tfMap[names.AttrSubnetIDs].(*schema.Set)),
				}
			} else {
				input.VpcConfig = &awstypes.VpcConfig{
					Ipv6AllowedForDualStack: aws.Bool(false),
					SecurityGroupIds:        []string{},
					SubnetIds:               []string{},
				}
			}
		}

		_, err := retryFunctionOp(ctx, func() (*lambda.UpdateFunctionConfigurationOutput, error) {
			return conn.UpdateFunctionConfiguration(ctx, input)
		})

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating Lambda Function (%s) configuration: %s", d.Id(), err)
		}

		if _, err := waitFunctionUpdated(ctx, conn, d.Id(), d.Timeout(schema.TimeoutUpdate)); err != nil {
			return sdkdiag.AppendErrorf(diags, "waiting for Lambda Function (%s) configuration update: %s", d.Id(), err)
		}
	}

	codeUpdate := needsFunctionCodeUpdate(d)
	if codeUpdate {
		input := &lambda.UpdateFunctionCodeInput{
			FunctionName: aws.String(d.Id()),
		}

		if d.HasChange("architectures") {
			if v, ok := d.GetOk("architectures"); ok && len(v.([]any)) > 0 {
				input.Architectures = flex.ExpandStringyValueList[awstypes.Architecture](v.([]any))
			}
		}

		if v, ok := d.GetOk("filename"); ok {
			// Grab an exclusive lock so that we're only reading one function into memory at a time.
			// See https://github.com/hashicorp/terraform/issues/9364
			conns.GlobalMutexKV.Lock(mutexKey)
			defer conns.GlobalMutexKV.Unlock(mutexKey)

			zipFile, err := tfio.ReadFileContents(v.(string))

			if err != nil {
				// As filename isn't set in resourceFunctionRead(), don't ovewrite the last known good value.
				old, _ := d.GetChange("filename")
				d.Set("filename", old)

				return sdkdiag.AppendErrorf(diags, "reading ZIP file (%s): %s", v, err)
			}

			input.ZipFile = zipFile
		} else if v, ok := d.GetOk("image_uri"); ok {
			input.ImageUri = aws.String(v.(string))
		} else {
			input.S3Bucket = aws.String(d.Get(names.AttrS3Bucket).(string))
			input.S3Key = aws.String(d.Get("s3_key").(string))
			if v, ok := d.GetOk("s3_object_version"); ok {
				input.S3ObjectVersion = aws.String(v.(string))
			}
		}

		_, err := conn.UpdateFunctionCode(ctx, input)

		if err != nil {
			if errs.IsAErrorMessageContains[*awstypes.InvalidParameterValueException](err, "Error occurred while GetObject.") {
				// As s3_bucket, s3_key and s3_object_version aren't set in resourceFunctionRead(), don't ovewrite the last known good values.
				for _, key := range []string{names.AttrS3Bucket, "s3_key", "s3_object_version"} {
					old, _ := d.GetChange(key)
					d.Set(key, old)
				}
			}

			return sdkdiag.AppendErrorf(diags, "updating Lambda Function (%s) code: %s", d.Id(), err)
		}

		if _, err := waitFunctionUpdated(ctx, conn, d.Id(), d.Timeout(schema.TimeoutUpdate)); err != nil {
			return sdkdiag.AppendErrorf(diags, "updating Lambda Function (%s) code: waiting for completion: %s", d.Id(), err)
		}
	}

	if d.HasChange("reserved_concurrent_executions") {
		if v, ok := d.Get("reserved_concurrent_executions").(int); ok && v >= 0 {
			_, err := conn.PutFunctionConcurrency(ctx, &lambda.PutFunctionConcurrencyInput{
				FunctionName:                 aws.String(d.Id()),
				ReservedConcurrentExecutions: aws.Int32(int32(v)),
			})

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "setting Lambda Function (%s) concurrency: %s", d.Id(), err)
			}
		} else {
			_, err := conn.DeleteFunctionConcurrency(ctx, &lambda.DeleteFunctionConcurrencyInput{
				FunctionName: aws.String(d.Id()),
			})

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "deleting Lambda Function (%s) concurrency: %s", d.Id(), err)
			}
		}
	}

	if d.Get("publish").(bool) && (codeUpdate || configUpdate || d.HasChange("publish")) {
		input := &lambda.PublishVersionInput{
			FunctionName: aws.String(d.Id()),
		}

		outputRaw, err := tfresource.RetryWhenIsAErrorMessageContains[*awstypes.ResourceConflictException](ctx, lambdaPropagationTimeout, func() (any, error) {
			return conn.PublishVersion(ctx, input)
		}, "in progress")

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "publishing Lambda Function (%s) version: %s", d.Id(), err)
		}

		output := outputRaw.(*lambda.PublishVersionOutput)

		err = lambda.NewFunctionUpdatedWaiter(conn).Wait(ctx, &lambda.GetFunctionConfigurationInput{
			FunctionName: output.FunctionArn,
			Qualifier:    output.Version,
		}, d.Timeout(schema.TimeoutUpdate))

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "publishing Lambda Function (%s) version: waiting for completion: %s", d.Id(), err)
		}
	}

	return append(diags, resourceFunctionRead(ctx, d, meta)...)
}
