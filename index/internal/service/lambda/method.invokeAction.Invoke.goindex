package github.com/hashicorp/terraform-provider-aws/internal/service/lambda
import (
	"context"
	"encoding/base64"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/lambda"
	awstypes "github.com/aws/aws-sdk-go-v2/service/lambda/types"
	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/framework/validators"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (a *invokeAction) Invoke(ctx context.Context, req action.InvokeRequest, resp *action.InvokeResponse) {
	var config invokeActionModel

	// Parse configuration
	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get AWS client
	conn := a.Meta().LambdaClient(ctx)

	functionName := config.FunctionName.ValueString()
	payload := config.Payload.ValueString()

	// Set default values for optional parameters
	invocationType := awstypes.InvocationTypeRequestResponse
	if !config.InvocationType.IsNull() && !config.InvocationType.IsUnknown() {
		invocationType = config.InvocationType.ValueEnum()
	}

	logType := awstypes.LogTypeNone
	if !config.LogType.IsNull() && !config.LogType.IsUnknown() {
		logType = config.LogType.ValueEnum()
	}

	tflog.Info(ctx, "Starting Lambda function invocation action", map[string]any{
		"function_name":      functionName,
		"invocation_type":    string(invocationType),
		"log_type":           string(logType),
		"payload_length":     len(payload),
		"has_qualifier":      !config.Qualifier.IsNull(),
		"has_client_context": !config.ClientContext.IsNull(),
	})

	// Send initial progress update
	resp.SendProgress(action.InvokeProgressEvent{
		Message: fmt.Sprintf("Invoking Lambda function %s...", functionName),
	})

	// Build the invoke input
	input := &lambda.InvokeInput{
		FunctionName:   aws.String(functionName),
		Payload:        []byte(payload),
		InvocationType: invocationType,
		LogType:        logType,
	}

	// Set optional parameters
	if !config.Qualifier.IsNull() {
		input.Qualifier = config.Qualifier.ValueStringPointer()
	}

	if !config.ClientContext.IsNull() {
		clientContext := config.ClientContext.ValueString()
		// Validate that client context is base64 encoded
		if _, err := base64.StdEncoding.DecodeString(clientContext); err != nil {
			resp.Diagnostics.AddError(
				"Invalid Client Context",
				fmt.Sprintf("Client context must be base64 encoded: %s", err),
			)
			return
		}
		input.ClientContext = aws.String(clientContext)
	}

	// Perform the invocation
	output, err := conn.Invoke(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Invoke Lambda Function",
			fmt.Sprintf("Could not invoke Lambda function %s: %s", functionName, err),
		)
		return
	}

	// Handle function errors
	if output.FunctionError != nil {
		functionError := aws.ToString(output.FunctionError)
		payloadStr := string(output.Payload)

		resp.Diagnostics.AddError(
			"Lambda Function Execution Error",
			fmt.Sprintf("Lambda function %s returned an error (%s): %s", functionName, functionError, payloadStr),
		)
		return
	}

	// Handle different invocation types
	switch invocationType {
	case awstypes.InvocationTypeRequestResponse:
		// For synchronous invocations, we get an immediate response
		statusCode := output.StatusCode
		payloadLength := len(output.Payload)

		var message string
		if logType == awstypes.LogTypeTail && output.LogResult != nil {
			message = fmt.Sprintf("Lambda function %s invoked successfully (status: %d, payload: %d bytes, logs included)",
				functionName, statusCode, payloadLength)
		} else {
			message = fmt.Sprintf("Lambda function %s invoked successfully (status: %d, payload: %d bytes)",
				functionName, statusCode, payloadLength)
		}

		resp.SendProgress(action.InvokeProgressEvent{
			Message: message,
		})

	case awstypes.InvocationTypeEvent:
		// For asynchronous invocations, we only get confirmation that the request was accepted
		statusCode := output.StatusCode
		resp.SendProgress(action.InvokeProgressEvent{
			Message: fmt.Sprintf("Lambda function %s invoked asynchronously (status: %d)", functionName, statusCode),
		})

	case awstypes.InvocationTypeDryRun:
		// For dry run, we validate parameters without actually invoking
		statusCode := output.StatusCode
		resp.SendProgress(action.InvokeProgressEvent{
			Message: fmt.Sprintf("Lambda function %s dry run completed successfully (status: %d)", functionName, statusCode),
		})
	}

	tflog.Info(ctx, "Lambda function invocation action completed successfully", map[string]any{
		"function_name":      functionName,
		"invocation_type":    string(invocationType),
		names.AttrStatusCode: output.StatusCode,
		"executed_version":   aws.ToString(output.ExecutedVersion),
		"has_logs":           output.LogResult != nil,
		"payload_length":     len(output.Payload),
	})
}
