package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceRouteUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).EC2Client(ctx)

	destinationAttributeKey, destination, err := routeDestinationAttribute(d)

	if err != nil {
		return sdkdiag.AppendFromErr(diags, err)
	}

	targetAttributeKey, target, err := routeTargetAttribute(d)

	if err != nil {
		return sdkdiag.AppendFromErr(diags, err)
	}

	routeTableID := d.Get("route_table_id").(string)
	input := &ec2.ReplaceRouteInput{
		RouteTableId: aws.String(routeTableID),
	}

	var routeFinder routeFinder

	switch destination := aws.String(destination); destinationAttributeKey {
	case routeDestinationCIDRBlock:
		input.DestinationCidrBlock = destination
		routeFinder = findRouteByIPv4Destination
	case routeDestinationIPv6CIDRBlock:
		input.DestinationIpv6CidrBlock = destination
		routeFinder = findRouteByIPv6Destination
	case routeDestinationPrefixListID:
		input.DestinationPrefixListId = destination
		routeFinder = findRouteByPrefixListIDDestination
	default:
		return sdkdiag.AppendErrorf(diags, "updating Route: unexpected route destination attribute: %q", destinationAttributeKey)
	}

	localTarget := target == gatewayIDLocal
	switch target := aws.String(target); targetAttributeKey {
	case "carrier_gateway_id":
		input.CarrierGatewayId = target
	case "core_network_arn":
		input.CoreNetworkArn = target
	case "egress_only_gateway_id":
		input.EgressOnlyInternetGatewayId = target
	case "gateway_id":
		if localTarget {
			input.LocalTarget = aws.Bool(true)
		} else {
			input.GatewayId = target
		}
	case "local_gateway_id":
		input.LocalGatewayId = target
	case "nat_gateway_id":
		input.NatGatewayId = target
	case "network_interface_id":
		input.NetworkInterfaceId = target
	case "transit_gateway_id":
		input.TransitGatewayId = target
	case "vpc_endpoint_id":
		input.VpcEndpointId = target
	case "vpc_peering_connection_id":
		input.VpcPeeringConnectionId = target
	default:
		return sdkdiag.AppendErrorf(diags, "updating Route: unexpected route target attribute: %q", targetAttributeKey)
	}

	log.Printf("[DEBUG] Updating Route: %v", input)
	_, err = conn.ReplaceRoute(ctx, input)

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "updating Route in Route Table (%s) with destination (%s): %s", routeTableID, destination, err)
	}

	if _, err := waitRouteReady(ctx, conn, routeFinder, routeTableID, destination, d.Timeout(schema.TimeoutUpdate)); err != nil {
		return sdkdiag.AppendErrorf(diags, "waiting for Route in Route Table (%s) with destination (%s) update: %s", routeTableID, destination, err)
	}

	return append(diags, resourceRouteRead(ctx, d, meta)...)
}
