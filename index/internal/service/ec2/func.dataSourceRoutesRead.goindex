package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func dataSourceRoutesRead(ctx context.Context, conn *ec2.Client, ec2Routes []awstypes.Route) []map[string]any {
	routes := make([]map[string]any, 0, len(ec2Routes))
	// Loop through the routes and add them to the set
	for _, r := range ec2Routes {
		if gatewayID := aws.ToString(r.GatewayId); gatewayID == gatewayIDLocal || gatewayID == gatewayIDVPCLattice {
			continue
		}

		if r.Origin == awstypes.RouteOriginEnableVgwRoutePropagation {
			continue
		}

		if r.DestinationPrefixListId != nil && strings.HasPrefix(aws.ToString(r.GatewayId), "vpce-") {
			// Skipping because VPC endpoint routes are handled separately
			// See aws_vpc_endpoint
			continue
		}

		// Skip cross-account ENIs for AWS services.
		if networkInterfaceID := aws.ToString(r.NetworkInterfaceId); networkInterfaceID != "" {
			networkInterface, err := findNetworkInterfaceByID(ctx, conn, networkInterfaceID)

			if err == nil && networkInterface.Attachment != nil {
				if ownerID, instanceOwnerID := aws.ToString(networkInterface.OwnerId), aws.ToString(networkInterface.Attachment.InstanceOwnerId); ownerID != "" && instanceOwnerID != ownerID {
					log.Printf("[DEBUG] Skip cross-account ENI (%s)", networkInterfaceID)
					continue
				}
			}
		}

		m := make(map[string]any)

		if r.DestinationCidrBlock != nil {
			m[names.AttrCIDRBlock] = aws.ToString(r.DestinationCidrBlock)
		}
		if r.DestinationIpv6CidrBlock != nil {
			m["ipv6_cidr_block"] = aws.ToString(r.DestinationIpv6CidrBlock)
		}
		if r.DestinationPrefixListId != nil {
			m["destination_prefix_list_id"] = aws.ToString(r.DestinationPrefixListId)
		}
		if r.CarrierGatewayId != nil {
			m["carrier_gateway_id"] = aws.ToString(r.CarrierGatewayId)
		}
		if r.CoreNetworkArn != nil {
			m["core_network_arn"] = aws.ToString(r.CoreNetworkArn)
		}
		if r.EgressOnlyInternetGatewayId != nil {
			m["egress_only_gateway_id"] = aws.ToString(r.EgressOnlyInternetGatewayId)
		}
		if r.GatewayId != nil {
			if strings.HasPrefix(*r.GatewayId, "vpce-") {
				m[names.AttrVPCEndpointID] = aws.ToString(r.GatewayId)
			} else {
				m["gateway_id"] = aws.ToString(r.GatewayId)
			}
		}
		if r.NatGatewayId != nil {
			m["nat_gateway_id"] = aws.ToString(r.NatGatewayId)
		}
		if r.LocalGatewayId != nil {
			m["local_gateway_id"] = aws.ToString(r.LocalGatewayId)
		}
		if r.InstanceId != nil {
			m[names.AttrInstanceID] = aws.ToString(r.InstanceId)
		}
		if r.TransitGatewayId != nil {
			m[names.AttrTransitGatewayID] = aws.ToString(r.TransitGatewayId)
		}
		if r.VpcPeeringConnectionId != nil {
			m["vpc_peering_connection_id"] = aws.ToString(r.VpcPeeringConnectionId)
		}
		if r.NetworkInterfaceId != nil {
			m[names.AttrNetworkInterfaceID] = aws.ToString(r.NetworkInterfaceId)
		}

		routes = append(routes, m)
	}
	return routes
}
