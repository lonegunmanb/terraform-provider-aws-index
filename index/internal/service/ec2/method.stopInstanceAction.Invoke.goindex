package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"fmt"
	"slices"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (a *stopInstanceAction) Invoke(ctx context.Context, req action.InvokeRequest, resp *action.InvokeResponse) {
	var config stopInstanceModel

	// Parse configuration
	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get AWS client
	conn := a.Meta().EC2Client(ctx)

	instanceID := config.InstanceID.ValueString()
	force := config.Force.ValueBool()

	// Set default timeout if not provided
	timeout := 600 * time.Second
	if !config.Timeout.IsNull() {
		timeout = time.Duration(config.Timeout.ValueInt64()) * time.Second
	}

	tflog.Info(ctx, "Starting EC2 stop instance action", map[string]any{
		names.AttrInstanceID: instanceID,
		"force":              force,
		names.AttrTimeout:    timeout.String(),
	})

	// Send initial progress update
	resp.SendProgress(action.InvokeProgressEvent{
		Message: fmt.Sprintf("Starting stop operation for EC2 instance %s...", instanceID),
	})

	// Check current instance state first
	instance, err := findInstanceByID(ctx, conn, instanceID)
	if err != nil {
		if tfawserr.ErrCodeEquals(err, errCodeInvalidInstanceIDNotFound) {
			resp.Diagnostics.AddError(
				"Instance Not Found",
				fmt.Sprintf("EC2 instance %s was not found", instanceID),
			)
			return
		}
		resp.Diagnostics.AddError(
			"Failed to Describe Instance",
			fmt.Sprintf("Could not describe EC2 instance %s: %s", instanceID, err),
		)
		return
	}

	currentState := string(instance.State.Name)
	tflog.Debug(ctx, "Current instance state", map[string]any{
		names.AttrInstanceID: instanceID,
		names.AttrState:      currentState,
	})

	// Check if instance is already stopped
	if instance.State.Name == awstypes.InstanceStateNameStopped {
		resp.SendProgress(action.InvokeProgressEvent{
			Message: fmt.Sprintf("EC2 instance %s is already stopped", instanceID),
		})
		tflog.Info(ctx, "Instance already stopped", map[string]any{
			names.AttrInstanceID: instanceID,
		})
		return
	}

	// Check if instance is in a state that can be stopped
	if !canStopInstance(instance.State.Name) {
		resp.Diagnostics.AddError(
			"Cannot Stop Instance",
			fmt.Sprintf("EC2 instance %s is in state '%s' and cannot be stopped. Instance must be in 'running' or 'stopping' state.", instanceID, currentState),
		)
		return
	}

	// If instance is already stopping, just wait for it
	if instance.State.Name == awstypes.InstanceStateNameStopping {
		resp.SendProgress(action.InvokeProgressEvent{
			Message: fmt.Sprintf("EC2 instance %s is already stopping, waiting for completion...", instanceID),
		})
	} else {
		// Stop the instance
		resp.SendProgress(action.InvokeProgressEvent{
			Message: fmt.Sprintf("Sending stop command to EC2 instance %s...", instanceID),
		})

		input := ec2.StopInstancesInput{
			Force:       aws.Bool(force),
			InstanceIds: []string{instanceID},
		}

		_, err = conn.StopInstances(ctx, &input)
		if err != nil {
			resp.Diagnostics.AddError(
				"Failed to Stop Instance",
				fmt.Sprintf("Could not stop EC2 instance %s: %s", instanceID, err),
			)
			return
		}

		resp.SendProgress(action.InvokeProgressEvent{
			Message: fmt.Sprintf("Stop command sent to EC2 instance %s, waiting for instance to stop...", instanceID),
		})
	}

	// Wait for instance to stop with periodic progress updates
	err = a.waitForInstanceStopped(ctx, conn, instanceID, timeout, resp)
	if err != nil {
		resp.Diagnostics.AddError(
			"Timeout Waiting for Instance to Stop",
			fmt.Sprintf("EC2 instance %s did not stop within %s: %s", instanceID, timeout, err),
		)
		return
	}

	// Final success message
	resp.SendProgress(action.InvokeProgressEvent{
		Message: fmt.Sprintf("EC2 instance %s has been successfully stopped", instanceID),
	})

	tflog.Info(ctx, "EC2 stop instance action completed successfully", map[string]any{
		names.AttrInstanceID: instanceID,
	})
}
