package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceRouteCreate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).EC2Client(ctx)

	destinationAttributeKey, destination, err := routeDestinationAttribute(d)
	if err != nil {
		return sdkdiag.AppendFromErr(diags, err)
	}

	targetAttributeKey, target, err := routeTargetAttribute(d)
	if err != nil {
		return sdkdiag.AppendFromErr(diags, err)
	}

	routeTableID := d.Get("route_table_id").(string)
	input := &ec2.CreateRouteInput{
		RouteTableId: aws.String(routeTableID),
	}

	var routeFinder routeFinder

	switch destination := aws.String(destination); destinationAttributeKey {
	case routeDestinationCIDRBlock:
		input.DestinationCidrBlock = destination
		routeFinder = findRouteByIPv4Destination
	case routeDestinationIPv6CIDRBlock:
		input.DestinationIpv6CidrBlock = destination
		routeFinder = findRouteByIPv6Destination
	case routeDestinationPrefixListID:
		input.DestinationPrefixListId = destination
		routeFinder = findRouteByPrefixListIDDestination
	default:
		return sdkdiag.AppendErrorf(diags, "creating Route: unexpected route destination attribute: %q", destinationAttributeKey)
	}

	switch target := aws.String(target); targetAttributeKey {
	case "carrier_gateway_id":
		input.CarrierGatewayId = target
	case "core_network_arn":
		input.CoreNetworkArn = target
	case "egress_only_gateway_id":
		input.EgressOnlyInternetGatewayId = target
	case "gateway_id":
		input.GatewayId = target
	case "local_gateway_id":
		input.LocalGatewayId = target
	case "nat_gateway_id":
		input.NatGatewayId = target
	case "network_interface_id":
		input.NetworkInterfaceId = target
	case "transit_gateway_id":
		input.TransitGatewayId = target
	case "vpc_endpoint_id":
		input.VpcEndpointId = target
	case "vpc_peering_connection_id":
		input.VpcPeeringConnectionId = target
	default:
		return sdkdiag.AppendErrorf(diags, "creating Route: unexpected route target attribute: %q", targetAttributeKey)
	}

	route, err := routeFinder(ctx, conn, routeTableID, destination)

	switch {
	case err == nil:
		if route.Origin == awstypes.RouteOriginCreateRoute {
			return sdkdiag.AppendFromErr(diags, routeAlreadyExistsError(routeTableID, destination))
		}
	case retry.NotFound(err):
	default:
		return sdkdiag.AppendErrorf(diags, "reading Route: %s", err)
	}

	_, err = tfresource.RetryWhenAWSErrCodeEquals(ctx, d.Timeout(schema.TimeoutCreate),
		func(ctx context.Context) (any, error) {
			return conn.CreateRoute(ctx, input)
		},
		errCodeInvalidParameterException,
		errCodeInvalidTransitGatewayIDNotFound,
	)

	// Local routes cannot be created manually.
	if tfawserr.ErrMessageContains(err, errCodeInvalidGatewayIDNotFound, "The gateway ID 'local' does not exist") {
		return sdkdiag.AppendErrorf(diags, "cannot create local Route, use `terraform import` to manage existing local Routes")
	}

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "creating Route in Route Table (%s) with destination (%s): %s", routeTableID, destination, err)
	}

	d.SetId(routeCreateID(routeTableID, destination))

	if _, err := waitRouteReady(ctx, conn, routeFinder, routeTableID, destination, d.Timeout(schema.TimeoutCreate)); err != nil {
		return sdkdiag.AppendErrorf(diags, "waiting for Route in Route Table (%s) with destination (%s) create: %s", routeTableID, destination, err)
	}

	return append(diags, resourceRouteRead(ctx, d, meta)...)
}
