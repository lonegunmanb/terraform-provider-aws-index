package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (m *dhcpOptionsMap) dhcpConfigurationsToResourceData(dhcpConfigurations []awstypes.DhcpConfiguration, d *schema.ResourceData) error {
	// Clear existing values
	for tfName := range m.tfToApi {
		d.Set(tfName, nil)
	}

	for _, dhcpConfiguration := range dhcpConfigurations {
		apiName := aws.ToString(dhcpConfiguration.Key)
		tfName, ok := m.apiToTf[apiName]
		if !ok {
			return fmt.Errorf("unsupported DHCP option: %s", apiName)
		}

		currentValue := d.Get(tfName)

		switch currentValue.(type) {
		case string:
			d.Set(tfName, dhcpConfiguration.Values[0].Value)
		case []any:
			var values []string
			for _, v := range dhcpConfiguration.Values {
				if v.Value != nil {
					values = append(values, aws.ToString(v.Value))
				}
			}
			d.Set(tfName, values)
		default:
			return fmt.Errorf("attribute (%s) is of unsupported type: %T", tfName, currentValue)
		}
	}

	return nil
}
