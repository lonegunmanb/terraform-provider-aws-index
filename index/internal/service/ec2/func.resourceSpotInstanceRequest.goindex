package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"log"
	"math/big"
	"strconv"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceSpotInstanceRequest() *schema.Resource {
	return &schema.Resource{
		CreateWithoutTimeout: resourceSpotInstanceRequestCreate,
		ReadWithoutTimeout:   resourceSpotInstanceRequestRead,
		UpdateWithoutTimeout: resourceSpotInstanceRequestUpdate,
		DeleteWithoutTimeout: resourceSpotInstanceRequestDelete,

		Importer: &schema.ResourceImporter{
			StateContext: func(ctx context.Context, rd *schema.ResourceData, meta any) ([]*schema.ResourceData, error) {
				rd.Set(names.AttrForceDestroy, false)

				return []*schema.ResourceData{rd}, nil
			},
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(10 * time.Minute),
			Read:   schema.DefaultTimeout(15 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		Schema: func() map[string]*schema.Schema {
			// The Spot Instance Request Schema is based on the AWS Instance schema.
			s := resourceInstance().SchemaMap()

			// Everything on a spot instance is ForceNew (except tags/tags_all).
			for k, v := range s {
				if v.Computed && !v.Optional {
					continue
				}
				// tags_all is Optional+Computed.
				if k == names.AttrTags || k == names.AttrTagsAll || k == "volume_tags" {
					continue
				}
				// Copy-on-write
				x := *v // nosemgrep:ci.semgrep.aws.prefer-pointer-conversion-assignment
				x.ForceNew = true
				s[k] = &x
			}

			// Remove attributes added for spot instances.
			delete(s, "instance_lifecycle")
			delete(s, "instance_market_options")
			delete(s, "spot_instance_request_id")

			s["instance_interruption_behavior"] = &schema.Schema{
				Type:             schema.TypeString,
				Optional:         true,
				Default:          awstypes.InstanceInterruptionBehaviorTerminate,
				ForceNew:         true,
				ValidateDiagFunc: enum.Validate[awstypes.InstanceInterruptionBehavior](),
			}
			s["launch_group"] = &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			}
			s["primary_network_interface"] = &schema.Schema{
				Type:     schema.TypeList,
				Computed: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						names.AttrDeleteOnTermination: {
							Type:     schema.TypeBool,
							Computed: true,
						},
						names.AttrNetworkInterfaceID: {
							Type:     schema.TypeString,
							Computed: true,
						},
					},
				},
			}
			s["spot_bid_status"] = &schema.Schema{
				Type:     schema.TypeString,
				Computed: true,
			}
			s["spot_instance_id"] = &schema.Schema{
				Type:     schema.TypeString,
				Computed: true,
			}
			s["spot_price"] = &schema.Schema{
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
				DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
					oldFloat, _ := strconv.ParseFloat(old, 64)
					newFloat, _ := strconv.ParseFloat(new, 64)

					return big.NewFloat(oldFloat).Cmp(big.NewFloat(newFloat)) == 0
				},
			}
			s["spot_request_state"] = &schema.Schema{
				Type:     schema.TypeString,
				Computed: true,
			}
			s["spot_type"] = &schema.Schema{
				Type:             schema.TypeString,
				Optional:         true,
				Default:          awstypes.SpotInstanceTypePersistent,
				ValidateDiagFunc: enum.Validate[awstypes.SpotInstanceType](),
			}
			s["valid_from"] = &schema.Schema{
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: validation.IsRFC3339Time,
				Computed:     true,
			}
			s["valid_until"] = &schema.Schema{
				Type:         schema.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: validation.IsRFC3339Time,
				Computed:     true,
			}
			s["wait_for_fulfillment"] = &schema.Schema{
				Type:     schema.TypeBool,
				Optional: true,
				Default:  false,
			}

			return s
		}(),
	}
}
