package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"bytes"
	"context"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/logging"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func forceRevokeSecurityGroupRules(ctx context.Context, conn *ec2.Client, id string, searchAll bool) error {
	conns.GlobalMutexKV.Lock(id)
	defer conns.GlobalMutexKV.Unlock(id)

	rules, err := rulesInSGsTouchingThis(ctx, conn, id, searchAll)
	if err != nil {
		return fmt.Errorf("describing security group rules: %w", err)
	}

	for _, rule := range rules {
		var err error

		if rule.IsEgress == nil || !aws.ToBool(rule.IsEgress) {
			input := &ec2.RevokeSecurityGroupIngressInput{
				SecurityGroupRuleIds: []string{aws.ToString(rule.SecurityGroupRuleId)},
			}

			if rule.GroupId != nil {
				input.GroupId = rule.GroupId
			} else {
				// If this rule isn't "owned" by this group, this will be wrong.
				// However, ec2.SecurityGroupRule doesn't include name so can't
				// be used. If it affects anything, this would affect default
				// VPCs.
				sg, err := findSecurityGroupByID(ctx, conn, id)
				if err != nil {
					return fmt.Errorf("reading Security Group (%s): %w", id, err)
				}

				input.GroupName = sg.GroupName
			}

			_, err = conn.RevokeSecurityGroupIngress(ctx, input)
		} else {
			input := &ec2.RevokeSecurityGroupEgressInput{
				GroupId:              rule.GroupId,
				SecurityGroupRuleIds: []string{aws.ToString(rule.SecurityGroupRuleId)},
			}

			_, err = conn.RevokeSecurityGroupEgress(ctx, input)
		}

		if tfawserr.ErrCodeEquals(err, errCodeInvalidSecurityGroupRuleIdNotFound) {
			continue
		}

		if tfawserr.ErrCodeEquals(err, errCodeInvalidGroupNotFound) {
			continue
		}

		if err != nil {
			return fmt.Errorf("revoking Security Group (%s) Rule (%s): %w", id, aws.ToString(rule.SecurityGroupRuleId), err)
		}
	}

	return nil
}
