package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"bytes"
	"context"
	"crypto/sha1"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
	"maps"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/backoff"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	itypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceInstanceUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).EC2Client(ctx)

	if d.HasChange("volume_tags") && !d.IsNewResource() {
		volIDs, err := getInstanceVolIDs(ctx, conn, d.Id())
		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
		}

		o, n := d.GetChange("volume_tags")

		for _, volID := range volIDs {
			if err := updateTags(ctx, conn, volID, o, n); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating volume_tags (%s): %s", volID, err)
			}
		}
	}

	if d.HasChange("iam_instance_profile") && !d.IsNewResource() {
		input := ec2.DescribeIamInstanceProfileAssociationsInput{
			Filters: []awstypes.Filter{
				{
					Name:   aws.String("instance-id"),
					Values: []string{d.Id()},
				},
			},
		}

		resp, err := conn.DescribeIamInstanceProfileAssociations(ctx, &input)
		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
		}

		// An Iam Instance Profile has been provided and is pending a change
		// This means it is an association or a replacement to an association
		if _, ok := d.GetOk("iam_instance_profile"); ok {
			// Does not have an Iam Instance Profile associated with it, need to associate
			if len(resp.IamInstanceProfileAssociations) == 0 {
				if err := associateInstanceProfile(ctx, d, conn); err != nil {
					return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
				}
			} else {
				// Has an Iam Instance Profile associated with it, need to replace the association
				associationId := resp.IamInstanceProfileAssociations[0].AssociationId
				input := ec2.ReplaceIamInstanceProfileAssociationInput{
					AssociationId: associationId,
					IamInstanceProfile: &awstypes.IamInstanceProfileSpecification{
						Name: aws.String(d.Get("iam_instance_profile").(string)),
					},
				}

				// If the instance is running, we can replace the instance profile association.
				// If it is stopped, the association must be removed and the new one attached separately. (GH-8262)
				instanceState := awstypes.InstanceStateName(d.Get("instance_state").(string))

				if instanceState != "" {
					if instanceState == awstypes.InstanceStateNameStopped || instanceState == awstypes.InstanceStateNameStopping || instanceState == awstypes.InstanceStateNameShuttingDown {
						if err := disassociateInstanceProfile(ctx, associationId, conn); err != nil {
							return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
						}
						if err := associateInstanceProfile(ctx, d, conn); err != nil {
							return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
						}
					} else {
						err := retry.RetryContext(ctx, iamPropagationTimeout, func() *retry.RetryError {
							_, err := conn.ReplaceIamInstanceProfileAssociation(ctx, &input)
							if err != nil {
								if tfawserr.ErrMessageContains(err, "InvalidParameterValue", "Invalid IAM Instance Profile") {
									return retry.RetryableError(err)
								}
								return retry.NonRetryableError(err)
							}
							return nil
						})
						if tfresource.TimedOut(err) {
							_, err = conn.ReplaceIamInstanceProfileAssociation(ctx, &input)
						}
						if err != nil {
							return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): replacing instance profile: %s", d.Id(), err)
						}
					}
				}
			}
			// An Iam Instance Profile has _not_ been provided but is pending a change. This means there is a pending removal
		} else {
			if len(resp.IamInstanceProfileAssociations) > 0 {
				// Has an Iam Instance Profile associated with it, need to remove the association
				associationId := resp.IamInstanceProfileAssociations[0].AssociationId
				if err := disassociateInstanceProfile(ctx, associationId, conn); err != nil {
					return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
				}
			}
		}

		if _, err := waitInstanceIAMInstanceProfileUpdated(ctx, conn, d.Id(), d.Get("iam_instance_profile").(string)); err != nil {
			return sdkdiag.AppendErrorf(diags, "waiting for EC2 Instance (%s) IAM Instance Profile update: %s", d.Id(), err)
		}
	}

	// SourceDestCheck can only be modified on an instance without manually specified network interfaces.
	// SourceDestCheck, in that case, is configured at the network interface level
	if _, ok := d.GetOk("network_interface"); !ok {
		// If we have a new resource and source_dest_check is still true, don't modify
		sourceDestCheck := d.Get("source_dest_check").(bool)

		// Because we're calling Update prior to Read, and the default value of `source_dest_check` is `true`,
		// HasChange() thinks there is a diff between what is set on the instance and what is set in state. We need to ensure that
		// if a diff has occurred, it's not because it's a new instance.
		if d.HasChange("source_dest_check") && !d.IsNewResource() || d.IsNewResource() && !sourceDestCheck {
			input := ec2.ModifyInstanceAttributeInput{
				InstanceId: aws.String(d.Id()),
				SourceDestCheck: &awstypes.AttributeBooleanValue{
					Value: aws.Bool(sourceDestCheck),
				},
			}

			_, err := conn.ModifyInstanceAttribute(ctx, &input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "modifying EC2 Instance (%s) SourceDestCheck attribute: %s", d.Id(), err)
			}
		}
	}

	if d.HasChange("enable_primary_ipv6") && !d.IsNewResource() {
		instance, err := FindInstanceByID(ctx, conn, d.Id())
		if err != nil {
			return sdkdiag.AppendErrorf(diags, "reading EC2 Instance (%s): %s", d.Id(), err)
		}

		var primaryInterface *awstypes.InstanceNetworkInterface
		for _, ni := range instance.NetworkInterfaces {
			if aws.ToInt32(ni.Attachment.DeviceIndex) == 0 {
				primaryInterface = &ni
			}
		}

		if primaryInterface == nil {
			return sdkdiag.AppendErrorf(diags, "modifying EC2 Instance (%s), enable_primary_ipv6, which does not contain a primary network interface", d.Id())
		}

		enablePrimaryIpv6 := d.Get("enable_primary_ipv6").(bool)

		input := ec2.ModifyNetworkInterfaceAttributeInput{
			NetworkInterfaceId: primaryInterface.NetworkInterfaceId,
			EnablePrimaryIpv6:  aws.Bool(enablePrimaryIpv6),
		}

		_, err = conn.ModifyNetworkInterfaceAttribute(ctx, &input)
		if err != nil {
			return sdkdiag.AppendErrorf(diags, "modifying EC2 Instance (%s) primary network interface: %s", d.Id(), err)
		}
	}

	if d.HasChange("ipv6_address_count") && !d.IsNewResource() {
		instance, err := findInstanceByID(ctx, conn, d.Id())
		if err != nil {
			return sdkdiag.AppendErrorf(diags, "reading EC2 Instance (%s): %s", d.Id(), err)
		}

		var primaryInterface awstypes.InstanceNetworkInterface
		for _, ni := range instance.NetworkInterfaces {
			if aws.ToInt32(ni.Attachment.DeviceIndex) == 0 {
				primaryInterface = ni
			}
		}

		if primaryInterface.NetworkInterfaceId == nil {
			return sdkdiag.AppendErrorf(diags, "Failed to update ipv6_address_count on %q, which does not contain a primary network interface", d.Id())
		}

		o, n := d.GetChange("ipv6_address_count")
		os, ns := o.(int), n.(int)

		if ns > os {
			// Add more to the primary NIC.
			input := ec2.AssignIpv6AddressesInput{
				NetworkInterfaceId: primaryInterface.NetworkInterfaceId,
				Ipv6AddressCount:   aws.Int32(int32(ns - os)),
			}

			_, err := conn.AssignIpv6Addresses(ctx, &input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "assigning EC2 Instance (%s) IPv6 addresses: %s", d.Id(), err)
			}
		} else if os > ns {
			// Remove IP addresses.
			if len(primaryInterface.Ipv6Addresses) != os {
				return sdkdiag.AppendErrorf(diags, "IPv6 address count (%d) on the instance does not match state's count (%d), we're in a race with something else", len(primaryInterface.Ipv6Addresses), os)
			}

			toRemove := make([]string, 0)
			for _, addr := range primaryInterface.Ipv6Addresses[ns:] { // Can I assume this is strongly ordered?
				toRemove = append(toRemove, *addr.Ipv6Address)
			}

			input := ec2.UnassignIpv6AddressesInput{
				NetworkInterfaceId: primaryInterface.NetworkInterfaceId,
				Ipv6Addresses:      toRemove,
			}

			_, err := conn.UnassignIpv6Addresses(ctx, &input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "unassigning EC2 Instance (%s) IPv6 addresses: %s", d.Id(), err)
			}
		}
	}

	if d.HasChanges("secondary_private_ips", names.AttrVPCSecurityGroupIDs) && !d.IsNewResource() {
		instance, err := findInstanceByID(ctx, conn, d.Id())

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "reading EC2 Instance (%s): %s", d.Id(), err)
		}

		var primaryInterface awstypes.InstanceNetworkInterface
		for _, ni := range instance.NetworkInterfaces {
			if aws.ToInt32(ni.Attachment.DeviceIndex) == 0 {
				primaryInterface = ni
			}
		}

		if d.HasChange("secondary_private_ips") {
			if primaryInterface.NetworkInterfaceId == nil {
				return sdkdiag.AppendErrorf(diags, "Failed to update secondary_private_ips on %q, which does not contain a primary network interface",
					d.Id())
			}
			o, n := d.GetChange("secondary_private_ips")
			if o == nil {
				o = new(schema.Set)
			}
			if n == nil {
				n = new(schema.Set)
			}

			os := o.(*schema.Set)
			ns := n.(*schema.Set)

			// Unassign old IP addresses
			unassignIps := os.Difference(ns)
			if unassignIps.Len() != 0 {
				input := ec2.UnassignPrivateIpAddressesInput{
					NetworkInterfaceId: primaryInterface.NetworkInterfaceId,
					PrivateIpAddresses: flex.ExpandStringValueSet(unassignIps),
				}
				log.Printf("[INFO] Unassigning secondary_private_ips on Instance %q", d.Id())
				_, err := conn.UnassignPrivateIpAddresses(ctx, &input)
				if err != nil {
					return sdkdiag.AppendErrorf(diags, "Failure to unassign Secondary Private IPs: %s", err)
				}
			}

			// Assign new IP addresses
			assignIps := ns.Difference(os)
			if assignIps.Len() != 0 {
				input := ec2.AssignPrivateIpAddressesInput{
					NetworkInterfaceId: primaryInterface.NetworkInterfaceId,
					PrivateIpAddresses: flex.ExpandStringValueSet(assignIps),
				}
				log.Printf("[INFO] Assigning secondary_private_ips on Instance %q", d.Id())
				_, err := conn.AssignPrivateIpAddresses(ctx, &input)
				if err != nil {
					return sdkdiag.AppendErrorf(diags, "Failure to assign Secondary Private IPs: %s", err)
				}
			}
		}

		if d.HasChange(names.AttrVPCSecurityGroupIDs) {
			if primaryInterface.NetworkInterfaceId == nil {
				return sdkdiag.AppendErrorf(diags, "Failed to update vpc_security_group_ids on %q, which does not contain a primary network interface",
					d.Id())
			}
			var groups []string
			if v := d.Get(names.AttrVPCSecurityGroupIDs).(*schema.Set); v.Len() > 0 {
				for _, v := range v.List() {
					groups = append(groups, v.(string))
				}
			}

			if len(groups) < 1 {
				return sdkdiag.AppendErrorf(diags, "VPC-based instances require at least one security group to be attached.")
			}
			// If a user has multiple network interface attachments on the target EC2 instance, simply modifying the
			// instance attributes via a `ModifyInstanceAttributes()` request would fail with the following error message:
			// "There are multiple interfaces attached to instance 'i-XX'. Please specify an interface ID for the operation instead."
			// Thus, we need to actually modify the primary network interface for the new security groups, as the primary
			// network interface is where we modify/create security group assignments during Create.
			log.Printf("[INFO] Modifying `vpc_security_group_ids` on Instance %q", d.Id())
			input := ec2.ModifyNetworkInterfaceAttributeInput{
				NetworkInterfaceId: primaryInterface.NetworkInterfaceId,
				Groups:             groups,
			}
			if _, err := conn.ModifyNetworkInterfaceAttribute(ctx, &input); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): modifying network interface: %s", d.Id(), err)
			}
		}
	}

	// See also CustomizeDiff.
	if d.HasChanges(names.AttrInstanceType, "user_data", "user_data_base64") && !d.IsNewResource() {
		// For each argument change, we start and stop the instance
		// to account for behaviors occurring outside terraform.
		// Only one attribute can be modified at a time, else we get
		// "InvalidParameterCombination: Fields for multiple attribute types specified"
		if d.HasChange(names.AttrInstanceType) {
			if !d.HasChange("capacity_reservation_specification.0.capacity_reservation_target.0.capacity_reservation_id") {
				instanceType := d.Get(names.AttrInstanceType).(string)
				input := ec2.ModifyInstanceAttributeInput{
					InstanceId: aws.String(d.Id()),
					InstanceType: &awstypes.AttributeValue{
						Value: aws.String(instanceType),
					},
				}

				if err := modifyInstanceAttributeWithStopStart(ctx, conn, &input, fmt.Sprintf("InstanceType (%s)", instanceType)); err != nil {
					return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) type: %s", d.Id(), err)
				}
			}
		}

		// From the API reference:
		// "If you are using an AWS SDK or command line tool,
		// base64-encoding is performed for you, and you can load the text from a file.
		// Otherwise, you must provide base64-encoded text".

		if d.HasChange("user_data") {
			// Decode so the AWS SDK doesn't double encode.
			v, err := itypes.Base64Decode(d.Get("user_data").(string))
			if err != nil {
				v = []byte(d.Get("user_data").(string))
			}

			input := ec2.ModifyInstanceAttributeInput{
				InstanceId: aws.String(d.Id()),
				UserData: &awstypes.BlobAttributeValue{
					Value: v,
				},
			}

			if err := modifyInstanceAttributeWithStopStart(ctx, conn, &input, "UserData"); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) user data: %s", d.Id(), err)
			}
		}

		if d.HasChange("user_data_base64") {
			// Schema validation technically ensures the data is Base64 encoded.
			// Decode so the AWS SDK doesn't double encode.
			v, err := itypes.Base64Decode(d.Get("user_data_base64").(string))
			if err != nil {
				v = []byte(d.Get("user_data_base64").(string))
			}

			input := ec2.ModifyInstanceAttributeInput{
				InstanceId: aws.String(d.Id()),
				UserData: &awstypes.BlobAttributeValue{
					Value: v,
				},
			}

			if err := modifyInstanceAttributeWithStopStart(ctx, conn, &input, "UserData (base64)"); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) user data base64: %s", d.Id(), err)
			}
		}
	}

	if d.HasChange("disable_api_stop") && !d.IsNewResource() {
		if err := disableInstanceAPIStop(ctx, conn, d.Id(), d.Get("disable_api_stop").(bool)); err != nil {
			return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
		}
	}

	if d.HasChange("disable_api_termination") && !d.IsNewResource() {
		if err := disableInstanceAPITermination(ctx, conn, d.Id(), d.Get("disable_api_termination").(bool)); err != nil {
			return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): %s", d.Id(), err)
		}
	}

	if d.HasChange("instance_initiated_shutdown_behavior") {
		input := ec2.ModifyInstanceAttributeInput{
			InstanceId: aws.String(d.Id()),
			InstanceInitiatedShutdownBehavior: &awstypes.AttributeValue{
				Value: aws.String(d.Get("instance_initiated_shutdown_behavior").(string)),
			},
		}

		_, err := conn.ModifyInstanceAttribute(ctx, &input)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "modifying EC2 Instance (%s) InstanceInitiatedShutdownBehavior attribute: %s", d.Id(), err)
		}
	}

	if d.HasChange("maintenance_options") && !d.IsNewResource() {
		autoRecovery := d.Get("maintenance_options.0.auto_recovery").(string)

		log.Printf("[INFO] Modifying instance automatic recovery settings %s", d.Id())
		input := ec2.ModifyInstanceMaintenanceOptionsInput{
			AutoRecovery: awstypes.InstanceAutoRecoveryState(autoRecovery),
			InstanceId:   aws.String(d.Id()),
		}
		_, err := conn.ModifyInstanceMaintenanceOptions(ctx, &input)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): modifying maintenance options: %s", d.Id(), err)
		}

		if _, err := waitInstanceMaintenanceOptionsAutoRecoveryUpdated(ctx, conn, d.Id(), autoRecovery, d.Timeout(schema.TimeoutUpdate)); err != nil {
			return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): modifying maintenance options: waiting for completion: %s", d.Id(), err)
		}
	}

	if d.HasChange("monitoring") {
		var mErr error
		if d.Get("monitoring").(bool) {
			log.Printf("[DEBUG] Enabling monitoring for Instance (%s)", d.Id())
			input := ec2.MonitorInstancesInput{
				InstanceIds: []string{d.Id()},
			}
			_, mErr = conn.MonitorInstances(ctx, &input)
		} else {
			log.Printf("[DEBUG] Disabling monitoring for Instance (%s)", d.Id())
			input := ec2.UnmonitorInstancesInput{
				InstanceIds: []string{d.Id()},
			}
			_, mErr = conn.UnmonitorInstances(ctx, &input)
		}
		if mErr != nil {
			return sdkdiag.AppendErrorf(diags, "updating Instance monitoring: %s", mErr)
		}
	}

	if d.HasChange("credit_specification") && !d.IsNewResource() {
		if v, ok := d.GetOk("credit_specification"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
			instanceCreditSpecification := expandInstanceCreditSpecificationRequest(v.([]any)[0].(map[string]any))
			instanceCreditSpecification.InstanceId = aws.String(d.Id())
			input := ec2.ModifyInstanceCreditSpecificationInput{
				ClientToken:                  aws.String(id.UniqueId()),
				InstanceCreditSpecifications: []awstypes.InstanceCreditSpecificationRequest{instanceCreditSpecification},
			}

			log.Printf("[DEBUG] Modifying EC2 Instance credit specification: %s", d.Id())
			_, err := conn.ModifyInstanceCreditSpecification(ctx, &input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) credit specification: %s", d.Id(), err)
			}
		}
	}

	if d.HasChange("metadata_options") && !d.IsNewResource() {
		if v, ok := d.GetOk("metadata_options"); ok {
			if tfMap, ok := v.([]any)[0].(map[string]any); ok {
				httpEndpoint := awstypes.InstanceMetadataEndpointState(tfMap["http_endpoint"].(string))
				input := ec2.ModifyInstanceMetadataOptionsInput{
					HttpEndpoint: httpEndpoint,
					HttpTokens:   awstypes.HttpTokensState(tfMap["http_tokens"].(string)),
					InstanceId:   aws.String(d.Id()),
				}

				if httpEndpoint == awstypes.InstanceMetadataEndpointStateEnabled {
					// These parameters are not allowed unless HttpEndpoint is enabled.
					input.HttpProtocolIpv6 = awstypes.InstanceMetadataProtocolState(tfMap["http_protocol_ipv6"].(string))
					input.HttpPutResponseHopLimit = aws.Int32(int32(tfMap["http_put_response_hop_limit"].(int)))
					input.InstanceMetadataTags = awstypes.InstanceMetadataTagsState(tfMap["instance_metadata_tags"].(string))
				}

				_, err := conn.ModifyInstanceMetadataOptions(ctx, &input)

				if tfawserr.ErrMessageContains(err, errCodeUnsupportedOperation, "InstanceMetadataTags") {
					log.Printf("[WARN] updating EC2 Instance (%s) metadata options: %s. Retrying without instance metadata tags.", d.Id(), err)

					_, err = conn.ModifyInstanceMetadataOptions(ctx, &input)
				}

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) metadata options: %s", d.Id(), err)
				}

				if _, err := waitInstanceMetadataOptionsApplied(ctx, conn, d.Id(), d.Timeout(schema.TimeoutUpdate)); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for EC2 Instance (%s) metadata options update: %s", d.Id(), err)
				}
			}
		}
	}

	if d.HasChange("root_block_device.0") && !d.IsNewResource() {
		volID := d.Get("root_block_device.0.volume_id").(string)

		input := ec2.ModifyVolumeInput{
			VolumeId: aws.String(volID),
		}
		modifyVolume := false

		if d.HasChange("root_block_device.0.volume_size") {
			if v, ok := d.Get("root_block_device.0.volume_size").(int); ok && v != 0 {
				modifyVolume = true
				input.Size = aws.Int32(int32(v))
			}
		}
		if d.HasChange("root_block_device.0.volume_type") {
			if v, ok := d.Get("root_block_device.0.volume_type").(string); ok && v != "" {
				modifyVolume = true
				input.VolumeType = awstypes.VolumeType(v)
			}
		}
		if d.HasChange("root_block_device.0.iops") {
			if v, ok := d.Get("root_block_device.0.iops").(int); ok && v != 0 {
				// Enforce IOPs usage with a valid volume type
				// Reference: https://github.com/hashicorp/terraform-provider-aws/issues/12667
				if t, ok := d.Get("root_block_device.0.volume_type").(string); ok && t != string(awstypes.VolumeTypeIo1) && t != string(awstypes.VolumeTypeIo2) && t != string(awstypes.VolumeTypeGp3) {
					if t == "" {
						// Volume defaults to gp2
						t = string(awstypes.VolumeTypeGp2)
					}
					return sdkdiag.AppendErrorf(diags, "updating instance: iops attribute not supported for type %s", t)
				}
				modifyVolume = true
				input.Iops = aws.Int32(int32(v))
			}
		}
		if d.HasChange("root_block_device.0.throughput") {
			if v, ok := d.Get("root_block_device.0.throughput").(int); ok && v != 0 {
				// Enforce throughput usage with a valid volume type
				if t, ok := d.Get("root_block_device.0.volume_type").(string); ok && t != string(awstypes.VolumeTypeGp3) {
					return sdkdiag.AppendErrorf(diags, "updating instance: throughput attribute not supported for type %s", t)
				}
				modifyVolume = true
				input.Throughput = aws.Int32(int32(v))
			}
		}
		if modifyVolume {
			log.Printf("[DEBUG] Modifying volume: %s", d.Id())
			_, err := conn.ModifyVolume(ctx, &input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) volume (%s): %s", d.Id(), volID, err)
			}

			if _, err := waitVolumeModificationComplete(ctx, conn, volID, d.Timeout(schema.TimeoutUpdate)); err != nil {
				return sdkdiag.AppendErrorf(diags, "waiting for EC2 Instance (%s) volume (%s) update: %s", d.Id(), volID, err)
			}
		}

		if d.HasChange("root_block_device.0.delete_on_termination") {
			deviceName := d.Get("root_block_device.0.device_name").(string)
			if v, ok := d.Get("root_block_device.0.delete_on_termination").(bool); ok {
				input := ec2.ModifyInstanceAttributeInput{
					BlockDeviceMappings: []awstypes.InstanceBlockDeviceMappingSpecification{
						{
							DeviceName: aws.String(deviceName),
							Ebs: &awstypes.EbsInstanceBlockDeviceSpecification{
								DeleteOnTermination: aws.Bool(v),
							},
						},
					},
					InstanceId: aws.String(d.Id()),
				}

				_, err := conn.ModifyInstanceAttribute(ctx, &input)

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "modifying EC2 Instance (%s) BlockDeviceMappings (%s) attribute: %s", d.Id(), deviceName, err)
				}

				if _, err := waitInstanceRootBlockDeviceDeleteOnTerminationUpdated(ctx, conn, d.Id(), v, d.Timeout(schema.TimeoutUpdate)); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for EC2 Instance (%s) root block device DeleteOnTermination update: %s", d.Id(), err)
				}
			}
		}

		if d.HasChange("root_block_device.0.tags") {
			o, n := d.GetChange("root_block_device.0.tags")

			if err := updateTags(ctx, conn, volID, o, n); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating tags for volume (%s): %s", volID, err)
			}
		}

		if d.HasChange("root_block_device.0.tags_all") && !d.HasChange("root_block_device.0.tags") {
			o, n := d.GetChange("root_block_device.0.tags_all")

			if err := updateTags(ctx, conn, volID, o, n); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating tags for volume (%s): %s", volID, err)
			}
		}
	}

	// To modify capacity reservation attributes of an instance, instance state needs to be in ec2.InstanceStateNameStopped,
	// otherwise the modification will return an IncorrectInstanceState error
	if d.HasChange("capacity_reservation_specification") && !d.IsNewResource() {
		if v, ok := d.GetOk("capacity_reservation_specification"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
			if v := expandCapacityReservationSpecification(v.([]any)[0].(map[string]any)); v != nil && (v.CapacityReservationPreference != "" || v.CapacityReservationTarget != nil) {
				if err := stopInstance(ctx, conn, d.Id(), false, instanceStopTimeout); err != nil {
					return sdkdiag.AppendFromErr(diags, err)
				}

				if d.HasChange("capacity_reservation_specification.0.capacity_reservation_target.0.capacity_reservation_id") && d.HasChange(names.AttrInstanceType) {
					instanceType := d.Get(names.AttrInstanceType).(string)
					input := ec2.ModifyInstanceAttributeInput{
						InstanceId: aws.String(d.Id()),
						InstanceType: &awstypes.AttributeValue{
							Value: aws.String(instanceType),
						},
					}

					if _, err := conn.ModifyInstanceAttribute(ctx, &input); err != nil {
						return sdkdiag.AppendErrorf(diags, "modifying EC2 Instance (%s) InstanceType (%s) attribute: %s", d.Id(), instanceType, err)
					}
				}

				input := ec2.ModifyInstanceCapacityReservationAttributesInput{
					CapacityReservationSpecification: v,
					InstanceId:                       aws.String(d.Id()),
				}

				log.Printf("[DEBUG] Modifying EC2 Instance capacity reservation attributes: %s", d.Id())

				_, err := conn.ModifyInstanceCapacityReservationAttributes(ctx, &input)

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s) capacity reservation attributes: %s", d.Id(), err)
				}

				if _, err := waitInstanceCapacityReservationSpecificationUpdated(ctx, conn, d.Id(), v); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for EC2 Instance (%s) capacity reservation attributes update: %s", d.Id(), err)
				}

				if err := startInstance(ctx, conn, d.Id(), true, instanceStartTimeout); err != nil {
					return sdkdiag.AppendFromErr(diags, err)
				}
			}
		}
	}

	if d.HasChange("private_dns_name_options") && !d.IsNewResource() {
		if v, ok := d.GetOk("private_dns_name_options"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
			tfMap := v.([]any)[0].(map[string]any)

			input := ec2.ModifyPrivateDnsNameOptionsInput{
				InstanceId: aws.String(d.Id()),
			}

			if d.HasChange("private_dns_name_options.0.enable_resource_name_dns_aaaa_record") {
				input.EnableResourceNameDnsAAAARecord = aws.Bool(tfMap["enable_resource_name_dns_aaaa_record"].(bool))
			}

			if d.HasChange("private_dns_name_options.0.enable_resource_name_dns_a_record") {
				input.EnableResourceNameDnsARecord = aws.Bool(tfMap["enable_resource_name_dns_a_record"].(bool))
			}

			if d.HasChange("private_dns_name_options.0.hostname_type") {
				input.PrivateDnsHostnameType = awstypes.HostnameType(tfMap["hostname_type"].(string))
			}

			_, err := conn.ModifyPrivateDnsNameOptions(ctx, &input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating EC2 Instance (%s): modifying private DNS name options: %s", d.Id(), err)
			}
		}
	}

	// TODO(mitchellh): wait for the attributes we modified to
	// persist the change...

	return append(diags, resourceInstanceRead(ctx, d, meta)...)
}
