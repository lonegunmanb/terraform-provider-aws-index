package github.com/hashicorp/terraform-provider-aws/internal/service/ec2
import (
	"context"
	"fmt"
	"slices"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (a *stopInstanceAction) waitForInstanceStopped(ctx context.Context, conn *ec2.Client, instanceID string, timeout time.Duration, resp *action.InvokeResponse) error {
	const (
		pollInterval     = 10 * time.Second
		progressInterval = 30 * time.Second
	)

	deadline := time.Now().Add(timeout)
	lastProgressUpdate := time.Now()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		// Check if we've exceeded the timeout
		if time.Now().After(deadline) {
			return fmt.Errorf("timeout after %s", timeout)
		}

		// Get current instance state
		instance, err := findInstanceByID(ctx, conn, instanceID)
		if err != nil {
			return fmt.Errorf("describing instance: %w", err)
		}

		currentState := string(instance.State.Name)

		// Send progress update every 30 seconds
		if time.Since(lastProgressUpdate) >= progressInterval {
			resp.SendProgress(action.InvokeProgressEvent{
				Message: fmt.Sprintf("EC2 instance %s is currently in state '%s', continuing to wait for 'stopped'...", instanceID, currentState),
			})
			lastProgressUpdate = time.Now()
		}

		// Check if we've reached the target state
		if instance.State.Name == awstypes.InstanceStateNameStopped {
			return nil
		}

		// Check if we're in an unexpected state
		validStates := []awstypes.InstanceStateName{
			awstypes.InstanceStateNameRunning,
			awstypes.InstanceStateNameStopping,
			awstypes.InstanceStateNameShuttingDown,
		}
		if !slices.Contains(validStates, instance.State.Name) {
			return fmt.Errorf("instance entered unexpected state: %s", currentState)
		}

		// Wait before next poll
		time.Sleep(pollInterval)
	}
}
