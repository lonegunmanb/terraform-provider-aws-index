package github.com/hashicorp/terraform-provider-aws/internal/service/apigateway
import (
	"context"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/apigateway"
	"github.com/aws/aws-sdk-go-v2/service/apigateway/types"
	awspolicy "github.com/hashicorp/awspolicyequivalence"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2/types/nullable"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceRestAPIWithBodyUpdateOperations(d *schema.ResourceData, output *apigateway.PutRestApiOutput) []types.PatchOperation {
	operations := make([]types.PatchOperation, 0)

	if v, ok := d.GetOk("api_key_source"); ok && v.(string) != string(output.ApiKeySource) {
		operations = append(operations, types.PatchOperation{
			Op:    types.OpReplace,
			Path:  aws.String("/apiKeySource"),
			Value: aws.String(v.(string)),
		})
	}

	if v, ok := d.GetOk("binary_media_types"); ok && len(v.([]any)) > 0 {
		if len(output.BinaryMediaTypes) > 0 {
			for _, elem := range output.BinaryMediaTypes {
				operations = append(operations, types.PatchOperation{
					Op:   types.OpRemove,
					Path: aws.String("/binaryMediaTypes/" + escapeJSONPointer(elem)),
				})
			}
		}

		for _, elem := range v.([]any) {
			if el, ok := elem.(string); ok {
				operations = append(operations, types.PatchOperation{
					Op:   types.OpAdd,
					Path: aws.String("/binaryMediaTypes/" + escapeJSONPointer(el)),
				})
			}
		}
	}

	if v, ok := d.GetOk(names.AttrDescription); ok && v.(string) != aws.ToString(output.Description) {
		operations = append(operations, types.PatchOperation{
			Op:    types.OpReplace,
			Path:  aws.String("/description"),
			Value: aws.String(v.(string)),
		})
	}

	if v, ok := d.GetOk("disable_execute_api_endpoint"); ok && v.(bool) != output.DisableExecuteApiEndpoint {
		operations = append(operations, types.PatchOperation{
			Op:    types.OpReplace,
			Path:  aws.String("/disableExecuteApiEndpoint"),
			Value: aws.String(strconv.FormatBool(v.(bool))),
		})
	}

	// Compare the defined values to the output values, don't blindly remove as they can cause race conditions with DNS and endpoint creation
	if v, ok := d.GetOk("endpoint_configuration"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
		endpointConfiguration := expandEndpointConfiguration(v.([]any)[0].(map[string]any))
		if endpointConfiguration != nil && len(endpointConfiguration.VpcEndpointIds) > 0 {
			prefix := "/endpointConfiguration/vpcEndpointIds"
			if output.EndpointConfiguration != nil {
				for _, v := range output.EndpointConfiguration.VpcEndpointIds {
					if slices.Contains(endpointConfiguration.VpcEndpointIds, v) {
						continue
					}
					operations = append(operations, types.PatchOperation{
						Op:    types.OpRemove,
						Path:  aws.String(prefix),
						Value: aws.String(v),
					})
				}
			}

			for _, v := range endpointConfiguration.VpcEndpointIds {
				if slices.Contains(output.EndpointConfiguration.VpcEndpointIds, v) {
					continue
				}
				operations = append(operations, types.PatchOperation{
					Op:    types.OpAdd,
					Path:  aws.String(prefix),
					Value: aws.String(v),
				})
			}
		}
		if endpointConfiguration != nil && endpointConfiguration.IpAddressType != "" && endpointConfiguration.IpAddressType != output.EndpointConfiguration.IpAddressType {
			if len(v.([]any)) > 0 {
				tfMap := v.([]any)[0].(map[string]any)

				operations = append(operations, types.PatchOperation{
					Op:    types.OpReplace,
					Path:  aws.String("/endpointConfiguration/ipAddressType"),
					Value: aws.String(tfMap[names.AttrIPAddressType].(string)),
				})
			}
		}
	}

	if v, ok := d.GetOk("minimum_compression_size"); ok && v.(string) != strconv.FormatInt(int64(aws.ToInt32(output.MinimumCompressionSize)), 10) {
		value := aws.String(v.(string))
		if v.(string) == "-1" {
			value = nil
		}
		operations = append(operations, types.PatchOperation{
			Op:    types.OpReplace,
			Path:  aws.String("/minimumCompressionSize"),
			Value: value,
		})
	}

	if v, ok := d.GetOk(names.AttrName); ok && v.(string) != aws.ToString(output.Name) {
		operations = append(operations, types.PatchOperation{
			Op:    types.OpReplace,
			Path:  aws.String("/name"),
			Value: aws.String(v.(string)),
		})
	}

	if v, ok := d.GetOk(names.AttrPolicy); ok {
		if equivalent, err := awspolicy.PoliciesAreEquivalent(v.(string), aws.ToString(output.Policy)); err != nil || !equivalent {
			policy, _ := structure.NormalizeJsonString(v.(string)) // validation covers error

			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/policy"),
				Value: aws.String(policy),
			})
		}
	}

	return operations
}
