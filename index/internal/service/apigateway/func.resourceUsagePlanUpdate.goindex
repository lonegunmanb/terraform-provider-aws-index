package github.com/hashicorp/terraform-provider-aws/internal/service/apigateway
import (
	"context"
	"fmt"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/apigateway"
	"github.com/aws/aws-sdk-go-v2/service/apigateway/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceUsagePlanUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).APIGatewayClient(ctx)

	if d.HasChangesExcept(names.AttrTags, names.AttrTagsAll) {
		operations := make([]types.PatchOperation, 0)

		if d.HasChange(names.AttrName) {
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/name"),
				Value: aws.String(d.Get(names.AttrName).(string)),
			})
		}

		if d.HasChange(names.AttrDescription) {
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/description"),
				Value: aws.String(d.Get(names.AttrDescription).(string)),
			})
		}

		if d.HasChange("product_code") {
			if v, ok := d.GetOk("product_code"); ok {
				operations = append(operations, types.PatchOperation{
					Op:    types.OpReplace,
					Path:  aws.String("/productCode"),
					Value: aws.String(v.(string)),
				})
			} else {
				operations = append(operations, types.PatchOperation{
					Op:   types.OpRemove,
					Path: aws.String("/productCode"),
				})
			}
		}

		if d.HasChange("api_stages") {
			o, n := d.GetChange("api_stages")
			os := o.(*schema.Set).List()
			ns := n.(*schema.Set).List()

			// Remove every stages associated. Simpler to remove and add new ones,
			// since there are no replacings.
			for _, v := range os {
				m := v.(map[string]any)
				operations = append(operations, types.PatchOperation{
					Op:    types.OpRemove,
					Path:  aws.String("/apiStages"),
					Value: aws.String(fmt.Sprintf("%s:%s", m["api_id"].(string), m[names.AttrStage].(string))),
				})
			}

			// Handle additions
			if len(ns) > 0 {
				for _, v := range ns {
					m := v.(map[string]any)
					id := fmt.Sprintf("%s:%s", m["api_id"].(string), m[names.AttrStage].(string))
					operations = append(operations, types.PatchOperation{
						Op:    types.OpAdd,
						Path:  aws.String("/apiStages"),
						Value: aws.String(id),
					})
					if t, ok := m["throttle"].(*schema.Set); ok && t.Len() > 0 {
						for _, throttle := range t.List() {
							th := throttle.(map[string]any)
							operations = append(operations, types.PatchOperation{
								Op:    types.OpReplace,
								Path:  aws.String(fmt.Sprintf("/apiStages/%s/throttle/%s/rateLimit", id, th[names.AttrPath].(string))),
								Value: flex.Float64ValueToString(th["rate_limit"].(float64)),
							})
							operations = append(operations, types.PatchOperation{
								Op:    types.OpReplace,
								Path:  aws.String(fmt.Sprintf("/apiStages/%s/throttle/%s/burstLimit", id, th[names.AttrPath].(string))),
								Value: flex.IntValueToString(th["burst_limit"].(int)),
							})
						}
					}
				}
			}
		}

		if d.HasChange("throttle_settings") {
			o, n := d.GetChange("throttle_settings")
			diff := n.([]any)

			// Handle Removal
			if len(diff) == 0 {
				operations = append(operations, types.PatchOperation{
					Op:   types.OpRemove,
					Path: aws.String("/throttle"),
				})
			}

			if len(diff) > 0 {
				d := diff[0].(map[string]any)

				// Handle Replaces
				if o != nil && n != nil {
					operations = append(operations, types.PatchOperation{
						Op:    types.OpReplace,
						Path:  aws.String("/throttle/rateLimit"),
						Value: flex.Float64ValueToString(d["rate_limit"].(float64)),
					})
					operations = append(operations, types.PatchOperation{
						Op:    types.OpReplace,
						Path:  aws.String("/throttle/burstLimit"),
						Value: flex.IntValueToString(d["burst_limit"].(int)),
					})
				}

				// Handle Additions
				if o == nil && n != nil {
					operations = append(operations, types.PatchOperation{
						Op:    types.OpAdd,
						Path:  aws.String("/throttle/rateLimit"),
						Value: flex.Float64ValueToString(d["rate_limit"].(float64)),
					})
					operations = append(operations, types.PatchOperation{
						Op:    types.OpAdd,
						Path:  aws.String("/throttle/burstLimit"),
						Value: flex.IntValueToString(d["burst_limit"].(int)),
					})
				}
			}
		}

		if d.HasChange("quota_settings") {
			o, n := d.GetChange("quota_settings")
			diff := n.([]any)

			// Handle Removal
			if len(diff) == 0 {
				operations = append(operations, types.PatchOperation{
					Op:   types.OpRemove,
					Path: aws.String("/quota"),
				})
			}

			if len(diff) > 0 {
				d := diff[0].(map[string]any)

				if errors := validUsagePlanQuotaSettings(d); len(errors) > 0 {
					return sdkdiag.AppendErrorf(diags, "validating the quota settings: %v", errors)
				}

				// Handle Replaces
				if o != nil && n != nil {
					operations = append(operations, types.PatchOperation{
						Op:    types.OpReplace,
						Path:  aws.String("/quota/limit"),
						Value: flex.IntValueToString(d["limit"].(int)),
					})
					operations = append(operations, types.PatchOperation{
						Op:    types.OpReplace,
						Path:  aws.String("/quota/offset"),
						Value: flex.IntValueToString(d["offset"].(int)),
					})
					operations = append(operations, types.PatchOperation{
						Op:    types.OpReplace,
						Path:  aws.String("/quota/period"),
						Value: aws.String(d["period"].(string)),
					})
				}

				// Handle Additions
				if o == nil && n != nil {
					operations = append(operations, types.PatchOperation{
						Op:    types.OpAdd,
						Path:  aws.String("/quota/limit"),
						Value: flex.IntValueToString(d["limit"].(int)),
					})
					operations = append(operations, types.PatchOperation{
						Op:    types.OpAdd,
						Path:  aws.String("/quota/offset"),
						Value: flex.IntValueToString(d["offset"].(int)),
					})
					operations = append(operations, types.PatchOperation{
						Op:    types.OpAdd,
						Path:  aws.String("/quota/period"),
						Value: aws.String(d["period"].(string)),
					})
				}
			}
		}

		input := apigateway.UpdateUsagePlanInput{
			PatchOperations: operations,
			UsagePlanId:     aws.String(d.Id()),
		}

		_, err := conn.UpdateUsagePlan(ctx, &input)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating API Gateway Usage Plan (%s): %s", d.Id(), err)
		}
	}

	return append(diags, resourceUsagePlanRead(ctx, d, meta)...)
}
