package github.com/hashicorp/terraform-provider-aws/internal/service/apigateway
import (
	"context"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/apigateway"
	"github.com/aws/aws-sdk-go-v2/service/apigateway/types"
	awspolicy "github.com/hashicorp/awspolicyequivalence"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2/types/nullable"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceRestAPIUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).APIGatewayClient(ctx)

	if d.HasChangesExcept(names.AttrTags, names.AttrTagsAll) {
		operations := make([]types.PatchOperation, 0)

		if d.HasChange("api_key_source") {
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/apiKeySource"),
				Value: aws.String(d.Get("api_key_source").(string)),
			})
		}

		if d.HasChange("binary_media_types") {
			o, n := d.GetChange("binary_media_types")
			prefix := "binaryMediaTypes"

			old := o.([]any)
			new := n.([]any)

			// Remove every binary media types. Simpler to remove and add new ones,
			// since there are no replacings.
			for _, v := range old {
				if e, ok := v.(string); ok {
					operations = append(operations, types.PatchOperation{
						Op:   types.OpRemove,
						Path: aws.String(fmt.Sprintf("/%s/%s", prefix, escapeJSONPointer(e))),
					})
				}
			}

			// Handle additions
			if len(new) > 0 {
				for _, v := range new {
					if e, ok := v.(string); ok {
						operations = append(operations, types.PatchOperation{
							Op:   types.OpAdd,
							Path: aws.String(fmt.Sprintf("/%s/%s", prefix, escapeJSONPointer(e))),
						})
					}
				}
			}
		}

		if d.HasChange(names.AttrDescription) {
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/description"),
				Value: aws.String(d.Get(names.AttrDescription).(string)),
			})
		}

		if d.HasChange("disable_execute_api_endpoint") {
			value := strconv.FormatBool(d.Get("disable_execute_api_endpoint").(bool))
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/disableExecuteApiEndpoint"),
				Value: aws.String(value),
			})
		}

		if d.HasChange("endpoint_configuration.0.types") {
			// The REST API must have an endpoint type.
			// If attempting to remove the configuration, do nothing.
			if v, ok := d.GetOk("endpoint_configuration"); ok && len(v.([]any)) > 0 {
				m := v.([]any)[0].(map[string]any)

				operations = append(operations, types.PatchOperation{
					Op:    types.OpReplace,
					Path:  aws.String("/endpointConfiguration/types/0"),
					Value: aws.String(m["types"].([]any)[0].(string)),
				})
			}
		}

		// Compare the old and new values, don't blindly remove as they can cause race conditions with DNS and endpoint creation
		if d.HasChange("endpoint_configuration.0.vpc_endpoint_ids") {
			o, n := d.GetChange("endpoint_configuration.0.vpc_endpoint_ids")
			prefix := "/endpointConfiguration/vpcEndpointIds"

			old := o.(*schema.Set).List()
			new := n.(*schema.Set).List()

			for _, v := range old {
				for _, x := range new {
					if v.(string) == x.(string) {
						break
					}
				}
				operations = append(operations, types.PatchOperation{
					Op:    types.OpRemove,
					Path:  aws.String(prefix),
					Value: aws.String(v.(string)),
				})
			}

			for _, v := range new {
				for _, x := range old {
					if v.(string) == x.(string) {
						break
					}
				}
				operations = append(operations, types.PatchOperation{
					Op:    types.OpAdd,
					Path:  aws.String(prefix),
					Value: aws.String(v.(string)),
				})
			}
		}

		if d.HasChange("endpoint_configuration.0.ip_address_type") {
			if v, ok := d.GetOk("endpoint_configuration"); ok && len(v.([]any)) > 0 {
				tfMap := v.([]any)[0].(map[string]any)

				operations = append(operations, types.PatchOperation{
					Op:    types.OpReplace,
					Path:  aws.String("/endpointConfiguration/ipAddressType"),
					Value: aws.String(tfMap[names.AttrIPAddressType].(string)),
				})
			}
		}

		if d.HasChange("minimum_compression_size") {
			v := d.Get("minimum_compression_size").(string)
			value := aws.String(v)
			if v == "-1" {
				value = nil
			}
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/minimumCompressionSize"),
				Value: value,
			})
		}

		if d.HasChange(names.AttrName) {
			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/name"),
				Value: aws.String(d.Get(names.AttrName).(string)),
			})
		}

		if d.HasChange(names.AttrPolicy) {
			policy, _ := structure.NormalizeJsonString(d.Get(names.AttrPolicy).(string)) // validation covers error

			operations = append(operations, types.PatchOperation{
				Op:    types.OpReplace,
				Path:  aws.String("/policy"),
				Value: aws.String(policy),
			})
		}

		if len(operations) > 0 {
			input := apigateway.UpdateRestApiInput{
				PatchOperations: operations,
				RestApiId:       aws.String(d.Id()),
			}
			_, err := conn.UpdateRestApi(ctx, &input)
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating API Gateway REST API (%s): %s", d.Id(), err)
			}
		}

		if d.HasChanges("body", names.AttrParameters) {
			if body, ok := d.GetOk("body"); ok {
				// Terraform implementation uses the `overwrite` mode by default.
				// Overwrite mode will delete existing literal properties if they are not explicitly set in the OpenAPI definition.
				// The VPC endpoints deletion and immediate recreation can cause a race condition.
				// 		Impacted properties: ApiKeySourceType, BinaryMediaTypes, Description, EndpointConfiguration, MinimumCompressionSize, Name, Policy
				// The `merge` mode will not delete literal properties of a RestApi if theyâ€™re not explicitly set in the OAS definition.
				input := apigateway.PutRestApiInput{
					Body:      []byte(body.(string)),
					Mode:      types.PutMode(modeConfigOrDefault(d)),
					RestApiId: aws.String(d.Id()),
				}

				if v, ok := d.GetOk("fail_on_warnings"); ok {
					input.FailOnWarnings = v.(bool)
				}

				if v, ok := d.GetOk(names.AttrParameters); ok && len(v.(map[string]any)) > 0 {
					input.Parameters = flex.ExpandStringValueMap(v.(map[string]any))
				}

				output, err := conn.PutRestApi(ctx, &input)

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "updating API Gateway REST API (%s) specification: %s", d.Id(), err)
				}

				// Using PutRestApi with mode overwrite will remove any configuration
				// that was done previously. Reconcile these changes by having
				// any Terraform configured values overwrite imported configuration.
				if operations := resourceRestAPIWithBodyUpdateOperations(d, output); len(operations) > 0 {
					input := apigateway.UpdateRestApiInput{
						PatchOperations: operations,
						RestApiId:       aws.String(d.Id()),
					}

					_, err := conn.UpdateRestApi(ctx, &input)

					if err != nil {
						return sdkdiag.AppendErrorf(diags, "updating API Gateway REST API (%s) after OpenAPI import: %s", d.Id(), err)
					}
				}
			}
		}
	}

	return append(diags, resourceRestAPIRead(ctx, d, meta)...)
}
