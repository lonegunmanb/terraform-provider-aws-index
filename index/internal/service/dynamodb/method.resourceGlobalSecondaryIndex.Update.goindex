package github.com/hashicorp/terraform-provider-aws/internal/service/dynamodb
import (
	"context"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	awstypes "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/helpers/validatordiag"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/fwdiag"
	intflex "github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/smerr"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/names"
	semconv "go.opentelemetry.io/otel/semconv/v1.38.0"
)
func (r *resourceGlobalSecondaryIndex) Update(ctx context.Context, request resource.UpdateRequest, response *resource.UpdateResponse) {
	var state, plan, config resourceGlobalSecondaryIndexModel

	response.Diagnostics.Append(request.State.Get(ctx, &state)...)
	if response.Diagnostics.HasError() {
		return
	}

	response.Diagnostics.Append(request.Plan.Get(ctx, &plan)...)
	if response.Diagnostics.HasError() {
		return
	}

	response.Diagnostics.Append(request.Config.Get(ctx, &config)...)
	if response.Diagnostics.HasError() {
		return
	}

	updateProvisionedThroughput := !plan.ProvisionedThroughput.Equal(state.ProvisionedThroughput)
	updateOnDemandThroughput := !plan.OnDemandThroughput.Equal(state.OnDemandThroughput)
	// Need to ignore `warm_throughput` when it's not set in config
	updateWarmThroughput := !config.WarmThroughput.IsNull() && !plan.WarmThroughput.Equal(state.WarmThroughput)

	if updateOnDemandThroughput {
		newOnDemandThroughput, d := plan.OnDemandThroughput.ToPtr(ctx)
		response.Diagnostics.Append(d...)
		if response.Diagnostics.HasError() {
			return
		}

		if newOnDemandThroughput.MaxReadRequestUnits.IsNull() || newOnDemandThroughput.MaxReadRequestUnits.IsUnknown() {
			newOnDemandThroughput.MaxReadRequestUnits = types.Int64Value(-1)
		}
		if newOnDemandThroughput.MaxWriteRequestUnits.IsNull() || newOnDemandThroughput.MaxWriteRequestUnits.IsUnknown() {
			newOnDemandThroughput.MaxWriteRequestUnits = types.Int64Value(-1)
		}

		plan.OnDemandThroughput = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, newOnDemandThroughput)
	}

	if updateProvisionedThroughput || updateOnDemandThroughput || updateWarmThroughput {
		updateTimeout := r.UpdateTimeout(ctx, plan.Timeouts)
		conn := r.Meta().DynamoDBClient(ctx)

		table, err := waitAllGSIActive(ctx, conn, plan.TableName.ValueString(), updateTimeout)
		if err != nil {
			if retry.NotFound(err) {
				response.Diagnostics.Append(fwdiag.NewResourceNotFoundWarningDiagnostic(err))
				response.State.RemoveResource(ctx)
			} else {
				response.Diagnostics.AddError(
					fmt.Sprintf(`Unable to read table "%s"`, plan.TableName.ValueString()),
					err.Error(),
				)
			}

			return
		}

		response.Diagnostics.Append(validateNewGSIAttributes(ctx, plan, table)...)
		if response.Diagnostics.HasError() {
			return
		}

		input := dynamodb.UpdateTableInput{
			TableName:                   plan.TableName.ValueStringPointer(),
			GlobalSecondaryIndexUpdates: make([]awstypes.GlobalSecondaryIndexUpdate, 1),
		}

		var action awstypes.UpdateGlobalSecondaryIndexAction
		response.Diagnostics.Append(fwflex.Expand(ctx, plan, &action)...)
		if response.Diagnostics.HasError() {
			return
		}

		if updateProvisionedThroughput || updateOnDemandThroughput {
			innerAction := action
			innerAction.WarmThroughput = nil

			input.GlobalSecondaryIndexUpdates[0].Update = &innerAction

			_, err := conn.UpdateTable(ctx, &input)
			if err != nil {
				smerr.AddError(ctx, &response.Diagnostics, err, names.AttrTableName, plan.TableName.ValueString(), "index_name", plan.IndexName.ValueString())
				return
			}
		}

		if updateWarmThroughput {
			innerAction := action
			innerAction.OnDemandThroughput = nil
			innerAction.ProvisionedThroughput = nil

			input.GlobalSecondaryIndexUpdates[0].Update = &innerAction

			_, err := conn.UpdateTable(ctx, &input)
			if err != nil {
				smerr.AddError(ctx, &response.Diagnostics, err, names.AttrTableName, plan.TableName.ValueString(), "index_name", plan.IndexName.ValueString())
				return
			}
		}

		if table, err = waitTableActive(ctx, conn, plan.TableName.ValueString(), updateTimeout); err != nil {
			smerr.AddError(ctx, &response.Diagnostics, err, names.AttrTableName, plan.TableName.ValueString(), "index_name", plan.IndexName.ValueString())
			return
		}

		if err = waitGSIWarmThroughputActive(ctx, conn, plan.TableName.ValueString(), plan.IndexName.ValueString(), updateTimeout); err != nil {
			smerr.AddError(ctx, &response.Diagnostics, err, names.AttrTableName, plan.TableName.ValueString(), "index_name", plan.IndexName.ValueString())
			return
		}

		index, err := waitGSIActive(ctx, conn, plan.TableName.ValueString(), plan.IndexName.ValueString(), updateTimeout)
		if err != nil {
			smerr.AddError(ctx, &response.Diagnostics, err, names.AttrTableName, plan.TableName.ValueString(), "index_name", plan.IndexName.ValueString())
			return
		}

		response.Diagnostics.Append(flattenGlobalSecondaryIndex(ctx, &plan, index, table)...)
		if response.Diagnostics.HasError() {
			return
		}
	}

	response.Diagnostics.Append(response.State.Set(ctx, &plan)...)
}
