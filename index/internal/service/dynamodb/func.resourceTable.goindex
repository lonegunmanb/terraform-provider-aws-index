package github.com/hashicorp/terraform-provider-aws/internal/service/dynamodb
import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"
	"slices"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	awstypes "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/go-multierror"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tfmaps "github.com/hashicorp/terraform-provider-aws/internal/maps"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	"github.com/hashicorp/terraform-provider-aws/internal/service/kms"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceTable() *schema.Resource {
	//lintignore:R011
	return &schema.Resource{
		CreateWithoutTimeout: resourceTableCreate,
		ReadWithoutTimeout:   resourceTableRead,
		UpdateWithoutTimeout: resourceTableUpdate,
		DeleteWithoutTimeout: resourceTableDelete,

		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(createTableTimeout),
			Delete: schema.DefaultTimeout(deleteTableTimeout),
			Update: schema.DefaultTimeout(updateTableTimeoutTotal),
		},

		CustomizeDiff: customdiff.All(
			func(_ context.Context, diff *schema.ResourceDiff, meta any) error {
				return validStreamSpec(diff)
			},
			func(_ context.Context, diff *schema.ResourceDiff, meta any) error {
				return validateTableAttributes(diff)
			},
			func(_ context.Context, diff *schema.ResourceDiff, meta any) error {
				if diff.Id() != "" && diff.HasChange("server_side_encryption") {
					o, n := diff.GetChange("server_side_encryption")
					if isTableOptionDisabled(o) && isTableOptionDisabled(n) {
						return diff.Clear("server_side_encryption")
					}
				}
				return nil
			},
			func(_ context.Context, diff *schema.ResourceDiff, meta any) error {
				if diff.Id() != "" && diff.HasChange("point_in_time_recovery") {
					o, n := diff.GetChange("point_in_time_recovery")
					if isTableOptionDisabled(o) && isTableOptionDisabled(n) {
						return diff.Clear("point_in_time_recovery")
					}
				}
				return nil
			},
			func(_ context.Context, diff *schema.ResourceDiff, meta any) error {
				if diff.Id() != "" && (diff.HasChange("stream_enabled") || (diff.Get("stream_view_type") != "" && diff.HasChange("stream_view_type"))) {
					if err := diff.SetNewComputed(names.AttrStreamARN); err != nil {
						return fmt.Errorf("setting stream_arn to computed: %w", err)
					}
				}
				return nil
			},
			func(_ context.Context, diff *schema.ResourceDiff, meta any) error {
				if v := diff.Get("restore_source_name"); v != "" {
					return nil
				}

				if !diff.GetRawPlan().GetAttr("restore_source_table_arn").IsWhollyKnown() ||
					diff.Get("restore_source_table_arn") != "" {
					return nil
				}

				var errs []error
				if err := validateProvisionedThroughputField(diff, "read_capacity"); err != nil {
					errs = append(errs, err)
				}
				if err := validateProvisionedThroughputField(diff, "write_capacity"); err != nil {
					errs = append(errs, err)
				}
				return errors.Join(errs...)
			},
			customdiff.ForceNewIfChange("restore_source_name", func(_ context.Context, old, new, meta any) bool {
				// If they differ force new unless new is cleared
				// https://github.com/hashicorp/terraform-provider-aws/issues/25214
				return old.(string) != new.(string) && new.(string) != ""
			}),
			customdiff.ForceNewIfChange("restore_source_table_arn", func(_ context.Context, old, new, meta any) bool {
				return old.(string) != new.(string) && new.(string) != ""
			}),
			customdiff.ForceNewIfChange("warm_throughput.0.read_units_per_second", func(_ context.Context, old, new, meta any) bool {
				// warm_throughput can only be increased, not decreased
				// i.e., "api error ValidationException: One or more parameter values were invalid: Requested ReadUnitsPerSecond for WarmThroughput for table is lower than current WarmThroughput, decreasing WarmThroughput is not supported"
				if old, new := old.(int), new.(int); new != 0 && new < old {
					return true
				}

				return false
			}),
			customdiff.ForceNewIfChange("warm_throughput.0.write_units_per_second", func(_ context.Context, old, new, meta any) bool {
				// warm_throughput can only be increased, not decreased
				// i.e., "api error ValidationException: One or more parameter values were invalid: Requested ReadUnitsPerSecond for WarmThroughput for table is lower than current WarmThroughput, decreasing WarmThroughput is not supported"
				if old, new := old.(int), new.(int); new != 0 && new < old {
					return true
				}

				return false
			}),
			validateWarmThroughputCustomDiff,
			validateTTLCustomDiff,
		),

		SchemaVersion: 1,
		MigrateState:  resourceTableMigrateState,

		SchemaFunc: func() map[string]*schema.Schema {
			return map[string]*schema.Schema{
				names.AttrARN: {
					Type:     schema.TypeString,
					Computed: true,
				},
				"attribute": {
					Type:     schema.TypeSet,
					Optional: true,
					Computed: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							names.AttrName: {
								Type:     schema.TypeString,
								Required: true,
							},
							names.AttrType: {
								Type:             schema.TypeString,
								Required:         true,
								ValidateDiagFunc: enum.Validate[awstypes.ScalarAttributeType](),
							},
						},
					},
					Set: sdkv2.SimpleSchemaSetFunc(names.AttrName),
				},
				"billing_mode": {
					Type:             schema.TypeString,
					Optional:         true,
					Default:          awstypes.BillingModeProvisioned,
					ValidateDiagFunc: enum.Validate[awstypes.BillingMode](),
				},
				"deletion_protection_enabled": {
					Type:     schema.TypeBool,
					Optional: true,
				},
				"global_secondary_index": {
					Type:     schema.TypeSet,
					Optional: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"hash_key": {
								Type:     schema.TypeString,
								Required: true,
							},
							names.AttrName: {
								Type:     schema.TypeString,
								Required: true,
							},
							"non_key_attributes": {
								Type:     schema.TypeSet,
								Optional: true,
								Elem:     &schema.Schema{Type: schema.TypeString},
							},
							"on_demand_throughput": onDemandThroughputSchema(),
							"projection_type": {
								Type:             schema.TypeString,
								Required:         true,
								ValidateDiagFunc: enum.Validate[awstypes.ProjectionType](),
							},
							"range_key": {
								Type:     schema.TypeString,
								Optional: true,
							},
							"read_capacity": {
								Type:     schema.TypeInt,
								Optional: true,
								Computed: true,
							},
							"warm_throughput": warmThroughputSchema(),
							"write_capacity": {
								Type:     schema.TypeInt,
								Optional: true,
								Computed: true,
							},
						},
					},
				},
				"hash_key": {
					Type:     schema.TypeString,
					Optional: true,
					Computed: true,
					ForceNew: true,
				},
				"import_table": {
					Type:          schema.TypeList,
					Optional:      true,
					MaxItems:      1,
					ConflictsWith: []string{"restore_source_name", "restore_source_table_arn"},
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"input_compression_type": {
								Type:             schema.TypeString,
								Optional:         true,
								ValidateDiagFunc: enum.Validate[awstypes.InputCompressionType](),
							},
							"input_format": {
								Type:             schema.TypeString,
								Required:         true,
								ValidateDiagFunc: enum.Validate[awstypes.InputFormat](),
							},
							"input_format_options": {
								Type:     schema.TypeList,
								Optional: true,
								MaxItems: 1,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										"csv": {
											Type:     schema.TypeList,
											Optional: true,
											MaxItems: 1,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													"delimiter": {
														Type:     schema.TypeString,
														Optional: true,
													},
													"header_list": {
														Type:     schema.TypeSet,
														Optional: true,
														Elem:     &schema.Schema{Type: schema.TypeString},
													},
												},
											},
										},
									},
								},
							},
							"s3_bucket_source": {
								Type:     schema.TypeList,
								MaxItems: 1,
								Required: true,
								ForceNew: true,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										names.AttrBucket: {
											Type:     schema.TypeString,
											Required: true,
										},
										"bucket_owner": {
											Type:     schema.TypeString,
											Optional: true,
										},
										"key_prefix": {
											Type:     schema.TypeString,
											Optional: true,
										},
									},
								},
							},
						},
					},
				},
				"local_secondary_index": {
					Type:     schema.TypeSet,
					Optional: true,
					ForceNew: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							names.AttrName: {
								Type:     schema.TypeString,
								Required: true,
								ForceNew: true,
							},
							"non_key_attributes": {
								Type:     schema.TypeList,
								Optional: true,
								ForceNew: true,
								Elem:     &schema.Schema{Type: schema.TypeString},
							},
							"projection_type": {
								Type:             schema.TypeString,
								Required:         true,
								ForceNew:         true,
								ValidateDiagFunc: enum.Validate[awstypes.ProjectionType](),
							},
							"range_key": {
								Type:     schema.TypeString,
								Required: true,
								ForceNew: true,
							},
						},
					},
					Set: sdkv2.SimpleSchemaSetFunc(names.AttrName),
				},
				names.AttrName: {
					Type:     schema.TypeString,
					Required: true,
					ForceNew: true,
				},
				"on_demand_throughput": onDemandThroughputSchema(),
				"point_in_time_recovery": {
					Type:     schema.TypeList,
					Optional: true,
					Computed: true,
					MaxItems: 1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							names.AttrEnabled: {
								Type:     schema.TypeBool,
								Required: true,
							},
							"recovery_period_in_days": {
								Type:         schema.TypeInt,
								Optional:     true,
								Computed:     true,
								ValidateFunc: validation.IntBetween(1, 35),
								DiffSuppressFunc: func(k, oldValue, newValue string, d *schema.ResourceData) bool {
									return !d.Get("point_in_time_recovery.0.enabled").(bool)
								},
							},
						},
					},
				},
				"range_key": {
					Type:     schema.TypeString,
					Optional: true,
					ForceNew: true,
				},
				"read_capacity": {
					Type:          schema.TypeInt,
					Optional:      true,
					Computed:      true,
					ConflictsWith: []string{"on_demand_throughput"},
				},
				"replica": {
					Type:     schema.TypeSet,
					Optional: true,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							names.AttrARN: {
								Type:     schema.TypeString,
								Computed: true,
							},
							"consistency_mode": {
								Type:             schema.TypeString,
								Optional:         true,
								Default:          awstypes.MultiRegionConsistencyEventual,
								ValidateDiagFunc: enum.Validate[awstypes.MultiRegionConsistency](),
							},
							"deletion_protection_enabled": {
								Type:     schema.TypeBool,
								Optional: true,
								Computed: true,
							},
							names.AttrKMSKeyARN: {
								Type:         schema.TypeString,
								Optional:     true,
								Computed:     true,
								ValidateFunc: verify.ValidARN,
								// update is equivalent of force a new *replica*, not table
							},
							"point_in_time_recovery": {
								Type:     schema.TypeBool,
								Optional: true,
								Default:  false,
							},
							names.AttrPropagateTags: {
								Type:     schema.TypeBool,
								Optional: true,
								Default:  false,
							},
							"region_name": {
								Type:     schema.TypeString,
								Required: true,
								// update is equivalent of force a new *replica*, not table
							},
							names.AttrStreamARN: {
								Type:     schema.TypeString,
								Computed: true,
							},
							"stream_label": {
								Type:     schema.TypeString,
								Computed: true,
							},
						},
					},
				},
				"restore_date_time": {
					Type:         schema.TypeString,
					Optional:     true,
					ForceNew:     true,
					ValidateFunc: verify.ValidUTCTimestamp,
				},
				"restore_source_table_arn": {
					Type:          schema.TypeString,
					Optional:      true,
					ValidateFunc:  verify.ValidARN,
					ConflictsWith: []string{"import_table", "restore_source_name"},
				},
				"restore_source_name": {
					Type:          schema.TypeString,
					Optional:      true,
					ConflictsWith: []string{"import_table", "restore_source_table_arn"},
				},
				"restore_to_latest_time": {
					Type:     schema.TypeBool,
					Optional: true,
					ForceNew: true,
				},
				"server_side_encryption": {
					Type:     schema.TypeList,
					Optional: true,
					Computed: true,
					MaxItems: 1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							names.AttrEnabled: {
								Type:     schema.TypeBool,
								Required: true,
							},
							names.AttrKMSKeyARN: {
								Type:         schema.TypeString,
								Optional:     true,
								Computed:     true,
								ValidateFunc: verify.ValidARN,
							},
						},
					},
				},
				names.AttrStreamARN: {
					Type:     schema.TypeString,
					Computed: true,
				},
				"stream_enabled": {
					Type:     schema.TypeBool,
					Optional: true,
				},
				"stream_label": {
					Type:     schema.TypeString,
					Computed: true,
				},
				"stream_view_type": {
					Type:         schema.TypeString,
					Optional:     true,
					Computed:     true,
					StateFunc:    sdkv2.ToUpperSchemaStateFunc,
					ValidateFunc: validation.StringInSlice(append(enum.Values[awstypes.StreamViewType](), ""), false),
				},
				"table_class": {
					Type:     schema.TypeString,
					Optional: true,
					Default:  awstypes.TableClassStandard,
					DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
						return old == "" && new == string(awstypes.TableClassStandard)
					},
					ValidateDiagFunc: enum.Validate[awstypes.TableClass](),
				},
				names.AttrTags:    tftags.TagsSchema(),
				names.AttrTagsAll: tftags.TagsSchemaComputed(),
				"ttl": {
					Type:     schema.TypeList,
					Optional: true,
					Computed: true,
					MaxItems: 1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"attribute_name": {
								Type:     schema.TypeString,
								Optional: true,
								DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
									// AWS requires the attribute name to be set when disabling TTL but
									// does not return it so it causes a diff.
									if old == "" && new != "" && !d.Get("ttl.0.enabled").(bool) {
										return true
									}
									return false
								},
							},
							names.AttrEnabled: {
								Type:     schema.TypeBool,
								Optional: true,
								Default:  false,
							},
						},
					},
					DiffSuppressFunc: verify.SuppressMissingOptionalConfigurationBlock,
				},
				"warm_throughput": warmThroughputSchema(),
				"write_capacity": {
					Type:          schema.TypeInt,
					Computed:      true,
					Optional:      true,
					ConflictsWith: []string{"on_demand_throughput"},
				},
			}
		},
	}
}
