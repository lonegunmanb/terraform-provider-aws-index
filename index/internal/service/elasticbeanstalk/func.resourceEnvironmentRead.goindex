package github.com/hashicorp/terraform-provider-aws/internal/service/elasticbeanstalk
import ( // nosemgrep:ci.semgrep.aws.multiple-service-imports
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"slices"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	"github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk"
	awstypes "github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	sdktypes "github.com/hashicorp/terraform-provider-aws/internal/sdkv2/types"
	tfec2 "github.com/hashicorp/terraform-provider-aws/internal/service/ec2"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceEnvironmentRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).ElasticBeanstalkClient(ctx)

	env, err := findEnvironmentByID(ctx, conn, d.Id())

	if !d.IsNewResource() && retry.NotFound(err) {
		log.Printf("[WARN] Elastic Beanstalk Environment (%s) not found, removing from state", d.Id())
		d.SetId("")
		return diags
	}

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "reading Elastic Beanstalk Environment (%s): %s", d.Id(), err)
	}

	resources, err := conn.DescribeEnvironmentResources(ctx, &elasticbeanstalk.DescribeEnvironmentResourcesInput{
		EnvironmentId: aws.String(d.Id()),
	})

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "reading Elastic Beanstalk Environment (%s) resources: %s", d.Id(), err)
	}

	input := elasticbeanstalk.DescribeConfigurationSettingsInput{
		ApplicationName: env.ApplicationName,
		EnvironmentName: env.EnvironmentName,
	}
	configurationSettings, err := findConfigurationSettings(ctx, conn, &input)

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "reading Elastic Beanstalk Environment (%s) configuration settings: %s", d.Id(), err)
	}

	d.Set("application", env.ApplicationName)
	d.Set(names.AttrARN, env.EnvironmentArn)
	if err := d.Set("autoscaling_groups", flattenAutoScalingGroups(resources.EnvironmentResources.AutoScalingGroups)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting autoscaling_groups: %s", err)
	}
	cname := aws.ToString(env.CNAME)
	d.Set("cname", cname)
	if cname != "" {
		var cnamePrefix string

		if cnamePrefixMatch := environmentCNAMERegex.FindStringSubmatch(cname); len(cnamePrefixMatch) > 1 {
			cnamePrefix = cnamePrefixMatch[1]
		}

		d.Set("cname_prefix", cnamePrefix)
	} else {
		d.Set("cname_prefix", "")
	}
	d.Set(names.AttrDescription, env.Description)
	d.Set("endpoint_url", env.EndpointURL)
	if err := d.Set("instances", flattenInstances(resources.EnvironmentResources.Instances)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting instances: %s", err)
	}
	if err := d.Set("launch_configurations", flattenLaunchConfigurations(resources.EnvironmentResources.LaunchConfigurations)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting launch_configurations: %s", err)
	}
	if err := d.Set("load_balancers", flattenLoadBalancers(resources.EnvironmentResources.LoadBalancers)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting load_balancers: %s", err)
	}
	d.Set(names.AttrName, env.EnvironmentName)
	d.Set("platform_arn", env.PlatformArn)
	if err := d.Set("queues", flattenQueues(resources.EnvironmentResources.Queues)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting queues: %s", err)
	}
	d.Set("solution_stack_name", env.SolutionStackName)
	d.Set("tier", env.Tier.Name)
	if err := d.Set(names.AttrTriggers, flattenTriggers(resources.EnvironmentResources.Triggers)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting triggers: %s", err)
	}
	d.Set("version_label", env.VersionLabel)

	var configuredSettings []any
	if v, ok := d.GetOk("setting"); ok && v.(*schema.Set).Len() > 0 {
		configuredSettings = v.(*schema.Set).List()
	}
	apiSettings := flattenConfigurationOptionSettings(ctx, meta, configurationSettings.OptionSettings)
	var settings []any

	for _, apiSetting := range apiSettings {
		tfMap := apiSetting.(map[string]any)
		isMatch := func(v any) bool {
			m := v.(map[string]any)

			return m[names.AttrNamespace].(string) == tfMap[names.AttrNamespace].(string) &&
				m[names.AttrName].(string) == tfMap[names.AttrName].(string) &&
				m["resource"].(string) == tfMap["resource"].(string)
		}
		if slices.ContainsFunc(configuredSettings, isMatch) {
			settings = append(settings, apiSetting)
		}
	}

	if err := d.Set("all_settings", apiSettings); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting all_settings: %s", err)
	}

	if err := d.Set("setting", settings); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting setting: %s", err)
	}

	return diags
}
