package github.com/hashicorp/terraform-provider-aws/internal/service/elasticbeanstalk
import ( // nosemgrep:ci.semgrep.aws.multiple-service-imports
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"slices"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	"github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk"
	awstypes "github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	sdktypes "github.com/hashicorp/terraform-provider-aws/internal/sdkv2/types"
	tfec2 "github.com/hashicorp/terraform-provider-aws/internal/service/ec2"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceEnvironmentUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).ElasticBeanstalkClient(ctx)

	waitForReadyTimeOut, _, err := sdktypes.Duration(d.Get("wait_for_ready_timeout").(string)).Value()

	if err != nil {
		return sdkdiag.AppendFromErr(diags, err)
	}

	pollInterval, _, err := sdktypes.Duration(d.Get("poll_interval").(string)).Value()

	if err != nil {
		pollInterval = 0
	}

	opTime := time.Now()

	if d.HasChangesExcept(names.AttrTags, names.AttrTagsAll, "poll_interval", "wait_for_ready_timeout") {
		if d.HasChange(names.AttrTagsAll) {
			if _, err := waitEnvironmentReady(ctx, conn, d.Id(), pollInterval, waitForReadyTimeOut); err != nil {
				return sdkdiag.AppendErrorf(diags, "waiting for Elastic Beanstalk Environment (%s) tags update: %s", d.Id(), err)
			}
		}

		input := elasticbeanstalk.UpdateEnvironmentInput{
			EnvironmentId: aws.String(d.Id()),
		}

		if d.HasChange(names.AttrDescription) {
			input.Description = aws.String(d.Get(names.AttrDescription).(string))
		}

		if d.HasChange("platform_arn") {
			if v, ok := d.GetOk("platform_arn"); ok {
				input.PlatformArn = aws.String(v.(string))
			}
		}

		if d.HasChange("setting") {
			o, n := d.GetChange("setting")
			os, ns := o.(*schema.Set), n.(*schema.Set)
			add, del := expandConfigurationOptionSettings(ns.Difference(os).List()), expandConfigurationOptionSettings(os.Difference(ns).List())

			// Additions and removals of options are done in a single API call, so we
			// can't do our normal "remove these" and then later "add these", re-adding
			// any updated settings.
			// Because of this, we need to exclude any settings in the "removable"
			// settings that are also found in the "add" settings, otherwise they
			// conflict. Here we loop through all the initial removables from the set
			// difference, and create a new slice `remove` that contains those settings
			// found in `rm` but not in `add`
			var remove []awstypes.ConfigurationOptionSetting
			if len(add) > 0 {
				for _, r := range del {
					var update = false
					for _, a := range add {
						// ResourceNames are optional. Some defaults come with it, some do
						// not. We need to guard against nil/empty in state as well as
						// nil/empty from the API
						if a.ResourceName != nil {
							if r.ResourceName == nil {
								continue
							}
							if aws.ToString(r.ResourceName) != aws.ToString(a.ResourceName) {
								continue
							}
						}
						if aws.ToString(r.Namespace) == aws.ToString(a.Namespace) && aws.ToString(r.OptionName) == aws.ToString(a.OptionName) {
							update = true
							break
						}
					}
					// Only remove options that are not updates
					if !update {
						remove = append(remove, r)
					}
				}
			} else {
				remove = del
			}

			for _, v := range remove {
				input.OptionsToRemove = append(input.OptionsToRemove, awstypes.OptionSpecification{
					Namespace:  v.Namespace,
					OptionName: v.OptionName,
				})
			}

			input.OptionSettings = add
		}

		if d.HasChange("solution_stack_name") {
			if v, ok := d.GetOk("solution_stack_name"); ok {
				input.SolutionStackName = aws.String(v.(string))
			}
		}

		if d.HasChange("template_name") {
			if v, ok := d.GetOk("template_name"); ok {
				input.TemplateName = aws.String(v.(string))
			}
		}

		if d.HasChange("version_label") {
			input.VersionLabel = aws.String(d.Get("version_label").(string))
		}

		_, err := conn.UpdateEnvironment(ctx, &input)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating Elastic Beanstalk Environment (%s): %s", d.Id(), err)
		}
	}

	if _, err := waitEnvironmentReady(ctx, conn, d.Id(), pollInterval, waitForReadyTimeOut); err != nil {
		return sdkdiag.AppendErrorf(diags, "waiting for Elastic Beanstalk Environment (%s) update: %s", d.Id(), err)
	}

	err = findEnvironmentErrorsByID(ctx, conn, d.Id(), opTime)

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "updating Elastic Beanstalk Environment (%s): %s", d.Id(), err)
	}

	return append(diags, resourceEnvironmentRead(ctx, d, meta)...)
}
