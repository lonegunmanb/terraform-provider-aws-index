package github.com/hashicorp/terraform-provider-aws/internal/service/elasticbeanstalk
import (
	"context"
	"log"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk"
	awstypes "github.com/aws/aws-sdk-go-v2/service/elasticbeanstalk/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceConfigurationTemplateUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).ElasticBeanstalkClient(ctx)

	if d.HasChange(names.AttrDescription) {
		input := &elasticbeanstalk.UpdateConfigurationTemplateInput{
			ApplicationName: aws.String(d.Get("application").(string)),
			Description:     aws.String(d.Get(names.AttrDescription).(string)),
			TemplateName:    aws.String(d.Id()),
		}

		_, err := conn.UpdateConfigurationTemplate(ctx, input)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating Elastic Beanstalk Configuration Template (%s): %s", d.Id(), err)
		}
	}

	if d.HasChange("setting") {
		o, n := d.GetChange("setting")
		os, ns := o.(*schema.Set), n.(*schema.Set)
		add, del := expandConfigurationOptionSettings(ns.Difference(os).List()), expandConfigurationOptionSettings(os.Difference(ns).List())

		// Additions and removals of options are done in a single API call, so we
		// can't do our normal "remove these" and then later "add these", re-adding
		// any updated settings.
		// Because of this, we need to remove any settings in the "removable"
		// settings that are also found in the "add" settings, otherwise they
		// conflict. Here we loop through all the initial removables from the set
		// difference, and we build up a slice of settings not found in the "add"
		// set

		defaultResourceName := func(ns *string) *string {
			switch aws.ToString(ns) {
			case "aws:autoscaling:asg":
				return aws.String("AWSEBAutoScalingGroup")
			case "aws:autoscaling:launchconfiguration":
				return aws.String("AWSEBAutoScalingLaunchConfiguration")
			default:
				return nil
			}
		}
		ensureResourceName := func(s *awstypes.ConfigurationOptionSetting) {
			if s.ResourceName == nil || aws.ToString(s.ResourceName) == "" {
				if rn := defaultResourceName(s.Namespace); rn != nil {
					s.ResourceName = rn
				}
			}
		}

		for i := range add {
			ensureResourceName(&add[i])
		}
		for i := range del {
			ensureResourceName(&del[i])
		}

		key := func(ns, on, rn *string) string {
			return aws.ToString(ns) + "|" + aws.ToString(on) + "|" + aws.ToString(rn)
		}

		addKeys := make(map[string]struct{}, len(add))
		for _, a := range add {
			addKeys[key(a.Namespace, a.OptionName, a.ResourceName)] = struct{}{}
		}

		var remove []awstypes.ConfigurationOptionSetting
		for _, r := range del {
			if _, exists := addKeys[key(r.Namespace, r.OptionName, r.ResourceName)]; !exists {
				remove = append(remove, r)
			}
		}

		input := &elasticbeanstalk.UpdateConfigurationTemplateInput{
			ApplicationName: aws.String(d.Get("application").(string)),
			OptionSettings:  add,
			TemplateName:    aws.String(d.Id()),
		}

		for _, v := range remove {
			input.OptionsToRemove = append(input.OptionsToRemove, awstypes.OptionSpecification{
				Namespace:    v.Namespace,
				OptionName:   v.OptionName,
				ResourceName: v.ResourceName,
			})
		}

		_, err := conn.UpdateConfigurationTemplate(ctx, input)

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "updating Elastic Beanstalk Configuration Template (%s): %s", d.Id(), err)
		}
	}

	return append(diags, resourceConfigurationTemplateRead(ctx, d, meta)...)
}
