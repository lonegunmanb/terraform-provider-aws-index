package github.com/hashicorp/terraform-provider-aws/internal/service/redshiftserverless
import (
	"context"
	"fmt"
	"log"
	"slices"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/redshiftserverless"
	awstypes "github.com/aws/aws-sdk-go-v2/service/redshiftserverless/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func prepareCapacityUpdates(d *schema.ResourceData) []updateOp {
	const (
		opDisablePricePerformanceTarget = "disable price_performance_target"
		opEnablePricePerformanceTarget  = "enable price_performance_target"
		opUpdateBaseCapacity            = "update base_capacity"
		opUpdateMaxCapacity             = "update max_capacity"
		opRemoveMaxCapacity             = "remove max_capacity"
	)

	var ops []updateOp

	checkCapacityChange := func(key string) (bool, int, int) {
		o, n := d.GetChange(key)
		oldCapacity, newCapacity := o.(int), n.(int)
		hasCapacityChange := newCapacity != oldCapacity
		return hasCapacityChange, oldCapacity, newCapacity
	}

	checkPricePerformanceChange := func(hasBaseChange bool) (bool, bool, *awstypes.PerformanceTarget) {
		ppt := expandPerformanceTarget(d.Get("price_performance_target").([]any))

		hasChange := d.HasChange("price_performance_target")
		hasPPTDisabledChange := hasChange && ppt != nil && ppt.Status == awstypes.PerformanceTargetStatusDisabled && hasBaseChange
		hasPPTEnabledChange := hasChange && ppt != nil && ppt.Status == awstypes.PerformanceTargetStatusEnabled

		return hasPPTDisabledChange, hasPPTEnabledChange, ppt
	}

	// Fetch all capacity and price performance related changes
	hasBaseChange, _, newBase := checkCapacityChange("base_capacity")
	hasMaxChange, oldMax, newMax := checkCapacityChange(names.AttrMaxCapacity)
	hasPPTDisabledChange, hasPPTEnabledChange, newPPT := checkPricePerformanceChange(hasBaseChange)

	// Plan capacity and price performance related changes
	//
	// 1. price_performance_target is disabled and base capacity is changed
	if hasPPTDisabledChange {
		// When disabling price_performance_target, base_capacity must be sent
		// in the same request to avoid a ValidationException.
		//
		//   ValidationException: You must set a base capacity when disabling pricePerformanceTargetStatus.
		ops = append(ops, updateOp{opDisablePricePerformanceTarget, &redshiftserverless.UpdateWorkgroupInput{
			PricePerformanceTarget: newPPT,
			BaseCapacity:           aws.Int32(int32(newBase)),
			WorkgroupName:          aws.String(d.Id()),
		}})
	}

	// 2. Various combinations of base_capacity and max_capacity changes
	if hasBaseChange && hasMaxChange {
		// When both change, order matters depending on relative values
		if newMax == 0 {
			ops = append(ops,
				updateOp{opUpdateBaseCapacity, &redshiftserverless.UpdateWorkgroupInput{
					BaseCapacity:  aws.Int32(int32(newBase)),
					WorkgroupName: aws.String(d.Id()),
				}},
				updateOp{opRemoveMaxCapacity, &redshiftserverless.UpdateWorkgroupInput{
					MaxCapacity:   aws.Int32(-1),
					WorkgroupName: aws.String(d.Id()),
				}},
			)
		} else if newBase > oldMax && oldMax != 0 {
			ops = append(ops,
				updateOp{opUpdateMaxCapacity, &redshiftserverless.UpdateWorkgroupInput{
					MaxCapacity:   aws.Int32(int32(newMax)),
					WorkgroupName: aws.String(d.Id()),
				}},
				updateOp{opUpdateBaseCapacity, &redshiftserverless.UpdateWorkgroupInput{
					BaseCapacity:  aws.Int32(int32(newBase)),
					WorkgroupName: aws.String(d.Id()),
				}},
			)
		} else {
			ops = append(ops,
				updateOp{opUpdateBaseCapacity, &redshiftserverless.UpdateWorkgroupInput{
					BaseCapacity:  aws.Int32(int32(newBase)),
					WorkgroupName: aws.String(d.Id()),
				}},
				updateOp{opUpdateMaxCapacity, &redshiftserverless.UpdateWorkgroupInput{
					MaxCapacity:   aws.Int32(int32(newMax)),
					WorkgroupName: aws.String(d.Id()),
				}},
			)
		}
	} else if hasBaseChange {
		ops = append(ops, updateOp{opUpdateBaseCapacity, &redshiftserverless.UpdateWorkgroupInput{
			BaseCapacity:  aws.Int32(int32(newBase)),
			WorkgroupName: aws.String(d.Id()),
		}})
	} else if hasMaxChange {
		if newMax == 0 {
			ops = append(ops, updateOp{opRemoveMaxCapacity, &redshiftserverless.UpdateWorkgroupInput{
				MaxCapacity:   aws.Int32(-1),
				WorkgroupName: aws.String(d.Id()),
			}})
		} else {
			ops = append(ops, updateOp{opUpdateMaxCapacity, &redshiftserverless.UpdateWorkgroupInput{
				MaxCapacity:   aws.Int32(int32(newMax)),
				WorkgroupName: aws.String(d.Id()),
			}})
		}
	}

	// 3. price_performance_target is enabled
	if hasPPTEnabledChange {
		// Enable price_performance_target last (after capacity cleared)
		ops = append(ops, updateOp{opEnablePricePerformanceTarget, &redshiftserverless.UpdateWorkgroupInput{
			PricePerformanceTarget: newPPT,
			WorkgroupName:          aws.String(d.Id()),
		}})
	}

	ops = slices.DeleteFunc(ops, func(op updateOp) bool {
		// When disabling price_performance_target, base_capacity is already set in the same
		// request. Remove any duplicate base_capacity-only operations
		return hasPPTDisabledChange && op.name == opUpdateBaseCapacity
	})

	return ops
}
