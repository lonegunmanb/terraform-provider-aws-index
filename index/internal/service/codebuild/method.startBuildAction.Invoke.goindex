package github.com/hashicorp/terraform-provider-aws/internal/service/codebuild
import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/codebuild"
	awstypes "github.com/aws/aws-sdk-go-v2/service/codebuild/types"
	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/actionwait"
	"github.com/hashicorp/terraform-provider-aws/internal/backoff"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (a *startBuildAction) Invoke(ctx context.Context, req action.InvokeRequest, resp *action.InvokeResponse) {
	var model startBuildActionModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	conn := a.Meta().CodeBuildClient(ctx)

	timeout := 30 * time.Minute
	if !model.Timeout.IsNull() {
		timeout = time.Duration(model.Timeout.ValueInt64()) * time.Second
	}

	tflog.Info(ctx, "Starting CodeBuild project build", map[string]any{
		"project_name": model.ProjectName.ValueString(),
	})

	resp.SendProgress(action.InvokeProgressEvent{
		Message: "Starting CodeBuild project build...",
	})

	var input codebuild.StartBuildInput
	resp.Diagnostics.Append(fwflex.Expand(ctx, model, &input)...)
	if resp.Diagnostics.HasError() {
		return
	}

	output, err := conn.StartBuild(ctx, &input)
	if err != nil {
		resp.Diagnostics.AddError("Starting CodeBuild project build", err.Error())
		return
	}

	buildID := aws.ToString(output.Build.Id)
	model.BuildID = types.StringValue(buildID)

	resp.SendProgress(action.InvokeProgressEvent{
		Message: "Build started, waiting for completion...",
	})

	// Poll for build completion using actionwait with backoff strategy
	// Use backoff since builds can take a long time and status changes less frequently
	// as the build progresses - start with frequent polling then back off
	_, err = actionwait.WaitForStatus(ctx, func(ctx context.Context) (actionwait.FetchResult[*awstypes.Build], error) {
		input := codebuild.BatchGetBuildsInput{Ids: []string{buildID}}
		batch, berr := conn.BatchGetBuilds(ctx, &input)
		if berr != nil {
			return actionwait.FetchResult[*awstypes.Build]{}, berr
		}
		if len(batch.Builds) == 0 {
			return actionwait.FetchResult[*awstypes.Build]{}, fmt.Errorf("build not found in BatchGetBuilds response")
		}
		b := batch.Builds[0]
		return actionwait.FetchResult[*awstypes.Build]{Status: actionwait.Status(b.BuildStatus), Value: &b}, nil
	}, actionwait.Options[*awstypes.Build]{
		Timeout:          timeout,
		Interval:         actionwait.WithBackoffDelay(backoff.DefaultSDKv2HelperRetryCompatibleDelay()),
		ProgressInterval: 2 * time.Minute,
		SuccessStates:    []actionwait.Status{actionwait.Status(awstypes.StatusTypeSucceeded)},
		TransitionalStates: []actionwait.Status{
			actionwait.Status(awstypes.StatusTypeInProgress),
		},
		FailureStates: []actionwait.Status{
			actionwait.Status(awstypes.StatusTypeFailed),
			actionwait.Status(awstypes.StatusTypeFault),
			actionwait.Status(awstypes.StatusTypeStopped),
			actionwait.Status(awstypes.StatusTypeTimedOut),
		},
		ProgressSink: func(fr actionwait.FetchResult[any], meta actionwait.ProgressMeta) {
			resp.SendProgress(action.InvokeProgressEvent{Message: "Build currently in state: " + string(fr.Status)})
		},
	})
	if err != nil {
		var timeoutErr *actionwait.TimeoutError
		var failureErr *actionwait.FailureStateError
		var unexpectedErr *actionwait.UnexpectedStateError
		if errors.As(err, &timeoutErr) {
			resp.Diagnostics.AddError("Build timeout", "Build did not complete within the specified timeout")
		} else if errors.As(err, &failureErr) {
			resp.Diagnostics.AddError("Build failed", "Build completed with status: "+err.Error())
		} else if errors.As(err, &unexpectedErr) {
			resp.Diagnostics.AddError("Unexpected build status", err.Error())
		} else {
			resp.Diagnostics.AddError("Error waiting for build", err.Error())
		}
		return
	}

	resp.SendProgress(action.InvokeProgressEvent{Message: "Build completed successfully"})
}
