package github.com/hashicorp/terraform-provider-aws/internal/service/codebuild
import (
	"context"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/codebuild"
	awstypes "github.com/aws/aws-sdk-go-v2/service/codebuild/types"
	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (a *startBuildAction) Invoke(ctx context.Context, req action.InvokeRequest, resp *action.InvokeResponse) {
	var model startBuildActionModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	conn := a.Meta().CodeBuildClient(ctx)

	timeout := 30 * time.Minute
	if !model.Timeout.IsNull() {
		timeout = time.Duration(model.Timeout.ValueInt64()) * time.Second
	}

	tflog.Info(ctx, "Starting CodeBuild project build", map[string]any{
		"project_name": model.ProjectName.ValueString(),
	})

	resp.SendProgress(action.InvokeProgressEvent{
		Message: "Starting CodeBuild project build...",
	})

	var input codebuild.StartBuildInput
	resp.Diagnostics.Append(fwflex.Expand(ctx, model, &input)...)
	if resp.Diagnostics.HasError() {
		return
	}

	output, err := conn.StartBuild(ctx, &input)
	if err != nil {
		resp.Diagnostics.AddError("Starting CodeBuild project build", err.Error())
		return
	}

	buildID := aws.ToString(output.Build.Id)
	model.BuildID = types.StringValue(buildID)

	resp.SendProgress(action.InvokeProgressEvent{
		Message: "Build started, waiting for completion...",
	})

	// Poll for build completion
	deadline := time.Now().Add(timeout)
	pollInterval := 30 * time.Second
	progressInterval := 2 * time.Minute
	lastProgressUpdate := time.Now()

	for {
		select {
		case <-ctx.Done():
			resp.Diagnostics.AddError("Build monitoring cancelled", "Context was cancelled")
			return
		default:
		}

		if time.Now().After(deadline) {
			resp.Diagnostics.AddError("Build timeout", "Build did not complete within the specified timeout")
			return
		}

		input := codebuild.BatchGetBuildsInput{
			Ids: []string{buildID},
		}
		batchGetBuildsOutput, err := conn.BatchGetBuilds(ctx, &input)
		if err != nil {
			resp.Diagnostics.AddError("Getting build status", err.Error())
			return
		}

		if len(batchGetBuildsOutput.Builds) == 0 {
			resp.Diagnostics.AddError("Build not found", "Build was not found in BatchGetBuilds response")
			return
		}

		build := batchGetBuildsOutput.Builds[0]
		status := build.BuildStatus

		if time.Since(lastProgressUpdate) >= progressInterval {
			resp.SendProgress(action.InvokeProgressEvent{
				Message: "Build currently in state: " + string(status),
			})
			lastProgressUpdate = time.Now()
		}

		switch status {
		case awstypes.StatusTypeSucceeded:
			resp.SendProgress(action.InvokeProgressEvent{
				Message: "Build completed successfully",
			})
			return
		case awstypes.StatusTypeFailed, awstypes.StatusTypeFault, awstypes.StatusTypeStopped, awstypes.StatusTypeTimedOut:
			resp.Diagnostics.AddError("Build failed", "Build completed with status: "+string(status))
			return
		case awstypes.StatusTypeInProgress:
			// Continue polling
		default:
			resp.Diagnostics.AddError("Unexpected build status", "Received unexpected build status: "+string(status))
			return
		}

		time.Sleep(pollInterval)
	}
}
