package github.com/hashicorp/terraform-provider-aws/internal/service/dms
import (
	"context"
	"fmt"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	awstypes "github.com/aws/aws-sdk-go-v2/service/databasemigrationservice/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func flattenS3Settings(apiObject *awstypes.S3Settings) []map[string]any {
	if apiObject == nil {
		return []map[string]any{}
	}

	tfMap := map[string]any{}

	if v := apiObject.AddColumnName; v != nil {
		tfMap["add_column_name"] = aws.ToBool(v)
	}
	if v := apiObject.BucketFolder; v != nil {
		tfMap["bucket_folder"] = aws.ToString(v)
	}
	if v := apiObject.BucketName; v != nil {
		tfMap[names.AttrBucketName] = aws.ToString(v)
	}
	tfMap["canned_acl_for_objects"] = string(apiObject.CannedAclForObjects)
	if v := apiObject.CdcInsertsAndUpdates; v != nil {
		tfMap["cdc_inserts_and_updates"] = aws.ToBool(v)
	}
	if v := apiObject.CdcInsertsOnly; v != nil {
		tfMap["cdc_inserts_only"] = aws.ToBool(v)
	}
	if v := apiObject.CdcMaxBatchInterval; v != nil {
		tfMap["cdc_max_batch_interval"] = aws.ToInt32(v)
	}
	if v := apiObject.CdcMinFileSize; v != nil {
		tfMap["cdc_min_file_size"] = aws.ToInt32(v)
	}
	if v := apiObject.CdcPath; v != nil {
		tfMap["cdc_path"] = aws.ToString(v)
	}
	tfMap["compression_type"] = string(apiObject.CompressionType)
	if v := apiObject.CsvDelimiter; v != nil {
		tfMap["csv_delimiter"] = aws.ToString(v)
	}
	if v := apiObject.CsvNoSupValue; v != nil {
		tfMap["csv_no_sup_value"] = aws.ToString(v)
	}
	if v := apiObject.CsvNullValue; v != nil {
		tfMap["csv_null_value"] = aws.ToString(v)
	}
	if v := apiObject.CsvRowDelimiter; v != nil {
		tfMap["csv_row_delimiter"] = aws.ToString(v)
	}
	tfMap["data_format"] = string(apiObject.DataFormat)
	if v := apiObject.DataPageSize; v != nil {
		tfMap["data_page_size"] = aws.ToInt32(v)
	}
	tfMap["date_partition_delimiter"] = string(apiObject.DatePartitionDelimiter)
	if v := apiObject.DatePartitionEnabled; v != nil {
		tfMap["date_partition_enabled"] = aws.ToBool(v)
	}
	tfMap["date_partition_sequence"] = string(apiObject.DatePartitionSequence)
	if v := apiObject.DictPageSizeLimit; v != nil {
		tfMap["dict_page_size_limit"] = aws.ToInt32(v)
	}
	if v := apiObject.EnableStatistics; v != nil {
		tfMap["enable_statistics"] = aws.ToBool(v)
	}
	tfMap["encoding_type"] = string(apiObject.EncodingType)
	tfMap["encryption_mode"] = string(apiObject.EncryptionMode)
	if v := apiObject.ExternalTableDefinition; v != nil {
		tfMap["external_table_definition"] = aws.ToString(v)
	}
	if v := apiObject.GlueCatalogGeneration; v != nil {
		tfMap["glue_catalog_generation"] = aws.ToBool(v)
	}
	if v := apiObject.IgnoreHeaderRows; v != nil {
		tfMap["ignore_header_rows"] = aws.ToInt32(v)
	}
	if v := apiObject.IncludeOpForFullLoad; v != nil {
		tfMap["include_op_for_full_load"] = aws.ToBool(v)
	}
	if v := apiObject.MaxFileSize; v != nil {
		tfMap["max_file_size"] = aws.ToInt32(v)
	}
	if v := apiObject.ParquetTimestampInMillisecond; v != nil {
		tfMap["parquet_timestamp_in_millisecond"] = aws.ToBool(v)
	}
	tfMap["parquet_version"] = string(apiObject.ParquetVersion)
	if v := apiObject.Rfc4180; v != nil {
		tfMap["rfc_4180"] = aws.ToBool(v)
	}
	if v := apiObject.RowGroupLength; v != nil {
		tfMap["row_group_length"] = aws.ToInt32(v)
	}
	if v := apiObject.ServerSideEncryptionKmsKeyId; v != nil {
		tfMap["server_side_encryption_kms_key_id"] = aws.ToString(v)
	}
	if v := apiObject.ServiceAccessRoleArn; v != nil {
		tfMap["service_access_role_arn"] = aws.ToString(v)
	}
	if v := apiObject.TimestampColumnName; v != nil {
		tfMap["timestamp_column_name"] = aws.ToString(v)
	}
	if v := apiObject.UseCsvNoSupValue; v != nil {
		tfMap["use_csv_no_sup_value"] = aws.ToBool(v)
	}
	if v := apiObject.UseTaskStartTimeForFullLoadTimestamp; v != nil {
		tfMap["use_task_start_time_for_full_load_timestamp"] = aws.ToBool(v)
	}

	return []map[string]any{tfMap}
}
