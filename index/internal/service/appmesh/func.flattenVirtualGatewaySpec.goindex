package github.com/hashicorp/terraform-provider-aws/internal/service/appmesh
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/appmesh"
	awstypes "github.com/aws/aws-sdk-go-v2/service/appmesh/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func flattenVirtualGatewaySpec(spec *awstypes.VirtualGatewaySpec) []any {
	if spec == nil {
		return []any{}
	}

	mSpec := map[string]any{}

	if backendDefaults := spec.BackendDefaults; backendDefaults != nil {
		mBackendDefaults := map[string]any{
			"client_policy": flattenVirtualGatewayClientPolicy(backendDefaults.ClientPolicy),
		}

		mSpec["backend_defaults"] = []any{mBackendDefaults}
	}

	if len(spec.Listeners) > 0 {
		var mListeners []any
		for _, listener := range spec.Listeners {
			mListener := map[string]any{}

			if connectionPool := listener.ConnectionPool; connectionPool != nil {
				mConnectionPool := map[string]any{}

				switch v := connectionPool.(type) {
				case *awstypes.VirtualGatewayConnectionPoolMemberGrpc:
					mGrpcConnectionPool := map[string]any{
						"max_requests": aws.ToInt32(v.Value.MaxRequests),
					}
					mConnectionPool["grpc"] = []any{mGrpcConnectionPool}
				case *awstypes.VirtualGatewayConnectionPoolMemberHttp:
					mHttpConnectionPool := map[string]any{
						"max_connections":      aws.ToInt32(v.Value.MaxConnections),
						"max_pending_requests": aws.ToInt32(v.Value.MaxPendingRequests),
					}
					mConnectionPool["http"] = []any{mHttpConnectionPool}
				case *awstypes.VirtualGatewayConnectionPoolMemberHttp2:
					mHttp2ConnectionPool := map[string]any{
						"max_requests": aws.ToInt32(v.Value.MaxRequests),
					}
					mConnectionPool["http2"] = []any{mHttp2ConnectionPool}
				}

				mListener["connection_pool"] = []any{mConnectionPool}
			}

			if healthCheck := listener.HealthCheck; healthCheck != nil {
				mHealthCheck := map[string]any{
					"healthy_threshold":   aws.ToInt32(healthCheck.HealthyThreshold),
					"interval_millis":     aws.ToInt64(healthCheck.IntervalMillis),
					names.AttrPath:        aws.ToString(healthCheck.Path),
					names.AttrPort:        aws.ToInt32(healthCheck.Port),
					names.AttrProtocol:    healthCheck.Protocol,
					"timeout_millis":      aws.ToInt64(healthCheck.TimeoutMillis),
					"unhealthy_threshold": aws.ToInt32(healthCheck.UnhealthyThreshold),
				}
				mListener[names.AttrHealthCheck] = []any{mHealthCheck}
			}

			if portMapping := listener.PortMapping; portMapping != nil {
				mPortMapping := map[string]any{
					names.AttrPort:     aws.ToInt32(portMapping.Port),
					names.AttrProtocol: portMapping.Protocol,
				}
				mListener["port_mapping"] = []any{mPortMapping}
			}

			if tls := listener.Tls; tls != nil {
				mTls := map[string]any{
					names.AttrMode: tls.Mode,
				}

				if certificate := tls.Certificate; certificate != nil {
					mCertificate := map[string]any{}

					switch v := certificate.(type) {
					case *awstypes.VirtualGatewayListenerTlsCertificateMemberAcm:
						mAcm := map[string]any{
							names.AttrCertificateARN: aws.ToString(v.Value.CertificateArn),
						}

						mCertificate["acm"] = []any{mAcm}
					case *awstypes.VirtualGatewayListenerTlsCertificateMemberFile:
						mFile := map[string]any{
							names.AttrCertificateChain: aws.ToString(v.Value.CertificateChain),
							names.AttrPrivateKey:       aws.ToString(v.Value.PrivateKey),
						}

						mCertificate["file"] = []any{mFile}
					case *awstypes.VirtualGatewayListenerTlsCertificateMemberSds:
						mSds := map[string]any{
							"secret_name": aws.ToString(v.Value.SecretName),
						}

						mCertificate["sds"] = []any{mSds}
					}

					mTls[names.AttrCertificate] = []any{mCertificate}
				}

				if validation := tls.Validation; validation != nil {
					mValidation := map[string]any{}

					if subjectAlternativeNames := validation.SubjectAlternativeNames; subjectAlternativeNames != nil {
						mSubjectAlternativeNames := map[string]any{}

						if match := subjectAlternativeNames.Match; match != nil {
							mMatch := map[string]any{
								"exact": match.Exact,
							}

							mSubjectAlternativeNames["match"] = []any{mMatch}
						}

						mValidation["subject_alternative_names"] = []any{mSubjectAlternativeNames}
					}

					if trust := validation.Trust; trust != nil {
						mTrust := map[string]any{}

						switch v := trust.(type) {
						case *awstypes.VirtualGatewayListenerTlsValidationContextTrustMemberFile:
							mFile := map[string]any{
								names.AttrCertificateChain: aws.ToString(v.Value.CertificateChain),
							}

							mTrust["file"] = []any{mFile}
						case *awstypes.VirtualGatewayListenerTlsValidationContextTrustMemberSds:
							mSds := map[string]any{
								"secret_name": aws.ToString(v.Value.SecretName),
							}

							mTrust["sds"] = []any{mSds}
						}

						mValidation["trust"] = []any{mTrust}
					}

					mTls["validation"] = []any{mValidation}
				}

				mListener["tls"] = []any{mTls}
			}
			mListeners = append(mListeners, mListener)
		}
		mSpec["listener"] = mListeners
	}

	if logging := spec.Logging; logging != nil {
		mLogging := map[string]any{}

		if accessLog := logging.AccessLog; accessLog != nil {
			mAccessLog := map[string]any{}

			switch v := accessLog.(type) {
			case *awstypes.VirtualGatewayAccessLogMemberFile:
				mFile := map[string]any{}

				if format := v.Value.Format; format != nil {
					mFormat := map[string]any{}

					switch v := format.(type) {
					case *awstypes.LoggingFormatMemberJson:
						vJsons := []any{}

						for _, j := range v.Value {
							mJson := map[string]any{
								names.AttrKey:   aws.ToString(j.Key),
								names.AttrValue: aws.ToString(j.Value),
							}

							vJsons = append(vJsons, mJson)
						}

						mFormat[names.AttrJSON] = vJsons
					case *awstypes.LoggingFormatMemberText:
						mFormat["text"] = v.Value
					}

					mFile[names.AttrFormat] = []any{mFormat}
				}

				mFile[names.AttrPath] = aws.ToString(v.Value.Path)

				mAccessLog["file"] = []any{mFile}
			}

			mLogging["access_log"] = []any{mAccessLog}
		}

		mSpec["logging"] = []any{mLogging}
	}

	return []any{mSpec}
}
