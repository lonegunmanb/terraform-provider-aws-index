package github.com/hashicorp/terraform-provider-aws/internal/service/appmesh
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/appmesh"
	awstypes "github.com/aws/aws-sdk-go-v2/service/appmesh/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceGatewayRouteSpecSchema() *schema.Schema {
	// httpRouteSchema returns the schema for `http_route` and `http2_route` attributes.
	httpRouteSchema := func(attrName string) *schema.Schema {
		return &schema.Schema{
			Type:     schema.TypeList,
			Optional: true,
			MinItems: 0,
			MaxItems: 1,
			Elem: &schema.Resource{
				Schema: map[string]*schema.Schema{
					names.AttrAction: {
						Type:     schema.TypeList,
						Required: true,
						MinItems: 1,
						MaxItems: 1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								"rewrite": {
									Type:     schema.TypeList,
									Optional: true,
									MinItems: 1,
									MaxItems: 1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											"hostname": {
												Type:     schema.TypeList,
												Optional: true,
												MinItems: 1,
												MaxItems: 1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														"default_target_hostname": {
															Type:         schema.TypeString,
															Required:     true,
															ValidateFunc: validation.StringInSlice([]string{"ENABLED", "DISABLED"}, false),
														},
													},
												},
												AtLeastOneOf: []string{
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.hostname", attrName),
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.path", attrName),
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix", attrName),
												},
											},
											names.AttrPath: {
												Type:     schema.TypeList,
												Optional: true,
												MinItems: 1,
												MaxItems: 1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														"exact": {
															Type:         schema.TypeString,
															Required:     true,
															ValidateFunc: validation.StringLenBetween(1, 255),
														},
													},
												},
												AtLeastOneOf: []string{
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.hostname", attrName),
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.path", attrName),
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix", attrName),
												},
											},
											names.AttrPrefix: {
												Type:     schema.TypeList,
												Optional: true,
												MinItems: 1,
												MaxItems: 1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														"default_prefix": {
															Type:         schema.TypeString,
															Optional:     true,
															ValidateFunc: validation.StringInSlice([]string{"ENABLED", "DISABLED"}, false),
															ExactlyOneOf: []string{
																fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix.0.default_prefix", attrName),
																fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix.0.value", attrName),
															},
														},
														names.AttrValue: {
															Type:         schema.TypeString,
															Optional:     true,
															ValidateFunc: validation.StringMatch(regexache.MustCompile(`^/`), "must start with /"),
															ExactlyOneOf: []string{
																fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix.0.default_prefix", attrName),
																fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix.0.value", attrName),
															},
														},
													},
												},
												AtLeastOneOf: []string{
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.hostname", attrName),
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.path", attrName),
													fmt.Sprintf("spec.0.%s.0.action.0.rewrite.0.prefix", attrName),
												},
											},
										},
									},
								},
								names.AttrTarget: {
									Type:     schema.TypeList,
									Required: true,
									MinItems: 1,
									MaxItems: 1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											names.AttrPort: {
												Type:         schema.TypeInt,
												Optional:     true,
												ValidateFunc: validation.IsPortNumber,
											},
											"virtual_service": {
												Type:     schema.TypeList,
												Required: true,
												MinItems: 1,
												MaxItems: 1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														"virtual_service_name": {
															Type:         schema.TypeString,
															Required:     true,
															ValidateFunc: validation.StringLenBetween(1, 255),
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"match": {
						Type:     schema.TypeList,
						Required: true,
						MinItems: 1,
						MaxItems: 1,
						Elem: &schema.Resource{
							Schema: map[string]*schema.Schema{
								names.AttrHeader: {
									Type:     schema.TypeSet,
									Optional: true,
									MinItems: 0,
									MaxItems: 10,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											"invert": {
												Type:     schema.TypeBool,
												Optional: true,
												Default:  false,
											},
											"match": {
												Type:     schema.TypeList,
												Optional: true,
												MinItems: 0,
												MaxItems: 1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														"exact": {
															Type:         schema.TypeString,
															Optional:     true,
															ValidateFunc: validation.StringLenBetween(1, 255),
														},
														names.AttrPrefix: {
															Type:         schema.TypeString,
															Optional:     true,
															ValidateFunc: validation.StringLenBetween(1, 255),
														},
														"range": {
															Type:     schema.TypeList,
															Optional: true,
															MinItems: 0,
															MaxItems: 1,
															Elem: &schema.Resource{
																Schema: map[string]*schema.Schema{
																	"end": {
																		Type:     schema.TypeInt,
																		Required: true,
																	},
																	"start": {
																		Type:     schema.TypeInt,
																		Required: true,
																	},
																},
															},
														},
														"regex": {
															Type:         schema.TypeString,
															Optional:     true,
															ValidateFunc: validation.StringLenBetween(1, 255),
														},
														"suffix": {
															Type:         schema.TypeString,
															Optional:     true,
															ValidateFunc: validation.StringLenBetween(1, 255),
														},
													},
												},
											},
											names.AttrName: {
												Type:         schema.TypeString,
												Required:     true,
												ValidateFunc: validation.StringLenBetween(1, 50),
											},
										},
									},
								},
								"hostname": {
									Type:     schema.TypeList,
									Optional: true,
									MinItems: 1,
									MaxItems: 1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											"exact": {
												Type:     schema.TypeString,
												Optional: true,
												ExactlyOneOf: []string{
													fmt.Sprintf("spec.0.%s.0.match.0.hostname.0.exact", attrName),
													fmt.Sprintf("spec.0.%s.0.match.0.hostname.0.suffix", attrName),
												},
											},
											"suffix": {
												Type:     schema.TypeString,
												Optional: true,
												ExactlyOneOf: []string{
													fmt.Sprintf("spec.0.%s.0.match.0.hostname.0.exact", attrName),
													fmt.Sprintf("spec.0.%s.0.match.0.hostname.0.suffix", attrName),
												},
											},
										},
									},
									AtLeastOneOf: []string{
										fmt.Sprintf("spec.0.%s.0.match.0.hostname", attrName),
										fmt.Sprintf("spec.0.%s.0.match.0.path", attrName),
										fmt.Sprintf("spec.0.%s.0.match.0.prefix", attrName),
									},
								},
								names.AttrPath: {
									Type:     schema.TypeList,
									Optional: true,
									MinItems: 0,
									MaxItems: 1,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											"exact": {
												Type:         schema.TypeString,
												Optional:     true,
												ValidateFunc: validation.StringLenBetween(1, 255),
											},
											"regex": {
												Type:         schema.TypeString,
												Optional:     true,
												ValidateFunc: validation.StringLenBetween(1, 255),
											},
										},
									},
									AtLeastOneOf: []string{
										fmt.Sprintf("spec.0.%s.0.match.0.hostname", attrName),
										fmt.Sprintf("spec.0.%s.0.match.0.path", attrName),
										fmt.Sprintf("spec.0.%s.0.match.0.prefix", attrName),
									},
								},
								names.AttrPort: {
									Type:         schema.TypeInt,
									Optional:     true,
									ValidateFunc: validation.IsPortNumber,
								},
								names.AttrPrefix: {
									Type:         schema.TypeString,
									Optional:     true,
									ValidateFunc: validation.StringMatch(regexache.MustCompile(`^/`), "must start with /"),
									AtLeastOneOf: []string{
										fmt.Sprintf("spec.0.%s.0.match.0.hostname", attrName),
										fmt.Sprintf("spec.0.%s.0.match.0.path", attrName),
										fmt.Sprintf("spec.0.%s.0.match.0.prefix", attrName),
									},
								},
								"query_parameter": {
									Type:     schema.TypeSet,
									Optional: true,
									MinItems: 0,
									MaxItems: 10,
									Elem: &schema.Resource{
										Schema: map[string]*schema.Schema{
											"match": {
												Type:     schema.TypeList,
												Optional: true,
												MinItems: 0,
												MaxItems: 1,
												Elem: &schema.Resource{
													Schema: map[string]*schema.Schema{
														"exact": {
															Type:     schema.TypeString,
															Optional: true,
														},
													},
												},
											},
											names.AttrName: {
												Type:     schema.TypeString,
												Required: true,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			ExactlyOneOf: []string{
				"spec.0.grpc_route",
				"spec.0.http2_route",
				"spec.0.http_route",
			},
		}
	}

	return &schema.Schema{
		Type:     schema.TypeList,
		Required: true,
		MinItems: 1,
		MaxItems: 1,
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"grpc_route": {
					Type:     schema.TypeList,
					Optional: true,
					MinItems: 0,
					MaxItems: 1,
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							names.AttrAction: {
								Type:     schema.TypeList,
								Required: true,
								MinItems: 1,
								MaxItems: 1,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										names.AttrTarget: {
											Type:     schema.TypeList,
											Required: true,
											MinItems: 1,
											MaxItems: 1,
											Elem: &schema.Resource{
												Schema: map[string]*schema.Schema{
													names.AttrPort: {
														Type:         schema.TypeInt,
														Optional:     true,
														ValidateFunc: validation.IsPortNumber,
													},
													"virtual_service": {
														Type:     schema.TypeList,
														Required: true,
														MinItems: 1,
														MaxItems: 1,
														Elem: &schema.Resource{
															Schema: map[string]*schema.Schema{
																"virtual_service_name": {
																	Type:         schema.TypeString,
																	Required:     true,
																	ValidateFunc: validation.StringLenBetween(1, 255),
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"match": {
								Type:     schema.TypeList,
								Required: true,
								MinItems: 1,
								MaxItems: 1,
								Elem: &schema.Resource{
									Schema: map[string]*schema.Schema{
										names.AttrPort: {
											Type:         schema.TypeInt,
											Optional:     true,
											ValidateFunc: validation.IsPortNumber,
										},
										names.AttrServiceName: {
											Type:     schema.TypeString,
											Required: true,
										},
									},
								},
							},
						},
					},
					ExactlyOneOf: []string{
						"spec.0.grpc_route",
						"spec.0.http2_route",
						"spec.0.http_route",
					},
				},
				"http_route":  httpRouteSchema("http_route"),
				"http2_route": httpRouteSchema("http2_route"),
				names.AttrPriority: {
					Type:         schema.TypeInt,
					Optional:     true,
					ValidateFunc: validation.IntBetween(0, 1000),
				},
			},
		},
	}
}
