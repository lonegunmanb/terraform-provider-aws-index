package github.com/hashicorp/terraform-provider-aws/internal/service/appmesh
import (
	"github.com/aws/aws-sdk-go-v2/aws"
	awstypes "github.com/aws/aws-sdk-go-v2/service/appmesh/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func expandVirtualNodeSpec(vSpec []any) *awstypes.VirtualNodeSpec {
	spec := &awstypes.VirtualNodeSpec{}

	if len(vSpec) == 0 || vSpec[0] == nil {
		// Empty Spec is allowed.
		return spec
	}
	mSpec := vSpec[0].(map[string]any)

	if vBackends, ok := mSpec["backend"].(*schema.Set); ok && vBackends.Len() > 0 {
		backends := []awstypes.Backend{}

		for _, vBackend := range vBackends.List() {
			backend := &awstypes.BackendMemberVirtualService{}
			mBackend := vBackend.(map[string]any)

			if vVirtualService, ok := mBackend["virtual_service"].([]any); ok && len(vVirtualService) > 0 && vVirtualService[0] != nil {
				virtualService := awstypes.VirtualServiceBackend{}

				mVirtualService := vVirtualService[0].(map[string]any)

				if vVirtualServiceName, ok := mVirtualService["virtual_service_name"].(string); ok {
					virtualService.VirtualServiceName = aws.String(vVirtualServiceName)
				}

				if vClientPolicy, ok := mVirtualService["client_policy"].([]any); ok {
					virtualService.ClientPolicy = expandClientPolicy(vClientPolicy)
				}

				backend.Value = virtualService
				backends = append(backends, backend)
			}
		}

		spec.Backends = backends
	}

	if vBackendDefaults, ok := mSpec["backend_defaults"].([]any); ok && len(vBackendDefaults) > 0 && vBackendDefaults[0] != nil {
		backendDefaults := &awstypes.BackendDefaults{}

		mBackendDefaults := vBackendDefaults[0].(map[string]any)

		if vClientPolicy, ok := mBackendDefaults["client_policy"].([]any); ok {
			backendDefaults.ClientPolicy = expandClientPolicy(vClientPolicy)
		}

		spec.BackendDefaults = backendDefaults
	}

	if vListeners, ok := mSpec["listener"].([]any); ok && len(vListeners) > 0 && vListeners[0] != nil {
		listeners := []awstypes.Listener{}

		for _, vListener := range vListeners {
			listener := awstypes.Listener{}

			mListener := vListener.(map[string]any)

			if vConnectionPool, ok := mListener["connection_pool"].([]any); ok && len(vConnectionPool) > 0 && vConnectionPool[0] != nil {
				mConnectionPool := vConnectionPool[0].(map[string]any)

				if vGrpcConnectionPool, ok := mConnectionPool["grpc"].([]any); ok && len(vGrpcConnectionPool) > 0 && vGrpcConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualNodeConnectionPoolMemberGrpc{}

					mGrpcConnectionPool := vGrpcConnectionPool[0].(map[string]any)

					grpcConnectionPool := awstypes.VirtualNodeGrpcConnectionPool{}

					if vMaxRequests, ok := mGrpcConnectionPool["max_requests"].(int); ok && vMaxRequests > 0 {
						grpcConnectionPool.MaxRequests = aws.Int32(int32(vMaxRequests))
					}

					connectionPool.Value = grpcConnectionPool
					listener.ConnectionPool = connectionPool
				}

				if vHttpConnectionPool, ok := mConnectionPool["http"].([]any); ok && len(vHttpConnectionPool) > 0 && vHttpConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualNodeConnectionPoolMemberHttp{}

					mHttpConnectionPool := vHttpConnectionPool[0].(map[string]any)

					httpConnectionPool := awstypes.VirtualNodeHttpConnectionPool{}

					if vMaxConnections, ok := mHttpConnectionPool["max_connections"].(int); ok && vMaxConnections > 0 {
						httpConnectionPool.MaxConnections = aws.Int32(int32(vMaxConnections))
					}
					if vMaxPendingRequests, ok := mHttpConnectionPool["max_pending_requests"].(int); ok && vMaxPendingRequests > 0 {
						httpConnectionPool.MaxPendingRequests = aws.Int32(int32(vMaxPendingRequests))
					}

					connectionPool.Value = httpConnectionPool
					listener.ConnectionPool = connectionPool
				}

				if vHttp2ConnectionPool, ok := mConnectionPool["http2"].([]any); ok && len(vHttp2ConnectionPool) > 0 && vHttp2ConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualNodeConnectionPoolMemberHttp2{}

					mHttp2ConnectionPool := vHttp2ConnectionPool[0].(map[string]any)

					http2ConnectionPool := awstypes.VirtualNodeHttp2ConnectionPool{}

					if vMaxRequests, ok := mHttp2ConnectionPool["max_requests"].(int); ok && vMaxRequests > 0 {
						http2ConnectionPool.MaxRequests = aws.Int32(int32(vMaxRequests))
					}

					connectionPool.Value = http2ConnectionPool
					listener.ConnectionPool = connectionPool
				}

				if vTcpConnectionPool, ok := mConnectionPool["tcp"].([]any); ok && len(vTcpConnectionPool) > 0 && vTcpConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualNodeConnectionPoolMemberTcp{}

					mTcpConnectionPool := vTcpConnectionPool[0].(map[string]any)

					tcpConnectionPool := awstypes.VirtualNodeTcpConnectionPool{}

					if vMaxConnections, ok := mTcpConnectionPool["max_connections"].(int); ok && vMaxConnections > 0 {
						tcpConnectionPool.MaxConnections = aws.Int32(int32(vMaxConnections))
					}

					connectionPool.Value = tcpConnectionPool
					listener.ConnectionPool = connectionPool
				}
			}

			if vHealthCheck, ok := mListener[names.AttrHealthCheck].([]any); ok && len(vHealthCheck) > 0 && vHealthCheck[0] != nil {
				healthCheck := &awstypes.HealthCheckPolicy{}

				mHealthCheck := vHealthCheck[0].(map[string]any)

				if vHealthyThreshold, ok := mHealthCheck["healthy_threshold"].(int); ok && vHealthyThreshold > 0 {
					healthCheck.HealthyThreshold = aws.Int32(int32(vHealthyThreshold))
				}
				if vIntervalMillis, ok := mHealthCheck["interval_millis"].(int); ok && vIntervalMillis > 0 {
					healthCheck.IntervalMillis = aws.Int64(int64(vIntervalMillis))
				}
				if vPath, ok := mHealthCheck[names.AttrPath].(string); ok && vPath != "" {
					healthCheck.Path = aws.String(vPath)
				}
				if vPort, ok := mHealthCheck[names.AttrPort].(int); ok && vPort > 0 {
					healthCheck.Port = aws.Int32(int32(vPort))
				}
				if vProtocol, ok := mHealthCheck[names.AttrProtocol].(string); ok && vProtocol != "" {
					healthCheck.Protocol = awstypes.PortProtocol(vProtocol)
				}
				if vTimeoutMillis, ok := mHealthCheck["timeout_millis"].(int); ok && vTimeoutMillis > 0 {
					healthCheck.TimeoutMillis = aws.Int64(int64(vTimeoutMillis))
				}
				if vUnhealthyThreshold, ok := mHealthCheck["unhealthy_threshold"].(int); ok && vUnhealthyThreshold > 0 {
					healthCheck.UnhealthyThreshold = aws.Int32(int32(vUnhealthyThreshold))
				}

				listener.HealthCheck = healthCheck
			}

			if vOutlierDetection, ok := mListener["outlier_detection"].([]any); ok && len(vOutlierDetection) > 0 && vOutlierDetection[0] != nil {
				outlierDetection := &awstypes.OutlierDetection{}

				mOutlierDetection := vOutlierDetection[0].(map[string]any)

				if vMaxEjectionPercent, ok := mOutlierDetection["max_ejection_percent"].(int); ok && vMaxEjectionPercent > 0 {
					outlierDetection.MaxEjectionPercent = aws.Int32(int32(vMaxEjectionPercent))
				}
				if vMaxServerErrors, ok := mOutlierDetection["max_server_errors"].(int); ok && vMaxServerErrors > 0 {
					outlierDetection.MaxServerErrors = aws.Int64(int64(vMaxServerErrors))
				}

				if vBaseEjectionDuration, ok := mOutlierDetection["base_ejection_duration"].([]any); ok {
					outlierDetection.BaseEjectionDuration = expandDuration(vBaseEjectionDuration)
				}

				if vInterval, ok := mOutlierDetection[names.AttrInterval].([]any); ok {
					outlierDetection.Interval = expandDuration(vInterval)
				}

				listener.OutlierDetection = outlierDetection
			}

			if vPortMapping, ok := mListener["port_mapping"].([]any); ok && len(vPortMapping) > 0 && vPortMapping[0] != nil {
				portMapping := &awstypes.PortMapping{}

				mPortMapping := vPortMapping[0].(map[string]any)

				if vPort, ok := mPortMapping[names.AttrPort].(int); ok && vPort > 0 {
					portMapping.Port = aws.Int32(int32(vPort))
				}
				if vProtocol, ok := mPortMapping[names.AttrProtocol].(string); ok && vProtocol != "" {
					portMapping.Protocol = awstypes.PortProtocol(vProtocol)
				}

				listener.PortMapping = portMapping
			}

			if vTimeout, ok := mListener[names.AttrTimeout].([]any); ok && len(vTimeout) > 0 && vTimeout[0] != nil {
				mTimeout := vTimeout[0].(map[string]any)

				if vGrpcTimeout, ok := mTimeout["grpc"].([]any); ok && len(vGrpcTimeout) > 0 && vGrpcTimeout[0] != nil {
					listener.Timeout = &awstypes.ListenerTimeoutMemberGrpc{Value: *expandGRPCTimeout(vGrpcTimeout)}
				}

				if vHttpTimeout, ok := mTimeout["http"].([]any); ok && len(vHttpTimeout) > 0 && vHttpTimeout[0] != nil {
					listener.Timeout = &awstypes.ListenerTimeoutMemberHttp{Value: *expandHTTPTimeout(vHttpTimeout)}
				}

				if vHttp2Timeout, ok := mTimeout["http2"].([]any); ok && len(vHttp2Timeout) > 0 && vHttp2Timeout[0] != nil {
					listener.Timeout = &awstypes.ListenerTimeoutMemberHttp2{Value: *expandHTTPTimeout(vHttp2Timeout)}
				}

				if vTcpTimeout, ok := mTimeout["tcp"].([]any); ok && len(vTcpTimeout) > 0 && vTcpTimeout[0] != nil {
					listener.Timeout = &awstypes.ListenerTimeoutMemberTcp{Value: *expandTCPTimeout(vTcpTimeout)}
				}
			}

			if vTls, ok := mListener["tls"].([]any); ok && len(vTls) > 0 && vTls[0] != nil {
				tls := &awstypes.ListenerTls{}

				mTls := vTls[0].(map[string]any)

				if vMode, ok := mTls[names.AttrMode].(string); ok && vMode != "" {
					tls.Mode = awstypes.ListenerTlsMode(vMode)
				}

				if vCertificate, ok := mTls[names.AttrCertificate].([]any); ok && len(vCertificate) > 0 && vCertificate[0] != nil {
					mCertificate := vCertificate[0].(map[string]any)

					if vAcm, ok := mCertificate["acm"].([]any); ok && len(vAcm) > 0 && vAcm[0] != nil {
						certificate := &awstypes.ListenerTlsCertificateMemberAcm{}
						acm := awstypes.ListenerTlsAcmCertificate{}

						mAcm := vAcm[0].(map[string]any)

						if vCertificateArn, ok := mAcm[names.AttrCertificateARN].(string); ok && vCertificateArn != "" {
							acm.CertificateArn = aws.String(vCertificateArn)
						}

						certificate.Value = acm
						tls.Certificate = certificate
					}

					if vFile, ok := mCertificate["file"].([]any); ok && len(vFile) > 0 && vFile[0] != nil {
						certificate := &awstypes.ListenerTlsCertificateMemberFile{}

						file := awstypes.ListenerTlsFileCertificate{}

						mFile := vFile[0].(map[string]any)

						if vCertificateChain, ok := mFile[names.AttrCertificateChain].(string); ok && vCertificateChain != "" {
							file.CertificateChain = aws.String(vCertificateChain)
						}
						if vPrivateKey, ok := mFile[names.AttrPrivateKey].(string); ok && vPrivateKey != "" {
							file.PrivateKey = aws.String(vPrivateKey)
						}

						certificate.Value = file
						tls.Certificate = certificate
					}

					if vSds, ok := mCertificate["sds"].([]any); ok && len(vSds) > 0 && vSds[0] != nil {
						certificate := &awstypes.ListenerTlsCertificateMemberSds{}

						sds := awstypes.ListenerTlsSdsCertificate{}

						mSds := vSds[0].(map[string]any)

						if vSecretName, ok := mSds["secret_name"].(string); ok && vSecretName != "" {
							sds.SecretName = aws.String(vSecretName)
						}

						certificate.Value = sds
						tls.Certificate = certificate
					}
				}

				if vValidation, ok := mTls["validation"].([]any); ok && len(vValidation) > 0 && vValidation[0] != nil {
					validation := &awstypes.ListenerTlsValidationContext{}

					mValidation := vValidation[0].(map[string]any)

					if vSubjectAlternativeNames, ok := mValidation["subject_alternative_names"].([]any); ok && len(vSubjectAlternativeNames) > 0 && vSubjectAlternativeNames[0] != nil {
						subjectAlternativeNames := &awstypes.SubjectAlternativeNames{}

						mSubjectAlternativeNames := vSubjectAlternativeNames[0].(map[string]any)

						if vMatch, ok := mSubjectAlternativeNames["match"].([]any); ok && len(vMatch) > 0 && vMatch[0] != nil {
							match := &awstypes.SubjectAlternativeNameMatchers{}

							mMatch := vMatch[0].(map[string]any)

							if vExact, ok := mMatch["exact"].(*schema.Set); ok && vExact.Len() > 0 {
								match.Exact = flex.ExpandStringValueSet(vExact)
							}

							subjectAlternativeNames.Match = match
						}

						validation.SubjectAlternativeNames = subjectAlternativeNames
					}

					if vTrust, ok := mValidation["trust"].([]any); ok && len(vTrust) > 0 && vTrust[0] != nil {
						mTrust := vTrust[0].(map[string]any)

						if vFile, ok := mTrust["file"].([]any); ok && len(vFile) > 0 && vFile[0] != nil {
							trust := &awstypes.ListenerTlsValidationContextTrustMemberFile{}

							file := awstypes.TlsValidationContextFileTrust{}

							mFile := vFile[0].(map[string]any)

							if vCertificateChain, ok := mFile[names.AttrCertificateChain].(string); ok && vCertificateChain != "" {
								file.CertificateChain = aws.String(vCertificateChain)
							}

							trust.Value = file
							validation.Trust = trust
						}

						if vSds, ok := mTrust["sds"].([]any); ok && len(vSds) > 0 && vSds[0] != nil {
							trust := &awstypes.ListenerTlsValidationContextTrustMemberSds{}

							sds := awstypes.TlsValidationContextSdsTrust{}

							mSds := vSds[0].(map[string]any)

							if vSecretName, ok := mSds["secret_name"].(string); ok && vSecretName != "" {
								sds.SecretName = aws.String(vSecretName)
							}

							trust.Value = sds
							validation.Trust = trust
						}
					}

					tls.Validation = validation
				}

				listener.Tls = tls
			}

			listeners = append(listeners, listener)
		}

		spec.Listeners = listeners
	}

	if vLogging, ok := mSpec["logging"].([]any); ok && len(vLogging) > 0 && vLogging[0] != nil {
		logging := &awstypes.Logging{}

		mLogging := vLogging[0].(map[string]any)

		if vAccessLog, ok := mLogging["access_log"].([]any); ok && len(vAccessLog) > 0 && vAccessLog[0] != nil {
			mAccessLog := vAccessLog[0].(map[string]any)

			if vFile, ok := mAccessLog["file"].([]any); ok && len(vFile) > 0 && vFile[0] != nil {
				accessLog := &awstypes.AccessLogMemberFile{}

				file := awstypes.FileAccessLog{}

				mFile := vFile[0].(map[string]any)

				if vFormat, ok := mFile[names.AttrFormat].([]any); ok && len(vFormat) > 0 && vFormat[0] != nil {
					mFormat := vFormat[0].(map[string]any)

					if vJsonFormatRefs, ok := mFormat[names.AttrJSON].([]any); ok && len(vJsonFormatRefs) > 0 {
						format := &awstypes.LoggingFormatMemberJson{}
						jsonFormatRefs := []awstypes.JsonFormatRef{}
						for _, vJsonFormatRef := range vJsonFormatRefs {
							mJsonFormatRef := awstypes.JsonFormatRef{
								Key:   aws.String(vJsonFormatRef.(map[string]any)[names.AttrKey].(string)),
								Value: aws.String(vJsonFormatRef.(map[string]any)[names.AttrValue].(string)),
							}
							jsonFormatRefs = append(jsonFormatRefs, mJsonFormatRef)
						}
						format.Value = jsonFormatRefs
						file.Format = format
					}

					if vText, ok := mFormat["text"].(string); ok && vText != "" {
						format := &awstypes.LoggingFormatMemberText{}
						format.Value = vText
						file.Format = format
					}

					logging.AccessLog = accessLog
				}

				if vPath, ok := mFile[names.AttrPath].(string); ok && vPath != "" {
					file.Path = aws.String(vPath)
				}

				accessLog.Value = file
				logging.AccessLog = accessLog
			}
		}

		spec.Logging = logging
	}

	if vServiceDiscovery, ok := mSpec["service_discovery"].([]any); ok && len(vServiceDiscovery) > 0 && vServiceDiscovery[0] != nil {
		mServiceDiscovery := vServiceDiscovery[0].(map[string]any)

		if vAwsCloudMap, ok := mServiceDiscovery["aws_cloud_map"].([]any); ok && len(vAwsCloudMap) > 0 && vAwsCloudMap[0] != nil {
			serviceDiscovery := &awstypes.ServiceDiscoveryMemberAwsCloudMap{}

			awsCloudMap := awstypes.AwsCloudMapServiceDiscovery{}

			mAwsCloudMap := vAwsCloudMap[0].(map[string]any)

			if vAttributes, ok := mAwsCloudMap[names.AttrAttributes].(map[string]any); ok && len(vAttributes) > 0 {
				attributes := []awstypes.AwsCloudMapInstanceAttribute{}

				for k, v := range vAttributes {
					attributes = append(attributes, awstypes.AwsCloudMapInstanceAttribute{
						Key:   aws.String(k),
						Value: aws.String(v.(string)),
					})
				}

				awsCloudMap.Attributes = attributes
			}
			if vNamespaceName, ok := mAwsCloudMap["namespace_name"].(string); ok && vNamespaceName != "" {
				awsCloudMap.NamespaceName = aws.String(vNamespaceName)
			}
			if vServiceName, ok := mAwsCloudMap[names.AttrServiceName].(string); ok && vServiceName != "" {
				awsCloudMap.ServiceName = aws.String(vServiceName)
			}

			serviceDiscovery.Value = awsCloudMap
			spec.ServiceDiscovery = serviceDiscovery
		}

		if vDns, ok := mServiceDiscovery["dns"].([]any); ok && len(vDns) > 0 && vDns[0] != nil {
			serviceDiscovery := &awstypes.ServiceDiscoveryMemberDns{}

			dns := awstypes.DnsServiceDiscovery{}

			mDns := vDns[0].(map[string]any)

			if vHostname, ok := mDns["hostname"].(string); ok && vHostname != "" {
				dns.Hostname = aws.String(vHostname)
			}

			if vIPPreference, ok := mDns["ip_preference"].(string); ok && vIPPreference != "" {
				dns.IpPreference = awstypes.IpPreference(vIPPreference)
			}

			if vResponseType, ok := mDns["response_type"].(string); ok && vResponseType != "" {
				dns.ResponseType = awstypes.DnsResponseType(vResponseType)
			}

			serviceDiscovery.Value = dns
			spec.ServiceDiscovery = serviceDiscovery
		}
	}

	return spec
}
