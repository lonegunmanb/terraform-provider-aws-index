package github.com/hashicorp/terraform-provider-aws/internal/service/appmesh
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/appmesh"
	awstypes "github.com/aws/aws-sdk-go-v2/service/appmesh/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func expandVirtualGatewaySpec(vSpec []any) *awstypes.VirtualGatewaySpec {
	if len(vSpec) == 0 || vSpec[0] == nil {
		return nil
	}

	spec := &awstypes.VirtualGatewaySpec{}

	mSpec := vSpec[0].(map[string]any)

	if vBackendDefaults, ok := mSpec["backend_defaults"].([]any); ok && len(vBackendDefaults) > 0 && vBackendDefaults[0] != nil {
		backendDefaults := &awstypes.VirtualGatewayBackendDefaults{}

		mBackendDefaults := vBackendDefaults[0].(map[string]any)

		if vClientPolicy, ok := mBackendDefaults["client_policy"].([]any); ok {
			backendDefaults.ClientPolicy = expandVirtualGatewayClientPolicy(vClientPolicy)
		}

		spec.BackendDefaults = backendDefaults
	}

	if vListeners, ok := mSpec["listener"].([]any); ok && len(vListeners) > 0 && vListeners[0] != nil {
		listeners := []awstypes.VirtualGatewayListener{}

		for _, vListener := range vListeners {
			listener := awstypes.VirtualGatewayListener{}

			mListener := vListener.(map[string]any)

			if vHealthCheck, ok := mListener[names.AttrHealthCheck].([]any); ok && len(vHealthCheck) > 0 && vHealthCheck[0] != nil {
				healthCheck := &awstypes.VirtualGatewayHealthCheckPolicy{}

				mHealthCheck := vHealthCheck[0].(map[string]any)

				if vHealthyThreshold, ok := mHealthCheck["healthy_threshold"].(int); ok && vHealthyThreshold > 0 {
					healthCheck.HealthyThreshold = aws.Int32(int32(vHealthyThreshold))
				}
				if vIntervalMillis, ok := mHealthCheck["interval_millis"].(int); ok && vIntervalMillis > 0 {
					healthCheck.IntervalMillis = aws.Int64(int64(vIntervalMillis))
				}
				if vPath, ok := mHealthCheck[names.AttrPath].(string); ok && vPath != "" {
					healthCheck.Path = aws.String(vPath)
				}
				if vPort, ok := mHealthCheck[names.AttrPort].(int); ok && vPort > 0 {
					healthCheck.Port = aws.Int32(int32(vPort))
				}
				if vProtocol, ok := mHealthCheck[names.AttrProtocol].(string); ok && vProtocol != "" {
					healthCheck.Protocol = awstypes.VirtualGatewayPortProtocol(vProtocol)
				}
				if vTimeoutMillis, ok := mHealthCheck["timeout_millis"].(int); ok && vTimeoutMillis > 0 {
					healthCheck.TimeoutMillis = aws.Int64(int64(vTimeoutMillis))
				}
				if vUnhealthyThreshold, ok := mHealthCheck["unhealthy_threshold"].(int); ok && vUnhealthyThreshold > 0 {
					healthCheck.UnhealthyThreshold = aws.Int32(int32(vUnhealthyThreshold))
				}

				listener.HealthCheck = healthCheck
			}

			if vConnectionPool, ok := mListener["connection_pool"].([]any); ok && len(vConnectionPool) > 0 && vConnectionPool[0] != nil {
				mConnectionPool := vConnectionPool[0].(map[string]any)

				if vGrpcConnectionPool, ok := mConnectionPool["grpc"].([]any); ok && len(vGrpcConnectionPool) > 0 && vGrpcConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualGatewayConnectionPoolMemberGrpc{}
					mGrpcConnectionPool := vGrpcConnectionPool[0].(map[string]any)

					grpcConnectionPool := awstypes.VirtualGatewayGrpcConnectionPool{}

					if vMaxRequests, ok := mGrpcConnectionPool["max_requests"].(int); ok && vMaxRequests > 0 {
						grpcConnectionPool.MaxRequests = aws.Int32(int32(vMaxRequests))
					}

					connectionPool.Value = grpcConnectionPool
					listener.ConnectionPool = connectionPool
				}

				if vHttpConnectionPool, ok := mConnectionPool["http"].([]any); ok && len(vHttpConnectionPool) > 0 && vHttpConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualGatewayConnectionPoolMemberHttp{}
					mHttpConnectionPool := vHttpConnectionPool[0].(map[string]any)

					httpConnectionPool := awstypes.VirtualGatewayHttpConnectionPool{}

					if vMaxConnections, ok := mHttpConnectionPool["max_connections"].(int); ok && vMaxConnections > 0 {
						httpConnectionPool.MaxConnections = aws.Int32(int32(vMaxConnections))
					}
					if vMaxPendingRequests, ok := mHttpConnectionPool["max_pending_requests"].(int); ok && vMaxPendingRequests > 0 {
						httpConnectionPool.MaxPendingRequests = aws.Int32(int32(vMaxPendingRequests))
					}

					connectionPool.Value = httpConnectionPool
					listener.ConnectionPool = connectionPool
				}

				if vHttp2ConnectionPool, ok := mConnectionPool["http2"].([]any); ok && len(vHttp2ConnectionPool) > 0 && vHttp2ConnectionPool[0] != nil {
					connectionPool := &awstypes.VirtualGatewayConnectionPoolMemberHttp2{}
					mHttp2ConnectionPool := vHttp2ConnectionPool[0].(map[string]any)

					http2ConnectionPool := awstypes.VirtualGatewayHttp2ConnectionPool{}

					if vMaxRequests, ok := mHttp2ConnectionPool["max_requests"].(int); ok && vMaxRequests > 0 {
						http2ConnectionPool.MaxRequests = aws.Int32(int32(vMaxRequests))
					}

					connectionPool.Value = http2ConnectionPool
					listener.ConnectionPool = connectionPool
				}
			}

			if vPortMapping, ok := mListener["port_mapping"].([]any); ok && len(vPortMapping) > 0 && vPortMapping[0] != nil {
				portMapping := &awstypes.VirtualGatewayPortMapping{}

				mPortMapping := vPortMapping[0].(map[string]any)

				if vPort, ok := mPortMapping[names.AttrPort].(int); ok && vPort > 0 {
					portMapping.Port = aws.Int32(int32(vPort))
				}
				if vProtocol, ok := mPortMapping[names.AttrProtocol].(string); ok && vProtocol != "" {
					portMapping.Protocol = awstypes.VirtualGatewayPortProtocol(vProtocol)
				}

				listener.PortMapping = portMapping
			}

			if vTls, ok := mListener["tls"].([]any); ok && len(vTls) > 0 && vTls[0] != nil {
				tls := &awstypes.VirtualGatewayListenerTls{}

				mTls := vTls[0].(map[string]any)

				if vMode, ok := mTls[names.AttrMode].(string); ok && vMode != "" {
					tls.Mode = awstypes.VirtualGatewayListenerTlsMode(vMode)
				}

				if vCertificate, ok := mTls[names.AttrCertificate].([]any); ok && len(vCertificate) > 0 && vCertificate[0] != nil {
					mCertificate := vCertificate[0].(map[string]any)

					if vAcm, ok := mCertificate["acm"].([]any); ok && len(vAcm) > 0 && vAcm[0] != nil {
						certificate := &awstypes.VirtualGatewayListenerTlsCertificateMemberAcm{}
						acm := awstypes.VirtualGatewayListenerTlsAcmCertificate{}

						mAcm := vAcm[0].(map[string]any)

						if vCertificateArn, ok := mAcm[names.AttrCertificateARN].(string); ok && vCertificateArn != "" {
							acm.CertificateArn = aws.String(vCertificateArn)
						}

						certificate.Value = acm
						tls.Certificate = certificate
					}

					if vFile, ok := mCertificate["file"].([]any); ok && len(vFile) > 0 && vFile[0] != nil {
						certificate := &awstypes.VirtualGatewayListenerTlsCertificateMemberFile{}
						file := awstypes.VirtualGatewayListenerTlsFileCertificate{}

						mFile := vFile[0].(map[string]any)

						if vCertificateChain, ok := mFile[names.AttrCertificateChain].(string); ok && vCertificateChain != "" {
							file.CertificateChain = aws.String(vCertificateChain)
						}
						if vPrivateKey, ok := mFile[names.AttrPrivateKey].(string); ok && vPrivateKey != "" {
							file.PrivateKey = aws.String(vPrivateKey)
						}

						certificate.Value = file
						tls.Certificate = certificate
					}

					if vSds, ok := mCertificate["sds"].([]any); ok && len(vSds) > 0 && vSds[0] != nil {
						certificate := &awstypes.VirtualGatewayListenerTlsCertificateMemberSds{}
						sds := awstypes.VirtualGatewayListenerTlsSdsCertificate{}

						mSds := vSds[0].(map[string]any)

						if vSecretName, ok := mSds["secret_name"].(string); ok && vSecretName != "" {
							sds.SecretName = aws.String(vSecretName)
						}

						certificate.Value = sds
						tls.Certificate = certificate
					}
				}

				if vValidation, ok := mTls["validation"].([]any); ok && len(vValidation) > 0 && vValidation[0] != nil {
					validation := &awstypes.VirtualGatewayListenerTlsValidationContext{}

					mValidation := vValidation[0].(map[string]any)

					if vSubjectAlternativeNames, ok := mValidation["subject_alternative_names"].([]any); ok && len(vSubjectAlternativeNames) > 0 && vSubjectAlternativeNames[0] != nil {
						subjectAlternativeNames := &awstypes.SubjectAlternativeNames{}

						mSubjectAlternativeNames := vSubjectAlternativeNames[0].(map[string]any)

						if vMatch, ok := mSubjectAlternativeNames["match"].([]any); ok && len(vMatch) > 0 && vMatch[0] != nil {
							match := &awstypes.SubjectAlternativeNameMatchers{}

							mMatch := vMatch[0].(map[string]any)

							if vExact, ok := mMatch["exact"].(*schema.Set); ok && vExact.Len() > 0 {
								match.Exact = flex.ExpandStringValueSet(vExact)
							}

							subjectAlternativeNames.Match = match
						}

						validation.SubjectAlternativeNames = subjectAlternativeNames
					}

					if vTrust, ok := mValidation["trust"].([]any); ok && len(vTrust) > 0 && vTrust[0] != nil {
						mTrust := vTrust[0].(map[string]any)

						if vFile, ok := mTrust["file"].([]any); ok && len(vFile) > 0 && vFile[0] != nil {
							trust := &awstypes.VirtualGatewayListenerTlsValidationContextTrustMemberFile{}
							file := awstypes.VirtualGatewayTlsValidationContextFileTrust{}

							mFile := vFile[0].(map[string]any)

							if vCertificateChain, ok := mFile[names.AttrCertificateChain].(string); ok && vCertificateChain != "" {
								file.CertificateChain = aws.String(vCertificateChain)
							}

							trust.Value = file
							validation.Trust = trust
						}

						if vSds, ok := mTrust["sds"].([]any); ok && len(vSds) > 0 && vSds[0] != nil {
							trust := &awstypes.VirtualGatewayListenerTlsValidationContextTrustMemberSds{}
							sds := awstypes.VirtualGatewayTlsValidationContextSdsTrust{}

							mSds := vSds[0].(map[string]any)

							if vSecretName, ok := mSds["secret_name"].(string); ok && vSecretName != "" {
								sds.SecretName = aws.String(vSecretName)
							}

							trust.Value = sds
							validation.Trust = trust
						}
					}

					tls.Validation = validation
				}

				listener.Tls = tls
			}

			listeners = append(listeners, listener)
		}

		spec.Listeners = listeners
	}

	if vLogging, ok := mSpec["logging"].([]any); ok && len(vLogging) > 0 && vLogging[0] != nil {
		logging := &awstypes.VirtualGatewayLogging{}

		mLogging := vLogging[0].(map[string]any)

		if vAccessLog, ok := mLogging["access_log"].([]any); ok && len(vAccessLog) > 0 && vAccessLog[0] != nil {
			mAccessLog := vAccessLog[0].(map[string]any)

			if vFile, ok := mAccessLog["file"].([]any); ok && len(vFile) > 0 && vFile[0] != nil {
				accessLog := &awstypes.VirtualGatewayAccessLogMemberFile{}
				file := awstypes.VirtualGatewayFileAccessLog{}

				mFile := vFile[0].(map[string]any)

				if vFormat, ok := mFile[names.AttrFormat].([]any); ok && len(vFormat) > 0 && vFormat[0] != nil {
					mFormat := vFormat[0].(map[string]any)

					if vJsonFormatRefs, ok := mFormat[names.AttrJSON].([]any); ok && len(vJsonFormatRefs) > 0 {
						format := &awstypes.LoggingFormatMemberJson{}
						jsonFormatRefs := []awstypes.JsonFormatRef{}
						for _, vJsonFormatRef := range vJsonFormatRefs {
							mJsonFormatRef := awstypes.JsonFormatRef{
								Key:   aws.String(vJsonFormatRef.(map[string]any)[names.AttrKey].(string)),
								Value: aws.String(vJsonFormatRef.(map[string]any)[names.AttrValue].(string)),
							}
							jsonFormatRefs = append(jsonFormatRefs, mJsonFormatRef)
						}
						format.Value = jsonFormatRefs
						file.Format = format
					}

					if vText, ok := mFormat["text"].(string); ok && vText != "" {
						format := &awstypes.LoggingFormatMemberText{}
						format.Value = vText
						file.Format = format
					}
				}

				if vPath, ok := mFile[names.AttrPath].(string); ok && vPath != "" {
					file.Path = aws.String(vPath)
				}

				accessLog.Value = file
				logging.AccessLog = accessLog
			}
		}

		spec.Logging = logging
	}

	return spec
}
