package github.com/hashicorp/terraform-provider-aws/internal/service/appmesh
import (
	"github.com/aws/aws-sdk-go-v2/aws"
	awstypes "github.com/aws/aws-sdk-go-v2/service/appmesh/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func expandHTTPRoute(vHttpRoute []any) *awstypes.HttpRoute {
	if len(vHttpRoute) == 0 || vHttpRoute[0] == nil {
		return nil
	}

	mHttpRoute := vHttpRoute[0].(map[string]any)

	httpRoute := &awstypes.HttpRoute{}

	if vHttpRouteAction, ok := mHttpRoute[names.AttrAction].([]any); ok && len(vHttpRouteAction) > 0 && vHttpRouteAction[0] != nil {
		mHttpRouteAction := vHttpRouteAction[0].(map[string]any)

		if vWeightedTargets, ok := mHttpRouteAction["weighted_target"].(*schema.Set); ok && vWeightedTargets.Len() > 0 {
			weightedTargets := []awstypes.WeightedTarget{}

			for _, vWeightedTarget := range vWeightedTargets.List() {
				weightedTarget := awstypes.WeightedTarget{}

				mWeightedTarget := vWeightedTarget.(map[string]any)

				if vPort, ok := mWeightedTarget[names.AttrPort].(int); ok && vPort > 0 {
					weightedTarget.Port = aws.Int32(int32(vPort))
				}
				if vVirtualNode, ok := mWeightedTarget["virtual_node"].(string); ok && vVirtualNode != "" {
					weightedTarget.VirtualNode = aws.String(vVirtualNode)
				}
				if vWeight, ok := mWeightedTarget[names.AttrWeight].(int); ok {
					weightedTarget.Weight = int32(vWeight)
				}

				weightedTargets = append(weightedTargets, weightedTarget)
			}

			httpRoute.Action = &awstypes.HttpRouteAction{
				WeightedTargets: weightedTargets,
			}
		}
	}

	if vHttpRouteMatch, ok := mHttpRoute["match"].([]any); ok && len(vHttpRouteMatch) > 0 && vHttpRouteMatch[0] != nil {
		httpRouteMatch := &awstypes.HttpRouteMatch{}

		mHttpRouteMatch := vHttpRouteMatch[0].(map[string]any)

		if vMethod, ok := mHttpRouteMatch["method"].(string); ok && vMethod != "" {
			httpRouteMatch.Method = awstypes.HttpMethod(vMethod)
		}
		if vPort, ok := mHttpRouteMatch[names.AttrPort].(int); ok && vPort > 0 {
			httpRouteMatch.Port = aws.Int32(int32(vPort))
		}
		if vPrefix, ok := mHttpRouteMatch[names.AttrPrefix].(string); ok && vPrefix != "" {
			httpRouteMatch.Prefix = aws.String(vPrefix)
		}
		if vScheme, ok := mHttpRouteMatch["scheme"].(string); ok && vScheme != "" {
			httpRouteMatch.Scheme = awstypes.HttpScheme(vScheme)
		}

		if vHttpRouteHeaders, ok := mHttpRouteMatch[names.AttrHeader].(*schema.Set); ok && vHttpRouteHeaders.Len() > 0 {
			httpRouteHeaders := []awstypes.HttpRouteHeader{}

			for _, vHttpRouteHeader := range vHttpRouteHeaders.List() {
				httpRouteHeader := awstypes.HttpRouteHeader{}

				mHttpRouteHeader := vHttpRouteHeader.(map[string]any)

				if vInvert, ok := mHttpRouteHeader["invert"].(bool); ok {
					httpRouteHeader.Invert = aws.Bool(vInvert)
				}
				if vName, ok := mHttpRouteHeader[names.AttrName].(string); ok && vName != "" {
					httpRouteHeader.Name = aws.String(vName)
				}

				if vMatch, ok := mHttpRouteHeader["match"].([]any); ok && len(vMatch) > 0 && vMatch[0] != nil {
					mMatch := vMatch[0].(map[string]any)

					if vExact, ok := mMatch["exact"].(string); ok && vExact != "" {
						httpRouteHeader.Match = &awstypes.HeaderMatchMethodMemberExact{Value: vExact}
					}
					if vPrefix, ok := mMatch[names.AttrPrefix].(string); ok && vPrefix != "" {
						httpRouteHeader.Match = &awstypes.HeaderMatchMethodMemberPrefix{Value: vPrefix}
					}
					if vRegex, ok := mMatch["regex"].(string); ok && vRegex != "" {
						httpRouteHeader.Match = &awstypes.HeaderMatchMethodMemberRegex{Value: vRegex}
					}
					if vSuffix, ok := mMatch["suffix"].(string); ok && vSuffix != "" {
						httpRouteHeader.Match = &awstypes.HeaderMatchMethodMemberSuffix{Value: vSuffix}
					}

					if vRange, ok := mMatch["range"].([]any); ok && len(vRange) > 0 && vRange[0] != nil {
						memberRange := &awstypes.HeaderMatchMethodMemberRange{}

						mRange := vRange[0].(map[string]any)

						if vEnd, ok := mRange["end"].(int); ok && vEnd > 0 {
							memberRange.Value.End = aws.Int64(int64(vEnd))
						}
						if vStart, ok := mRange["start"].(int); ok && vStart > 0 {
							memberRange.Value.Start = aws.Int64(int64(vStart))
						}

						httpRouteHeader.Match = memberRange
					}
				}

				httpRouteHeaders = append(httpRouteHeaders, httpRouteHeader)
			}

			httpRouteMatch.Headers = httpRouteHeaders
		}

		if vHttpRoutePath, ok := mHttpRouteMatch[names.AttrPath].([]any); ok && len(vHttpRoutePath) > 0 && vHttpRoutePath[0] != nil {
			httpRoutePath := &awstypes.HttpPathMatch{}

			mHttpRoutePath := vHttpRoutePath[0].(map[string]any)

			if vExact, ok := mHttpRoutePath["exact"].(string); ok && vExact != "" {
				httpRoutePath.Exact = aws.String(vExact)
			}
			if vRegex, ok := mHttpRoutePath["regex"].(string); ok && vRegex != "" {
				httpRoutePath.Regex = aws.String(vRegex)
			}

			httpRouteMatch.Path = httpRoutePath
		}

		if vHttpRouteQueryParameters, ok := mHttpRouteMatch["query_parameter"].(*schema.Set); ok && vHttpRouteQueryParameters.Len() > 0 {
			httpRouteQueryParameters := []awstypes.HttpQueryParameter{}

			for _, vHttpRouteQueryParameter := range vHttpRouteQueryParameters.List() {
				httpRouteQueryParameter := awstypes.HttpQueryParameter{}

				mHttpRouteQueryParameter := vHttpRouteQueryParameter.(map[string]any)

				if vName, ok := mHttpRouteQueryParameter[names.AttrName].(string); ok && vName != "" {
					httpRouteQueryParameter.Name = aws.String(vName)
				}

				if vMatch, ok := mHttpRouteQueryParameter["match"].([]any); ok && len(vMatch) > 0 && vMatch[0] != nil {
					httpRouteQueryParameter.Match = &awstypes.QueryParameterMatch{}

					mMatch := vMatch[0].(map[string]any)

					if vExact, ok := mMatch["exact"].(string); ok && vExact != "" {
						httpRouteQueryParameter.Match.Exact = aws.String(vExact)
					}
				}

				httpRouteQueryParameters = append(httpRouteQueryParameters, httpRouteQueryParameter)
			}

			httpRouteMatch.QueryParameters = httpRouteQueryParameters
		}

		httpRoute.Match = httpRouteMatch
	}

	if vHttpRetryPolicy, ok := mHttpRoute["retry_policy"].([]any); ok && len(vHttpRetryPolicy) > 0 && vHttpRetryPolicy[0] != nil {
		httpRetryPolicy := &awstypes.HttpRetryPolicy{}

		mHttpRetryPolicy := vHttpRetryPolicy[0].(map[string]any)

		if vMaxRetries, ok := mHttpRetryPolicy["max_retries"].(int); ok {
			httpRetryPolicy.MaxRetries = aws.Int64(int64(vMaxRetries))
		}

		if vHttpRetryEvents, ok := mHttpRetryPolicy["http_retry_events"].(*schema.Set); ok && vHttpRetryEvents.Len() > 0 {
			httpRetryPolicy.HttpRetryEvents = flex.ExpandStringValueSet(vHttpRetryEvents)
		}

		if vPerRetryTimeout, ok := mHttpRetryPolicy["per_retry_timeout"].([]any); ok {
			httpRetryPolicy.PerRetryTimeout = expandDuration(vPerRetryTimeout)
		}

		if vTcpRetryEvents, ok := mHttpRetryPolicy["tcp_retry_events"].(*schema.Set); ok && vTcpRetryEvents.Len() > 0 {
			httpRetryPolicy.TcpRetryEvents = flex.ExpandStringyValueSet[awstypes.TcpRetryPolicyEvent](vTcpRetryEvents)
		}

		httpRoute.RetryPolicy = httpRetryPolicy
	}

	if vHttpTimeout, ok := mHttpRoute[names.AttrTimeout].([]any); ok {
		httpRoute.Timeout = expandHTTPTimeout(vHttpTimeout)
	}

	return httpRoute
}
