package github.com/hashicorp/terraform-provider-aws/internal/service/ses
import (
	"context"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ses"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ses/types"
	"github.com/hashicorp/terraform-plugin-framework/action"
	"github.com/hashicorp/terraform-plugin-framework/action/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (a *sendEmailAction) Invoke(ctx context.Context, req action.InvokeRequest, resp *action.InvokeResponse) {
	var config sendEmailActionModel

	resp.Diagnostics.Append(req.Config.Get(ctx, &config)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Validate that at least one body type is provided
	if config.TextBody.IsNull() && config.HtmlBody.IsNull() {
		resp.Diagnostics.AddError(
			"Missing Email Body",
			"Either text_body or html_body must be specified",
		)
		return
	}

	conn := a.Meta().SESClient(ctx)

	source := config.Source.ValueString()
	subject := config.Subject.ValueString()

	tflog.Info(ctx, "Starting SES send email action", map[string]any{
		names.AttrSource: source,
		"subject":        subject,
		"has_text_body":  !config.TextBody.IsNull(),
		"has_html_body":  !config.HtmlBody.IsNull(),
	})

	resp.SendProgress(action.InvokeProgressEvent{
		Message: fmt.Sprintf("Sending email from %s...", source),
	})

	// Build destination
	destination := &awstypes.Destination{}
	if !config.ToAddresses.IsNull() {
		destination.ToAddresses = fwflex.ExpandFrameworkStringValueList(ctx, config.ToAddresses)
	}
	if !config.CcAddresses.IsNull() {
		destination.CcAddresses = fwflex.ExpandFrameworkStringValueList(ctx, config.CcAddresses)
	}
	if !config.BccAddresses.IsNull() {
		destination.BccAddresses = fwflex.ExpandFrameworkStringValueList(ctx, config.BccAddresses)
	}

	// Build message
	message := &awstypes.Message{
		Subject: &awstypes.Content{
			Data: aws.String(subject),
		},
		Body: &awstypes.Body{},
	}

	if !config.TextBody.IsNull() {
		message.Body.Text = &awstypes.Content{
			Data: config.TextBody.ValueStringPointer(),
		}
	}
	if !config.HtmlBody.IsNull() {
		message.Body.Html = &awstypes.Content{
			Data: config.HtmlBody.ValueStringPointer(),
		}
	}

	// Build input
	input := &ses.SendEmailInput{
		Source:      aws.String(source),
		Destination: destination,
		Message:     message,
	}

	if !config.ReplyToAddresses.IsNull() {
		input.ReplyToAddresses = fwflex.ExpandFrameworkStringValueList(ctx, config.ReplyToAddresses)
	}

	if !config.ReturnPath.IsNull() {
		input.ReturnPath = config.ReturnPath.ValueStringPointer()
	}

	// Send email
	output, err := conn.SendEmail(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Send Email",
			fmt.Sprintf("Could not send email from %s: %s", source, err),
		)
		return
	}

	messageId := aws.ToString(output.MessageId)
	resp.SendProgress(action.InvokeProgressEvent{
		Message: fmt.Sprintf("Email sent successfully (Message ID: %s)", messageId),
	})

	tflog.Info(ctx, "SES send email action completed successfully", map[string]any{
		names.AttrSource: source,
		"message_id":     messageId,
	})
}
