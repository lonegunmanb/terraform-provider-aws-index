package github.com/hashicorp/terraform-provider-aws/internal/service/kinesisanalyticsv2
import (
	"context"
	"errors"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/kinesisanalyticsv2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/kinesisanalyticsv2/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func flattenApplicationConfigurationDescription(applicationConfigurationDescription *awstypes.ApplicationConfigurationDescription) []any {
	if applicationConfigurationDescription == nil {
		return []any{}
	}

	mApplicationConfiguration := map[string]any{}

	if applicationCodeConfigurationDescription := applicationConfigurationDescription.ApplicationCodeConfigurationDescription; applicationCodeConfigurationDescription != nil {
		mApplicationCodeConfiguration := map[string]any{
			"code_content_type": applicationCodeConfigurationDescription.CodeContentType,
		}

		if codeContentDescription := applicationCodeConfigurationDescription.CodeContentDescription; codeContentDescription != nil {
			mCodeContent := map[string]any{
				"text_content": aws.ToString(codeContentDescription.TextContent),
			}

			if s3ApplicationCodeLocationDescription := codeContentDescription.S3ApplicationCodeLocationDescription; s3ApplicationCodeLocationDescription != nil {
				mS3ContentLocation := map[string]any{
					"bucket_arn":     aws.ToString(s3ApplicationCodeLocationDescription.BucketARN),
					"file_key":       aws.ToString(s3ApplicationCodeLocationDescription.FileKey),
					"object_version": aws.ToString(s3ApplicationCodeLocationDescription.ObjectVersion),
				}

				mCodeContent["s3_content_location"] = []any{mS3ContentLocation}
			}

			mApplicationCodeConfiguration["code_content"] = []any{mCodeContent}
		}

		mApplicationConfiguration["application_code_configuration"] = []any{mApplicationCodeConfiguration}
	}

	if applicationSnapshotConfigurationDescription := applicationConfigurationDescription.ApplicationSnapshotConfigurationDescription; applicationSnapshotConfigurationDescription != nil {
		mApplicationSnapshotConfiguration := map[string]any{
			"snapshots_enabled": aws.ToBool(applicationSnapshotConfigurationDescription.SnapshotsEnabled),
		}

		mApplicationConfiguration["application_snapshot_configuration"] = []any{mApplicationSnapshotConfiguration}
	}

	if environmentPropertyDescriptions := applicationConfigurationDescription.EnvironmentPropertyDescriptions; environmentPropertyDescriptions != nil && len(environmentPropertyDescriptions.PropertyGroupDescriptions) > 0 {
		mEnvironmentProperties := map[string]any{}

		vPropertyGroups := []any{}

		for _, propertyGroup := range environmentPropertyDescriptions.PropertyGroupDescriptions {
			mPropertyGroup := map[string]any{
				"property_group_id": aws.ToString(propertyGroup.PropertyGroupId),
				"property_map":      flex.FlattenStringValueMap(propertyGroup.PropertyMap),
			}

			vPropertyGroups = append(vPropertyGroups, mPropertyGroup)
		}

		mEnvironmentProperties["property_group"] = vPropertyGroups

		mApplicationConfiguration["environment_properties"] = []any{mEnvironmentProperties}
	}

	if flinkApplicationConfigurationDescription := applicationConfigurationDescription.FlinkApplicationConfigurationDescription; flinkApplicationConfigurationDescription != nil {
		mFlinkApplicationConfiguration := map[string]any{}

		if checkpointConfigurationDescription := flinkApplicationConfigurationDescription.CheckpointConfigurationDescription; checkpointConfigurationDescription != nil {
			mCheckpointConfiguration := map[string]any{
				"checkpointing_enabled":         aws.ToBool(checkpointConfigurationDescription.CheckpointingEnabled),
				"checkpoint_interval":           aws.ToInt64(checkpointConfigurationDescription.CheckpointInterval),
				"configuration_type":            checkpointConfigurationDescription.ConfigurationType,
				"min_pause_between_checkpoints": aws.ToInt64(checkpointConfigurationDescription.MinPauseBetweenCheckpoints),
			}

			mFlinkApplicationConfiguration["checkpoint_configuration"] = []any{mCheckpointConfiguration}
		}

		if monitoringConfigurationDescription := flinkApplicationConfigurationDescription.MonitoringConfigurationDescription; monitoringConfigurationDescription != nil {
			mMonitoringConfiguration := map[string]any{
				"configuration_type": monitoringConfigurationDescription.ConfigurationType,
				"log_level":          monitoringConfigurationDescription.LogLevel,
				"metrics_level":      monitoringConfigurationDescription.MetricsLevel,
			}

			mFlinkApplicationConfiguration["monitoring_configuration"] = []any{mMonitoringConfiguration}
		}

		if parallelismConfigurationDescription := flinkApplicationConfigurationDescription.ParallelismConfigurationDescription; parallelismConfigurationDescription != nil {
			mParallelismConfiguration := map[string]any{
				"auto_scaling_enabled": aws.ToBool(parallelismConfigurationDescription.AutoScalingEnabled),
				"configuration_type":   parallelismConfigurationDescription.ConfigurationType,
				"parallelism":          aws.ToInt32(parallelismConfigurationDescription.Parallelism),
				"parallelism_per_kpu":  aws.ToInt32(parallelismConfigurationDescription.ParallelismPerKPU),
			}

			mFlinkApplicationConfiguration["parallelism_configuration"] = []any{mParallelismConfiguration}
		}

		mApplicationConfiguration["flink_application_configuration"] = []any{mFlinkApplicationConfiguration}
	}

	if runConfigurationDescription := applicationConfigurationDescription.RunConfigurationDescription; runConfigurationDescription != nil {
		mRunConfiguration := map[string]any{}

		if applicationRestoreConfigurationDescription := runConfigurationDescription.ApplicationRestoreConfigurationDescription; applicationRestoreConfigurationDescription != nil {
			mApplicationRestoreConfiguration := map[string]any{
				"application_restore_type": applicationRestoreConfigurationDescription.ApplicationRestoreType,
				"snapshot_name":            aws.ToString(applicationRestoreConfigurationDescription.SnapshotName),
			}

			mRunConfiguration["application_restore_configuration"] = []any{mApplicationRestoreConfiguration}
		}

		if flinkRunConfigurationDescription := runConfigurationDescription.FlinkRunConfigurationDescription; flinkRunConfigurationDescription != nil {
			mFlinkRunConfiguration := map[string]any{
				"allow_non_restored_state": aws.ToBool(flinkRunConfigurationDescription.AllowNonRestoredState),
			}

			mRunConfiguration["flink_run_configuration"] = []any{mFlinkRunConfiguration}
		}

		mApplicationConfiguration["run_configuration"] = []any{mRunConfiguration}
	}

	if sqlApplicationConfigurationDescription := applicationConfigurationDescription.SqlApplicationConfigurationDescription; sqlApplicationConfigurationDescription != nil {
		mSqlApplicationConfiguration := map[string]any{}

		if inputDescriptions := sqlApplicationConfigurationDescription.InputDescriptions; len(inputDescriptions) > 0 {
			inputDescription := inputDescriptions[0]

			mInput := map[string]any{
				"in_app_stream_names": inputDescription.InAppStreamNames,
				"input_id":            aws.ToString(inputDescription.InputId),
				names.AttrNamePrefix:  aws.ToString(inputDescription.NamePrefix),
			}

			if inputParallelism := inputDescription.InputParallelism; inputParallelism != nil {
				mInputParallelism := map[string]any{
					"count": aws.ToInt32(inputParallelism.Count),
				}

				mInput["input_parallelism"] = []any{mInputParallelism}
			}

			if inputSchema := inputDescription.InputSchema; inputSchema != nil {
				mInput["input_schema"] = flattenSourceSchema(inputSchema)
			}

			if inputProcessingConfigurationDescription := inputDescription.InputProcessingConfigurationDescription; inputProcessingConfigurationDescription != nil {
				mInputProcessingConfiguration := map[string]any{}

				if inputLambdaProcessorDescription := inputProcessingConfigurationDescription.InputLambdaProcessorDescription; inputLambdaProcessorDescription != nil {
					mInputLambdaProcessor := map[string]any{
						names.AttrResourceARN: aws.ToString(inputLambdaProcessorDescription.ResourceARN),
					}

					mInputProcessingConfiguration["input_lambda_processor"] = []any{mInputLambdaProcessor}
				}

				mInput["input_processing_configuration"] = []any{mInputProcessingConfiguration}
			}

			if inputStartingPositionConfiguration := inputDescription.InputStartingPositionConfiguration; inputStartingPositionConfiguration != nil {
				mInputStartingPositionConfiguration := map[string]any{
					"input_starting_position": inputStartingPositionConfiguration.InputStartingPosition,
				}

				mInput["input_starting_position_configuration"] = []any{mInputStartingPositionConfiguration}
			}

			if kinesisFirehoseInputDescription := inputDescription.KinesisFirehoseInputDescription; kinesisFirehoseInputDescription != nil {
				mKinesisFirehoseInput := map[string]any{
					names.AttrResourceARN: aws.ToString(kinesisFirehoseInputDescription.ResourceARN),
				}

				mInput["kinesis_firehose_input"] = []any{mKinesisFirehoseInput}
			}

			if kinesisStreamsInputDescription := inputDescription.KinesisStreamsInputDescription; kinesisStreamsInputDescription != nil {
				mKinesisStreamsInput := map[string]any{
					names.AttrResourceARN: aws.ToString(kinesisStreamsInputDescription.ResourceARN),
				}

				mInput["kinesis_streams_input"] = []any{mKinesisStreamsInput}
			}

			mSqlApplicationConfiguration["input"] = []any{mInput}
		}

		if outputDescriptions := sqlApplicationConfigurationDescription.OutputDescriptions; len(outputDescriptions) > 0 {
			vOutputs := []any{}

			for _, outputDescription := range outputDescriptions {
				mOutput := map[string]any{
					names.AttrName: aws.ToString(outputDescription.Name),
					"output_id":    aws.ToString(outputDescription.OutputId),
				}

				if destinationSchema := outputDescription.DestinationSchema; destinationSchema != nil {
					mDestinationSchema := map[string]any{
						"record_format_type": destinationSchema.RecordFormatType,
					}

					mOutput["destination_schema"] = []any{mDestinationSchema}
				}

				if kinesisFirehoseOutputDescription := outputDescription.KinesisFirehoseOutputDescription; kinesisFirehoseOutputDescription != nil {
					mKinesisFirehoseOutput := map[string]any{
						names.AttrResourceARN: aws.ToString(kinesisFirehoseOutputDescription.ResourceARN),
					}

					mOutput["kinesis_firehose_output"] = []any{mKinesisFirehoseOutput}
				}

				if kinesisStreamsOutputDescription := outputDescription.KinesisStreamsOutputDescription; kinesisStreamsOutputDescription != nil {
					mKinesisStreamsOutput := map[string]any{
						names.AttrResourceARN: aws.ToString(kinesisStreamsOutputDescription.ResourceARN),
					}

					mOutput["kinesis_streams_output"] = []any{mKinesisStreamsOutput}
				}

				if lambdaOutputDescription := outputDescription.LambdaOutputDescription; lambdaOutputDescription != nil {
					mLambdaOutput := map[string]any{
						names.AttrResourceARN: aws.ToString(lambdaOutputDescription.ResourceARN),
					}

					mOutput["lambda_output"] = []any{mLambdaOutput}
				}

				vOutputs = append(vOutputs, mOutput)
			}

			mSqlApplicationConfiguration["output"] = vOutputs
		}

		if referenceDataSourceDescriptions := sqlApplicationConfigurationDescription.ReferenceDataSourceDescriptions; len(referenceDataSourceDescriptions) > 0 {
			referenceDataSourceDescription := referenceDataSourceDescriptions[0]

			mReferenceDataSource := map[string]any{
				"reference_id":      aws.ToString(referenceDataSourceDescription.ReferenceId),
				names.AttrTableName: aws.ToString(referenceDataSourceDescription.TableName),
			}

			if referenceSchema := referenceDataSourceDescription.ReferenceSchema; referenceSchema != nil {
				mReferenceDataSource["reference_schema"] = flattenSourceSchema(referenceSchema)
			}

			if s3ReferenceDataSource := referenceDataSourceDescription.S3ReferenceDataSourceDescription; s3ReferenceDataSource != nil {
				mS3ReferenceDataSource := map[string]any{
					"bucket_arn": aws.ToString(s3ReferenceDataSource.BucketARN),
					"file_key":   aws.ToString(s3ReferenceDataSource.FileKey),
				}

				mReferenceDataSource["s3_reference_data_source"] = []any{mS3ReferenceDataSource}
			}

			mSqlApplicationConfiguration["reference_data_source"] = []any{mReferenceDataSource}
		}

		mApplicationConfiguration["sql_application_configuration"] = []any{mSqlApplicationConfiguration}
	}

	if vpcConfigurationDescriptions := applicationConfigurationDescription.VpcConfigurationDescriptions; len(vpcConfigurationDescriptions) > 0 {
		vpcConfigurationDescription := vpcConfigurationDescriptions[0]

		mVpcConfiguration := map[string]any{
			names.AttrSecurityGroupIDs: vpcConfigurationDescription.SecurityGroupIds,
			names.AttrSubnetIDs:        vpcConfigurationDescription.SubnetIds,
			"vpc_configuration_id":     aws.ToString(vpcConfigurationDescription.VpcConfigurationId),
			names.AttrVPCID:            aws.ToString(vpcConfigurationDescription.VpcId),
		}

		mApplicationConfiguration[names.AttrVPCConfiguration] = []any{mVpcConfiguration}
	}

	return []any{mApplicationConfiguration}
}
