package github.com/hashicorp/terraform-provider-aws/internal/service/kinesisanalyticsv2
import (
	"context"
	"errors"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/kinesisanalyticsv2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/kinesisanalyticsv2/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceApplicationUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).KinesisAnalyticsV2Client(ctx)
	applicationName := d.Get(names.AttrName).(string)

	if d.HasChanges("application_configuration", "cloudwatch_logging_options", "runtime_environment", "service_execution_role") {
		currentApplicationVersionID := int64(d.Get("version_id").(int))
		updateApplication := false

		input := &kinesisanalyticsv2.UpdateApplicationInput{
			ApplicationName: aws.String(applicationName),
		}

		if d.HasChange("application_configuration") {
			applicationConfigurationUpdate := &awstypes.ApplicationConfigurationUpdate{}

			if d.HasChange("application_configuration.0.application_code_configuration") {
				applicationConfigurationUpdate.ApplicationCodeConfigurationUpdate = expandApplicationCodeConfigurationUpdate(d.Get("application_configuration.0.application_code_configuration").([]any))

				updateApplication = true
			}

			if d.HasChange("application_configuration.0.application_snapshot_configuration") {
				applicationConfigurationUpdate.ApplicationSnapshotConfigurationUpdate = expandApplicationSnapshotConfigurationUpdate(d.Get("application_configuration.0.application_snapshot_configuration").([]any))

				updateApplication = true
			}

			if d.HasChange("application_configuration.0.environment_properties") {
				applicationConfigurationUpdate.EnvironmentPropertyUpdates = expandEnvironmentPropertyUpdates(d.Get("application_configuration.0.environment_properties").([]any))

				updateApplication = true
			}

			if d.HasChange("application_configuration.0.flink_application_configuration") {
				applicationConfigurationUpdate.FlinkApplicationConfigurationUpdate = expandApplicationFlinkApplicationConfigurationUpdate(d.Get("application_configuration.0.flink_application_configuration").([]any))

				updateApplication = true
			}

			if d.HasChange("application_configuration.0.sql_application_configuration") {
				sqlApplicationConfigurationUpdate := &awstypes.SqlApplicationConfigurationUpdate{}

				if d.HasChange("application_configuration.0.sql_application_configuration.0.input") {
					o, n := d.GetChange("application_configuration.0.sql_application_configuration.0.input")

					if len(o.([]any)) == 0 {
						// Add new input.
						input := &kinesisanalyticsv2.AddApplicationInputInput{
							ApplicationName:             aws.String(applicationName),
							CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
							Input:                       expandInput(n.([]any)),
						}

						output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.AddApplicationInputOutput, error) {
							return conn.AddApplicationInput(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics v2 Application (%s) input: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
						}

						currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
					} else if len(n.([]any)) == 0 {
						// The existing input cannot be deleted.
						// This should be handled by the CustomizeDiff function above.
						return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics v2 Application (%s) input", d.Id())
					} else {
						// Update existing input.
						inputUpdate := expandInputUpdate(n.([]any))

						if d.HasChange("application_configuration.0.sql_application_configuration.0.input.0.input_processing_configuration") {
							o, n := d.GetChange("application_configuration.0.sql_application_configuration.0.input.0.input_processing_configuration")

							// Update of existing input processing configuration is handled via the updating of the existing input.

							if len(o.([]any)) == 0 {
								// Add new input processing configuration.
								input := &kinesisanalyticsv2.AddApplicationInputProcessingConfigurationInput{
									ApplicationName:              aws.String(applicationName),
									CurrentApplicationVersionId:  aws.Int64(currentApplicationVersionID),
									InputId:                      inputUpdate.InputId,
									InputProcessingConfiguration: expandInputProcessingConfiguration(n.([]any)),
								}

								output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.AddApplicationInputProcessingConfigurationOutput, error) {
									return conn.AddApplicationInputProcessingConfiguration(ctx, input)
								})

								if err != nil {
									return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics v2 Application (%s) input processing configuration: %s", d.Id(), err)
								}

								if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
									return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
								}

								currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
							} else if len(n.([]any)) == 0 {
								// Delete existing input processing configuration.
								input := &kinesisanalyticsv2.DeleteApplicationInputProcessingConfigurationInput{
									ApplicationName:             aws.String(applicationName),
									CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
									InputId:                     inputUpdate.InputId,
								}

								output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.DeleteApplicationInputProcessingConfigurationOutput, error) {
									return conn.DeleteApplicationInputProcessingConfiguration(ctx, input)
								})

								if err != nil {
									return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics v2 Application (%s) input processing configuration: %s", d.Id(), err)
								}

								if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
									return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
								}

								currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
							}
						}

						sqlApplicationConfigurationUpdate.InputUpdates = []awstypes.InputUpdate{inputUpdate}

						updateApplication = true
					}
				}

				if d.HasChange("application_configuration.0.sql_application_configuration.0.output") {
					o, n := d.GetChange("application_configuration.0.sql_application_configuration.0.output")
					os, ns := o.(*schema.Set), n.(*schema.Set)

					additions := []any{}
					deletions := []string{}

					// Additions.
					for _, vOutput := range ns.Difference(os).List() {
						if v, ok := vOutput.(map[string]any)["output_id"].(string); ok && v != "" {
							// Shouldn't be attempting to add an output with an ID.
							log.Printf("[WARN] Attempting to add invalid Kinesis Analytics v2 Application (%s) output: %#v", d.Id(), vOutput)
						} else {
							additions = append(additions, vOutput)
						}
					}

					// Deletions.
					for _, vOutput := range os.Difference(ns).List() {
						if v, ok := vOutput.(map[string]any)["output_id"].(string); ok && v != "" {
							deletions = append(deletions, v)
						} else {
							// Shouldn't be attempting to delete an output without an ID.
							log.Printf("[WARN] Attempting to delete invalid Kinesis Analytics v2 Application (%s) output: %#v", d.Id(), vOutput)
						}
					}

					// Delete existing outputs.
					for _, v := range deletions {
						input := &kinesisanalyticsv2.DeleteApplicationOutputInput{
							ApplicationName:             aws.String(applicationName),
							CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
							OutputId:                    aws.String(v),
						}

						output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.DeleteApplicationOutputOutput, error) {
							return conn.DeleteApplicationOutput(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics v2 Application (%s) output: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
						}

						currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
					}

					// Add new outputs.
					for _, v := range additions {
						input := &kinesisanalyticsv2.AddApplicationOutputInput{
							ApplicationName:             aws.String(applicationName),
							CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
							Output:                      expandOutput(v),
						}

						output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.AddApplicationOutputOutput, error) {
							return conn.AddApplicationOutput(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics v2 Application (%s) output: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
						}

						currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
					}
				}

				if d.HasChange("application_configuration.0.sql_application_configuration.0.reference_data_source") {
					o, n := d.GetChange("application_configuration.0.sql_application_configuration.0.reference_data_source")

					if len(o.([]any)) == 0 {
						// Add new reference data source.
						input := &kinesisanalyticsv2.AddApplicationReferenceDataSourceInput{
							ApplicationName:             aws.String(applicationName),
							CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
							ReferenceDataSource:         expandReferenceDataSource(n.([]any)),
						}

						output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.AddApplicationReferenceDataSourceOutput, error) {
							return conn.AddApplicationReferenceDataSource(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics v2 Application (%s) reference data source: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
						}

						currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
					} else if len(n.([]any)) == 0 {
						// Delete existing reference data source.
						mOldReferenceDataSource := o.([]any)[0].(map[string]any)

						input := &kinesisanalyticsv2.DeleteApplicationReferenceDataSourceInput{
							ApplicationName:             aws.String(applicationName),
							CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
							ReferenceId:                 aws.String(mOldReferenceDataSource["reference_id"].(string)),
						}

						output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.DeleteApplicationReferenceDataSourceOutput, error) {
							return conn.DeleteApplicationReferenceDataSource(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics v2 Application (%s) reference data source: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
						}

						currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
					} else {
						// Update existing reference data source.
						referenceDataSourceUpdate := expandReferenceDataSourceUpdate(n.([]any))

						sqlApplicationConfigurationUpdate.ReferenceDataSourceUpdates = []awstypes.ReferenceDataSourceUpdate{referenceDataSourceUpdate}

						updateApplication = true
					}
				}

				applicationConfigurationUpdate.SqlApplicationConfigurationUpdate = sqlApplicationConfigurationUpdate
			}

			if d.HasChange("application_configuration.0.vpc_configuration") {
				o, n := d.GetChange("application_configuration.0.vpc_configuration")

				if len(o.([]any)) == 0 {
					// Add new VPC configuration.
					input := &kinesisanalyticsv2.AddApplicationVpcConfigurationInput{
						ApplicationName:             aws.String(applicationName),
						CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
						VpcConfiguration:            expandVPCConfiguration(n.([]any)),
					}

					output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.AddApplicationVpcConfigurationOutput, error) {
						return conn.AddApplicationVpcConfiguration(ctx, input)
					})

					if err != nil {
						return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics v2 Application (%s) VPC configuration: %s", d.Id(), err)
					}

					if operationID := aws.ToString(output.OperationId); operationID != "" {
						if _, err := waitApplicationOperationSucceeded(ctx, conn, applicationName, operationID, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) operation (%s) success: %s", applicationName, operationID, err)
						}
					}

					if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
						return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
					}

					currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
				} else if len(n.([]any)) == 0 {
					// Delete existing VPC configuration.
					mOldVpcConfiguration := o.([]any)[0].(map[string]any)

					input := &kinesisanalyticsv2.DeleteApplicationVpcConfigurationInput{
						ApplicationName:             aws.String(applicationName),
						CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
						VpcConfigurationId:          aws.String(mOldVpcConfiguration["vpc_configuration_id"].(string)),
					}

					output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.DeleteApplicationVpcConfigurationOutput, error) {
						return conn.DeleteApplicationVpcConfiguration(ctx, input)
					})

					if err != nil {
						return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics v2 Application (%s) VPC configuration: %s", d.Id(), err)
					}

					if operationID := aws.ToString(output.OperationId); operationID != "" {
						if _, err := waitApplicationOperationSucceeded(ctx, conn, applicationName, operationID, d.Timeout(schema.TimeoutUpdate)); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) operation (%s) success: %s", applicationName, operationID, err)
						}
					}

					if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
						return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
					}

					currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
				} else {
					// Update existing VPC configuration.
					vpcConfigurationUpdate := expandVPCConfigurationUpdate(n.([]any))

					applicationConfigurationUpdate.VpcConfigurationUpdates = []awstypes.VpcConfigurationUpdate{vpcConfigurationUpdate}

					updateApplication = true
				}
			}

			if d.HasChange("application_configuration.0.run_configuration") {
				application, err := findApplicationDetailByName(ctx, conn, applicationName)

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "reading Kinesis Analytics v2 Application (%s): %s", applicationName, err)
				}

				if actual, expected := application.ApplicationStatus, awstypes.ApplicationStatusRunning; actual == expected {
					input.RunConfigurationUpdate = expandRunConfigurationUpdate(d.Get("application_configuration.0.run_configuration").([]any))

					updateApplication = true
				}
			}

			input.ApplicationConfigurationUpdate = applicationConfigurationUpdate
		}

		if d.HasChange("cloudwatch_logging_options") {
			o, n := d.GetChange("cloudwatch_logging_options")

			if len(o.([]any)) == 0 {
				// Add new CloudWatch logging options.
				mNewCloudWatchLoggingOption := n.([]any)[0].(map[string]any)

				input := &kinesisanalyticsv2.AddApplicationCloudWatchLoggingOptionInput{
					ApplicationName: aws.String(applicationName),
					CloudWatchLoggingOption: &awstypes.CloudWatchLoggingOption{
						LogStreamARN: aws.String(mNewCloudWatchLoggingOption["log_stream_arn"].(string)),
					},
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
				}

				output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.AddApplicationCloudWatchLoggingOptionOutput, error) {
					return conn.AddApplicationCloudWatchLoggingOption(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics v2 Application (%s) CloudWatch logging option: %s", d.Id(), err)
				}

				if operationID := aws.ToString(output.OperationId); operationID != "" {
					if _, err := waitApplicationOperationSucceeded(ctx, conn, applicationName, operationID, d.Timeout(schema.TimeoutUpdate)); err != nil {
						return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) operation (%s) success: %s", applicationName, operationID, err)
					}
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
				}

				currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
			} else if len(n.([]any)) == 0 {
				// Delete existing CloudWatch logging options.
				mOldCloudWatchLoggingOption := o.([]any)[0].(map[string]any)

				input := &kinesisanalyticsv2.DeleteApplicationCloudWatchLoggingOptionInput{
					ApplicationName:             aws.String(applicationName),
					CloudWatchLoggingOptionId:   aws.String(mOldCloudWatchLoggingOption["cloudwatch_logging_option_id"].(string)),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
				}

				output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.DeleteApplicationCloudWatchLoggingOptionOutput, error) {
					return conn.DeleteApplicationCloudWatchLoggingOption(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics v2 Application (%s) CloudWatch logging option: %s", d.Id(), err)
				}

				if operationID := aws.ToString(output.OperationId); operationID != "" {
					if _, err := waitApplicationOperationSucceeded(ctx, conn, applicationName, operationID, d.Timeout(schema.TimeoutUpdate)); err != nil {
						return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) operation (%s) success: %s", applicationName, operationID, err)
					}
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
				}

				currentApplicationVersionID = aws.ToInt64(output.ApplicationVersionId)
			} else {
				// Update existing CloudWatch logging options.
				mOldCloudWatchLoggingOption := o.([]any)[0].(map[string]any)
				mNewCloudWatchLoggingOption := n.([]any)[0].(map[string]any)

				input.CloudWatchLoggingOptionUpdates = []awstypes.CloudWatchLoggingOptionUpdate{
					{
						CloudWatchLoggingOptionId: aws.String(mOldCloudWatchLoggingOption["cloudwatch_logging_option_id"].(string)),
						LogStreamARNUpdate:        aws.String(mNewCloudWatchLoggingOption["log_stream_arn"].(string)),
					},
				}

				updateApplication = true
			}
		}

		if d.HasChange("service_execution_role") {
			input.ServiceExecutionRoleUpdate = aws.String(d.Get("service_execution_role").(string))

			updateApplication = true
		}

		if d.HasChange("runtime_environment") {
			input.RuntimeEnvironmentUpdate = awstypes.RuntimeEnvironment(d.Get("runtime_environment").(string))

			updateApplication = true
		}

		if updateApplication {
			input.CurrentApplicationVersionId = aws.Int64(currentApplicationVersionID)

			output, err := waitIAMPropagation(ctx, func() (*kinesisanalyticsv2.UpdateApplicationOutput, error) {
				return conn.UpdateApplication(ctx, input)
			})

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating Kinesis Analytics v2 Application (%s): %s", d.Id(), err)
			}

			if operationID := aws.ToString(output.OperationId); operationID != "" {
				if _, err := waitApplicationOperationSucceeded(ctx, conn, applicationName, operationID, d.Timeout(schema.TimeoutUpdate)); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) operation (%s) success: %s", applicationName, operationID, err)
				}
			}

			if _, err := waitApplicationUpdated(ctx, conn, applicationName, d.Timeout(schema.TimeoutUpdate)); err != nil {
				return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics v2 Application (%s) to update: %s", d.Id(), err)
			}
		}
	}

	if d.HasChange("start_application") {
		if _, ok := d.GetOk("start_application"); ok {
			if err := startApplication(ctx, conn, expandStartApplicationInput(d), d.Timeout(schema.TimeoutUpdate)); err != nil {
				return sdkdiag.AppendFromErr(diags, err)
			}
		} else {
			if err := stopApplication(ctx, conn, expandStopApplicationInput(d), d.Timeout(schema.TimeoutUpdate)); err != nil {
				return sdkdiag.AppendFromErr(diags, err)
			}
		}
	}

	return append(diags, resourceApplicationRead(ctx, d, meta)...)
}
