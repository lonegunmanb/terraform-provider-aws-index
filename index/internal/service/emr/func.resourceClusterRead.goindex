package github.com/hashicorp/terraform-provider-aws/internal/service/emr
import (
	"bytes"
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"slices"
	"strings"
	"time"
	_ "unsafe" // Required for go:linkname

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/emr"
	awstypes "github.com/aws/aws-sdk-go-v2/service/emr/types"
	smithyjson "github.com/aws/smithy-go/encoding/json"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/structure"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tfjson "github.com/hashicorp/terraform-provider-aws/internal/json"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceClusterRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).EMRClient(ctx)

	cluster, err := findClusterByID(ctx, conn, d.Id())

	if !d.IsNewResource() && tfresource.NotFound(err) {
		log.Printf("[WARN] EMR Cluster (%s) not found, removing from state", d.Id())
		d.SetId("")
		return diags
	}

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "reading EMR Cluster (%s): %s", d.Id(), err)
	}

	d.Set("cluster_state", cluster.Status.State)
	d.Set(names.AttrARN, cluster.ClusterArn)

	instanceGroups, err := findInstanceGroupsByClusterID(ctx, conn, d.Id())

	if err == nil { // find instance group
		coreGroup, _ := coreInstanceGroup(instanceGroups)
		masterGroup, _ := masterInstanceGroup(instanceGroups)

		flattenedCoreInstanceGroup, err := flattenCoreInstanceGroup(coreGroup)
		if err != nil {
			return sdkdiag.AppendFromErr(diags, err)
		}

		if err := d.Set("core_instance_group", flattenedCoreInstanceGroup); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting core_instance_group: %s", err)
		}

		if err := d.Set("master_instance_group", flattenMasterInstanceGroup(masterGroup)); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting master_instance_group: %s", err)
		}
	}

	instanceFleets, err := findInstanceFleetsByClusterID(ctx, conn, d.Id())

	if err == nil { // find instance fleets
		coreFleet, _ := instanceFleetForRole(instanceFleets, awstypes.InstanceFleetTypeCore)
		masterFleet, _ := instanceFleetForRole(instanceFleets, awstypes.InstanceFleetTypeMaster)

		flattenedCoreInstanceFleet := flattenInstanceFleet(coreFleet)
		if err := d.Set("core_instance_fleet", flattenedCoreInstanceFleet); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting core_instance_fleet: %s", err)
		}

		flattenedMasterInstanceFleet := flattenInstanceFleet(masterFleet)
		if err := d.Set("master_instance_fleet", flattenedMasterInstanceFleet); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting master_instance_fleet: %s", err)
		}
	}

	setTagsOut(ctx, cluster.Tags)

	d.Set(names.AttrName, cluster.Name)

	d.Set(names.AttrServiceRole, cluster.ServiceRole)
	d.Set("security_configuration", cluster.SecurityConfiguration)
	d.Set("autoscaling_role", cluster.AutoScalingRole)
	d.Set("release_label", cluster.ReleaseLabel)
	d.Set("log_encryption_kms_key_id", cluster.LogEncryptionKmsKeyId)
	d.Set("log_uri", cluster.LogUri)
	d.Set("master_public_dns", cluster.MasterPublicDnsName)
	d.Set("visible_to_all_users", cluster.VisibleToAllUsers)
	d.Set("ebs_root_volume_size", cluster.EbsRootVolumeSize)
	d.Set("scale_down_behavior", cluster.ScaleDownBehavior)
	d.Set("termination_protection", cluster.TerminationProtected)
	d.Set("unhealthy_node_replacement", cluster.UnhealthyNodeReplacement)
	d.Set("step_concurrency_level", cluster.StepConcurrencyLevel)

	d.Set("custom_ami_id", cluster.CustomAmiId)

	if err := d.Set("applications", flattenApplications(cluster.Applications)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting applications: %s", err)
	}

	if _, ok := d.GetOk("configurations_json"); ok {
		configOut, err := flattenConfigurationJSON(cluster.Configurations)
		if err != nil {
			return sdkdiag.AppendFromErr(diags, err)
		}
		if err := d.Set("configurations_json", configOut); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting configurations_json: %s", err)
		}
	}

	if err := d.Set("ec2_attributes", flattenEC2InstanceAttributes(cluster.Ec2InstanceAttributes)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting ec2_attributes: %s", err)
	}

	if err := d.Set("kerberos_attributes", flattenKerberosAttributes(d, cluster.KerberosAttributes)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting kerberos_attributes: %s", err)
	}

	bootstrapActions, err := findBootstrapActionsByClusterID(ctx, conn, d.Id())

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "reading EMR Cluster (%s) bootstrap actions: %s", d.Id(), err)
	}

	if err := d.Set("bootstrap_action", flattenBootstrapArguments(bootstrapActions)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting bootstrap_action: %s", err)
	}

	input := &emr.ListStepsInput{
		ClusterId: aws.String(d.Id()),
	}
	if v, ok := d.GetOk("list_steps_states"); ok && v.(*schema.Set).Len() > 0 {
		input.StepStates = flex.ExpandStringyValueSet[awstypes.StepState](v.(*schema.Set))
	}

	stepSummaries, err := findStepSummaries(ctx, conn, input)

	if err != nil {
		return sdkdiag.AppendErrorf(diags, "listing EMR Cluster (%s) step summaries: %s", d.Id(), err)
	}

	if err := d.Set("step", flattenStepSummaries(stepSummaries)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting step: %s", err)
	}

	// AWS provides no other way to read back the additional_info
	if v, ok := d.GetOk("additional_info"); ok {
		v, err := structure.NormalizeJsonString(v)
		if err != nil {
			return sdkdiag.AppendFromErr(diags, err)
		}
		d.Set("additional_info", v)
	}

	autoTerminationPolicy, err := findAutoTerminationPolicyByClusterID(ctx, conn, d.Id())
	switch {
	case tfresource.NotFound(err):
		d.Set("auto_termination_policy", nil)
	case err != nil:
		return sdkdiag.AppendErrorf(diags, "reading EMR Cluster (%s) auto-termination policy: %s", d.Id(), err)
	default:
		if err := d.Set("auto_termination_policy", flattenAutoTerminationPolicy(autoTerminationPolicy)); err != nil {
			return sdkdiag.AppendErrorf(diags, "setting auto_termination_policy: %s", err)
		}
	}

	if err := d.Set("placement_group_config", flattenPlacementGroupConfigs(cluster.PlacementGroups)); err != nil {
		return sdkdiag.AppendErrorf(diags, "setting placement_group_config: %s", err)
	}

	return diags
}
