package github.com/hashicorp/terraform-provider-aws/internal/service/iam
import (
	"context"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/iam"
	awstypes "github.com/aws/aws-sdk-go-v2/service/iam/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func dataSourcePrincipalPolicySimulationRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).IAMClient(ctx)

	setAsAWSStringSlice := func(raw any) []string {
		if raw.(*schema.Set).Len() == 0 {
			return nil
		}
		return flex.ExpandStringValueSet(raw.(*schema.Set))
	}

	input := &iam.SimulatePrincipalPolicyInput{
		ActionNames:                        setAsAWSStringSlice(d.Get("action_names")),
		PermissionsBoundaryPolicyInputList: setAsAWSStringSlice(d.Get("permissions_boundary_policies_json")),
		PolicyInputList:                    setAsAWSStringSlice(d.Get("additional_policies_json")),
		PolicySourceArn:                    aws.String(d.Get("policy_source_arn").(string)),
		ResourceArns:                       setAsAWSStringSlice(d.Get("resource_arns")),
	}

	for _, entryRaw := range d.Get("context").(*schema.Set).List() {
		entryRaw := entryRaw.(map[string]any)
		entry := awstypes.ContextEntry{
			ContextKeyName:   aws.String(entryRaw[names.AttrKey].(string)),
			ContextKeyType:   awstypes.ContextKeyTypeEnum(entryRaw[names.AttrType].(string)),
			ContextKeyValues: setAsAWSStringSlice(entryRaw[names.AttrValues]),
		}
		input.ContextEntries = append(input.ContextEntries, entry)
	}

	if v := d.Get("caller_arn").(string); v != "" {
		input.CallerArn = aws.String(v)
	}
	if v := d.Get("resource_handling_option").(string); v != "" {
		input.ResourceHandlingOption = aws.String(v)
	}
	if v := d.Get("resource_owner_account_id").(string); v != "" {
		input.ResourceOwner = aws.String(v)
	}
	if v := d.Get("resource_policy_json").(string); v != "" {
		input.ResourcePolicy = aws.String(v)
	}

	// We are going to keep fetching through potentially multiple pages of
	// results in order to return a complete result, so we'll ask the API
	// to return as much as possible in each request to minimize the
	// round-trips.
	input.MaxItems = aws.Int32(1000)

	var results []awstypes.EvaluationResult

	for { // Terminates below, once we see a result that does not set IsTruncated.
		output, err := conn.SimulatePrincipalPolicy(ctx, input)
		if err != nil {
			return sdkdiag.AppendErrorf(diags, "simulating IAM Principal Policy: %s", err)
		}

		results = append(results, output.EvaluationResults...)

		if !output.IsTruncated {
			break // All done!
		}

		// If we're making another request then we need to specify the marker
		// to get the next page of results.
		input.Marker = output.Marker
	}

	// While we build the result we'll also tally up the number of allowed
	// vs. denied decisions to use for our top-level "all_allowed" summary
	// result.
	allowedCount := 0
	deniedCount := 0

	rawResults := make([]any, len(results))
	for i, result := range results {
		rawResult := map[string]any{}
		rawResult["action_name"] = aws.ToString(result.EvalActionName)
		rawResult["decision"] = string(result.EvalDecision)
		allowed := string(result.EvalDecision) == "allowed"
		rawResult["allowed"] = allowed
		if allowed {
			allowedCount++
		} else {
			deniedCount++
		}
		if result.EvalResourceName != nil {
			rawResult[names.AttrResourceARN] = aws.ToString(result.EvalResourceName)
		}

		var missingContextKeys []string
		for _, mkk := range result.MissingContextValues {
			if mkk != "" {
				missingContextKeys = append(missingContextKeys, mkk)
			}
		}
		rawResult["missing_context_keys"] = missingContextKeys

		decisionDetails := make(map[string]string, len(result.EvalDecisionDetails))
		for k, pv := range result.EvalDecisionDetails {
			if pv != "" {
				decisionDetails[k] = string(pv)
			}
		}
		rawResult["decision_details"] = decisionDetails

		rawMatchedStmts := make([]any, len(result.MatchedStatements))
		for i, stmt := range result.MatchedStatements {
			rawStmt := map[string]any{
				"source_policy_id":   stmt.SourcePolicyId,
				"source_policy_type": stmt.SourcePolicyType,
			}
			rawMatchedStmts[i] = rawStmt
		}
		rawResult["matched_statements"] = rawMatchedStmts

		rawResults[i] = rawResult
	}
	d.Set("results", rawResults)

	// "all" are allowed only if there is at least one result and no other
	// results were denied. We require at least one allowed here just as
	// a safety-net against a confusing result from a degenerate request.
	d.Set("all_allowed", allowedCount > 0 && deniedCount == 0)

	d.SetId("-")

	return diags
}
