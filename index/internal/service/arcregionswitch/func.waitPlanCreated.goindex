package github.com/hashicorp/terraform-provider-aws/internal/service/arcregionswitch
import (
	"context"
	"errors"
	"slices"
	"time"

	"github.com/YakDriver/smarterr"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/arcregionswitch"
	awstypes "github.com/aws/aws-sdk-go-v2/service/arcregionswitch/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	fwdiag "github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	fwschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	"github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	fwvalidators "github.com/hashicorp/terraform-provider-aws/internal/framework/validators"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/smerr"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func waitPlanCreated(ctx context.Context, conn *arcregionswitch.Client, arn string, timeout time.Duration) (*awstypes.Plan, error) {
	stateConf := &retry.StateChangeConf{
		Pending: []string{},
		Target:  []string{"exists"},
		Refresh: statusPlan(ctx, conn, arn),
		Timeout: timeout,
	}

	outputRaw, err := stateConf.WaitForStateContext(ctx)
	if err != nil {
		return nil, smarterr.NewError(err)
	}

	plan, ok := outputRaw.(*awstypes.Plan)
	if !ok {
		return nil, nil // nosemgrep:ci.semgrep.smarterr.go-no-bare-return-err
	}

	// Check if plan has Route53HealthCheck steps
	hasRoute53HealthChecks := false
	expectedCount := 0
	for _, workflow := range plan.Workflows {
		for _, step := range workflow.Steps {
			if step.ExecutionBlockType == awstypes.ExecutionBlockTypeRoute53HealthCheck {
				hasRoute53HealthChecks = true
				expectedCount++
			}
		}
	}

	// If plan has Route53 health checks, wait for them to be allocated
	if hasRoute53HealthChecks {
		healthCheckConf := &retry.StateChangeConf{
			Pending: []string{"pending"},
			Target:  []string{"allocated"},
			Refresh: statusRoute53HealthChecks(ctx, conn, arn, expectedCount),
			Timeout: timeout,
		}

		_, err = healthCheckConf.WaitForStateContext(ctx)
		if err != nil {
			return nil, smarterr.NewError(err)
		}
	}

	return plan, nil
}
