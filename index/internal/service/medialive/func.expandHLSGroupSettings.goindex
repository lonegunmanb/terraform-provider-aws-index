package github.com/hashicorp/terraform-provider-aws/internal/service/medialive
import (
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/medialive/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func expandHLSGroupSettings(tfList []any) *types.HlsGroupSettings {
	if len(tfList) == 0 || tfList[0] == nil {
		return nil
	}

	m := tfList[0].(map[string]any)

	var out types.HlsGroupSettings
	if v, ok := m[names.AttrDestination].([]any); ok && len(v) > 0 {
		out.Destination = expandDestination(v)
	}
	if v, ok := m["ad_markers"].([]any); ok && len(v) > 0 {
		out.AdMarkers = expandHLSAdMarkers(v)
	}
	if v, ok := m["base_url_content"].(string); ok && v != "" {
		out.BaseUrlContent = aws.String(v)
	}
	if v, ok := m["base_url_content1"].(string); ok && v != "" {
		out.BaseUrlContent1 = aws.String(v)
	}
	if v, ok := m["base_url_manifest"].(string); ok && v != "" {
		out.BaseUrlManifest = aws.String(v)
	}
	if v, ok := m["base_url_manifest1"].(string); ok && v != "" {
		out.BaseUrlManifest1 = aws.String(v)
	}
	if v, ok := m["caption_language_mappings"].(*schema.Set); ok && v.Len() > 0 {
		out.CaptionLanguageMappings = expandHSLGroupSettingsCaptionLanguageMappings(v.List())
	}
	if v, ok := m["caption_language_setting"].(string); ok && v != "" {
		out.CaptionLanguageSetting = types.HlsCaptionLanguageSetting(v)
	}
	if v, ok := m["client_cache"].(string); ok && v != "" {
		out.ClientCache = types.HlsClientCache(v)
	}
	if v, ok := m["codec_specification"].(string); ok && v != "" {
		out.CodecSpecification = types.HlsCodecSpecification(v)
	}
	if v, ok := m["constant_iv"].(string); ok && v != "" {
		out.ConstantIv = aws.String(v)
	}
	if v, ok := m["directory_structure"].(string); ok && v != "" {
		out.DirectoryStructure = types.HlsDirectoryStructure(v)
	}
	if v, ok := m["discontinuity_tags"].(string); ok && v != "" {
		out.DiscontinuityTags = types.HlsDiscontinuityTags(v)
	}
	if v, ok := m["encryption_type"].(string); ok && v != "" {
		out.EncryptionType = types.HlsEncryptionType(v)
	}
	if v, ok := m["hls_cdn_settings"].([]any); ok && len(v) > 0 {
		out.HlsCdnSettings = expandHLSCDNSettings(v)
	}
	if v, ok := m["hls_id3_segment_tagging"].(string); ok && v != "" {
		out.HlsId3SegmentTagging = types.HlsId3SegmentTaggingState(v)
	}
	if v, ok := m["iframe_only_playlists"].(string); ok && v != "" {
		out.IFrameOnlyPlaylists = types.IFrameOnlyPlaylistType(v)
	}
	if v, ok := m["incomplete_segment_behavior"].(string); ok && v != "" {
		out.IncompleteSegmentBehavior = types.HlsIncompleteSegmentBehavior(v)
	}
	if v, ok := m["index_n_segments"].(int); ok && v != 0 {
		out.IndexNSegments = aws.Int32(int32(v))
	}
	if v, ok := m["input_loss_action"].(string); ok && v != "" {
		out.InputLossAction = types.InputLossActionForHlsOut(v)
	}
	if v, ok := m["iv_in_manifest"].(string); ok && v != "" {
		out.IvInManifest = types.HlsIvInManifest(v)
	}
	if v, ok := m["iv_source"].(string); ok && v != "" {
		out.IvSource = types.HlsIvSource(v)
	}
	if v, ok := m["keep_segments"].(int); ok && v != 0 {
		out.KeepSegments = aws.Int32(int32(v))
	}
	if v, ok := m["key_format"].(string); ok && v != "" {
		out.KeyFormat = aws.String(v)
	}
	if v, ok := m["key_format_versions"].(string); ok && v != "" {
		out.KeyFormatVersions = aws.String(v)
	}
	if v, ok := m["key_provider_settings"].([]any); ok && len(v) > 0 {
		out.KeyProviderSettings = expandHLSGroupSettingsKeyProviderSettings(v)
	}
	if v, ok := m["manifest_compression"].(string); ok && v != "" {
		out.ManifestCompression = types.HlsManifestCompression(v)
	}
	if v, ok := m["manifest_duration_format"].(string); ok && v != "" {
		out.ManifestDurationFormat = types.HlsManifestDurationFormat(v)
	}
	if v, ok := m["min_segment_length"].(int); ok && v != 0 {
		out.MinSegmentLength = aws.Int32(int32(v))
	}
	if v, ok := m[names.AttrMode].(string); ok && v != "" {
		out.Mode = types.HlsMode(v)
	}
	if v, ok := m["output_selection"].(string); ok && v != "" {
		out.OutputSelection = types.HlsOutputSelection(v)
	}
	if v, ok := m["program_date_time"].(string); ok && v != "" {
		out.ProgramDateTime = types.HlsProgramDateTime(v)
	}
	if v, ok := m["program_date_time_clock"].(string); ok && v != "" {
		out.ProgramDateTimeClock = types.HlsProgramDateTimeClock(v)
	}
	if v, ok := m["program_date_time_period"].(int); ok && v != 0 {
		out.ProgramDateTimePeriod = aws.Int32(int32(v))
	}
	if v, ok := m["redundant_manifest"].(string); ok && v != "" {
		out.RedundantManifest = types.HlsRedundantManifest(v)
	}
	if v, ok := m["segment_length"].(int); ok && v != 0 {
		out.SegmentLength = aws.Int32(int32(v))
	}
	if v, ok := m["segments_per_subdirectory"].(int); ok && v != 0 {
		out.SegmentsPerSubdirectory = aws.Int32(int32(v))
	}
	if v, ok := m["stream_inf_resolution"].(string); ok && v != "" {
		out.StreamInfResolution = types.HlsStreamInfResolution(v)
	}
	if v, ok := m["timed_metadata_id3_frame"].(string); ok && v != "" {
		out.TimedMetadataId3Frame = types.HlsTimedMetadataId3Frame(v)
	}
	if v, ok := m["timed_metadata_id3_period"].(int); ok && v != 0 {
		out.TimedMetadataId3Period = aws.Int32(int32(v))
	}
	if v, ok := m["timestamp_delta_milliseconds"].(int); ok && v != 0 {
		out.TimestampDeltaMilliseconds = aws.Int32(int32(v))
	}
	if v, ok := m["ts_file_mode"].(string); ok && v != "" {
		out.TsFileMode = types.HlsTsFileMode(v)
	}

	return &out
}
