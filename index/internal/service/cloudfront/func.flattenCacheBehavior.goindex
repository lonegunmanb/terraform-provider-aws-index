package github.com/hashicorp/terraform-provider-aws/internal/service/cloudfront
import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudfront"
	awstypes "github.com/aws/aws-sdk-go-v2/service/cloudfront/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/id"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func flattenCacheBehavior(apiObject *awstypes.CacheBehavior) map[string]any {
	tfMap := make(map[string]any)

	tfMap["cache_policy_id"] = aws.ToString(apiObject.CachePolicyId)
	tfMap["compress"] = aws.ToBool(apiObject.Compress)
	tfMap["field_level_encryption_id"] = aws.ToString(apiObject.FieldLevelEncryptionId)
	tfMap["viewer_protocol_policy"] = apiObject.ViewerProtocolPolicy
	tfMap["target_origin_id"] = aws.ToString(apiObject.TargetOriginId)
	tfMap["min_ttl"] = aws.ToInt64(apiObject.MinTTL)
	tfMap["origin_request_policy_id"] = aws.ToString(apiObject.OriginRequestPolicyId)
	tfMap["realtime_log_config_arn"] = aws.ToString(apiObject.RealtimeLogConfigArn)
	tfMap["response_headers_policy_id"] = aws.ToString(apiObject.ResponseHeadersPolicyId)

	if apiObject.AllowedMethods != nil {
		tfMap["allowed_methods"] = flattenAllowedMethods(apiObject.AllowedMethods)
	}

	if apiObject.AllowedMethods.CachedMethods != nil {
		tfMap["cached_methods"] = flattenCachedMethods(apiObject.AllowedMethods.CachedMethods)
	}

	if apiObject.DefaultTTL != nil {
		tfMap["default_ttl"] = aws.ToInt64(apiObject.DefaultTTL)
	}

	if apiObject.ForwardedValues != nil {
		tfMap["forwarded_values"] = []any{flattenForwardedValues(apiObject.ForwardedValues)}
	}

	if len(apiObject.FunctionAssociations.Items) > 0 {
		tfMap["function_association"] = flattenFunctionAssociations(apiObject.FunctionAssociations)
	}

	if apiObject.GrpcConfig != nil {
		tfMap["grpc_config"] = []any{flattenGRPCConfig(apiObject.GrpcConfig)}
	}

	if len(apiObject.LambdaFunctionAssociations.Items) > 0 {
		tfMap["lambda_function_association"] = flattenLambdaFunctionAssociations(apiObject.LambdaFunctionAssociations)
	}

	if apiObject.MaxTTL != nil {
		tfMap["max_ttl"] = aws.ToInt64(apiObject.MaxTTL)
	}

	if apiObject.PathPattern != nil {
		tfMap["path_pattern"] = aws.ToString(apiObject.PathPattern)
	}

	if apiObject.SmoothStreaming != nil {
		tfMap["smooth_streaming"] = aws.ToBool(apiObject.SmoothStreaming)
	}

	if len(apiObject.TrustedKeyGroups.Items) > 0 {
		tfMap["trusted_key_groups"] = flattenTrustedKeyGroups(apiObject.TrustedKeyGroups)
	}

	if len(apiObject.TrustedSigners.Items) > 0 {
		tfMap["trusted_signers"] = flattenTrustedSigners(apiObject.TrustedSigners)
	}

	return tfMap
}
