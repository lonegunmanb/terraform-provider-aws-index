package github.com/hashicorp/terraform-provider-aws/internal/service/kinesisanalytics
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/kinesisanalytics"
	awstypes "github.com/aws/aws-sdk-go-v2/service/kinesisanalytics/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceApplicationUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).KinesisAnalyticsClient(ctx)

	if d.HasChanges("cloudwatch_logging_options", "code", "inputs", "outputs", "reference_data_sources") {
		applicationName := d.Get(names.AttrName).(string)
		currentApplicationVersionID := int64(d.Get(names.AttrVersion).(int))
		updateApplication := false

		input := &kinesisanalytics.UpdateApplicationInput{
			ApplicationName:   aws.String(applicationName),
			ApplicationUpdate: &awstypes.ApplicationUpdate{},
		}

		if d.HasChange("cloudwatch_logging_options") {
			o, n := d.GetChange("cloudwatch_logging_options")

			if len(o.([]any)) == 0 {
				// Add new CloudWatch logging options.
				mNewCloudWatchLoggingOption := n.([]any)[0].(map[string]any)

				input := &kinesisanalytics.AddApplicationCloudWatchLoggingOptionInput{
					ApplicationName: aws.String(applicationName),
					CloudWatchLoggingOption: &awstypes.CloudWatchLoggingOption{
						LogStreamARN: aws.String(mNewCloudWatchLoggingOption["log_stream_arn"].(string)),
						RoleARN:      aws.String(mNewCloudWatchLoggingOption[names.AttrRoleARN].(string)),
					},
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.AddApplicationCloudWatchLoggingOption(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics Application (%s) CloudWatch logging option: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			} else if len(n.([]any)) == 0 {
				// Delete existing CloudWatch logging options.
				mOldCloudWatchLoggingOption := o.([]any)[0].(map[string]any)

				input := &kinesisanalytics.DeleteApplicationCloudWatchLoggingOptionInput{
					ApplicationName:             aws.String(applicationName),
					CloudWatchLoggingOptionId:   aws.String(mOldCloudWatchLoggingOption[names.AttrID].(string)),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.DeleteApplicationCloudWatchLoggingOption(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics Application (%s) CloudWatch logging option: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			} else {
				// Update existing CloudWatch logging options.
				mOldCloudWatchLoggingOption := o.([]any)[0].(map[string]any)
				mNewCloudWatchLoggingOption := n.([]any)[0].(map[string]any)

				input.ApplicationUpdate.CloudWatchLoggingOptionUpdates = []awstypes.CloudWatchLoggingOptionUpdate{
					{
						CloudWatchLoggingOptionId: aws.String(mOldCloudWatchLoggingOption[names.AttrID].(string)),
						LogStreamARNUpdate:        aws.String(mNewCloudWatchLoggingOption["log_stream_arn"].(string)),
						RoleARNUpdate:             aws.String(mNewCloudWatchLoggingOption[names.AttrRoleARN].(string)),
					},
				}

				updateApplication = true
			}
		}

		if d.HasChange("code") {
			input.ApplicationUpdate.ApplicationCodeUpdate = aws.String(d.Get("code").(string))

			updateApplication = true
		}

		if d.HasChange("inputs") {
			o, n := d.GetChange("inputs")

			if len(o.([]any)) == 0 {
				// Add new input.
				input := &kinesisanalytics.AddApplicationInputInput{
					ApplicationName:             aws.String(applicationName),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
					Input:                       expandInput(n.([]any)),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.AddApplicationInput(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics Application (%s) input: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			} else if len(n.([]any)) == 0 {
				// The existing input cannot be deleted.
				// This should be handled by the CustomizeDiff function above.
				return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics Application (%s) input", d.Id())
			} else {
				// Update existing input.
				inputUpdate := expandInputUpdate(n.([]any))

				if d.HasChange("inputs.0.processing_configuration") {
					o, n := d.GetChange("inputs.0.processing_configuration")

					// Update of existing input processing configuration is handled via the updating of the existing input.

					if len(o.([]any)) == 0 {
						// Add new input processing configuration.
						input := &kinesisanalytics.AddApplicationInputProcessingConfigurationInput{
							ApplicationName:              aws.String(applicationName),
							CurrentApplicationVersionId:  aws.Int64(currentApplicationVersionID),
							InputId:                      inputUpdate.InputId,
							InputProcessingConfiguration: expandInputProcessingConfiguration(n.([]any)),
						}

						_, err := waitIAMPropagation(ctx, func() (any, error) {
							return conn.AddApplicationInputProcessingConfiguration(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics Application (%s) input processing configuration: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
						}

						currentApplicationVersionID += 1
					} else if len(n.([]any)) == 0 {
						// Delete existing input processing configuration.
						input := &kinesisanalytics.DeleteApplicationInputProcessingConfigurationInput{
							ApplicationName:             aws.String(applicationName),
							CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
							InputId:                     inputUpdate.InputId,
						}

						_, err := waitIAMPropagation(ctx, func() (any, error) {
							return conn.DeleteApplicationInputProcessingConfiguration(ctx, input)
						})

						if err != nil {
							return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics Application (%s) input processing configuration: %s", d.Id(), err)
						}

						if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
							return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
						}

						currentApplicationVersionID += 1
					}
				}

				input.ApplicationUpdate.InputUpdates = []awstypes.InputUpdate{inputUpdate}

				updateApplication = true
			}
		}

		if d.HasChange("outputs") {
			o, n := d.GetChange("outputs")
			os := o.(*schema.Set)
			ns := n.(*schema.Set)

			additions := []any{}
			deletions := []string{}

			// Additions.
			for _, vOutput := range ns.Difference(os).List() {
				if outputId, ok := vOutput.(map[string]any)[names.AttrID].(string); ok && outputId != "" {
					// Shouldn't be attempting to add an output with an ID.
					log.Printf("[WARN] Attempting to add invalid Kinesis Analytics Application (%s) output: %#v", d.Id(), vOutput)
				} else {
					additions = append(additions, vOutput)
				}
			}

			// Deletions.
			for _, vOutput := range os.Difference(ns).List() {
				if outputId, ok := vOutput.(map[string]any)[names.AttrID].(string); ok && outputId != "" {
					deletions = append(deletions, outputId)
				} else {
					// Shouldn't be attempting to delete an output without an ID.
					log.Printf("[WARN] Attempting to delete invalid Kinesis Analytics Application (%s) output: %#v", d.Id(), vOutput)
				}
			}

			// Delete existing outputs.
			for _, outputID := range deletions {
				input := &kinesisanalytics.DeleteApplicationOutputInput{
					ApplicationName:             aws.String(applicationName),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
					OutputId:                    aws.String(outputID),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.DeleteApplicationOutput(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics Application (%s) output: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			}

			// Add new outputs.
			for _, vOutput := range additions {
				input := &kinesisanalytics.AddApplicationOutputInput{
					ApplicationName:             aws.String(applicationName),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
					Output:                      expandOutput(vOutput),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.AddApplicationOutput(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics Application (%s) output: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			}
		}

		if d.HasChange("reference_data_sources") {
			o, n := d.GetChange("reference_data_sources")

			if len(o.([]any)) == 0 {
				// Add new reference data source.
				input := &kinesisanalytics.AddApplicationReferenceDataSourceInput{
					ApplicationName:             aws.String(applicationName),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
					ReferenceDataSource:         expandReferenceDataSource(n.([]any)),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.AddApplicationReferenceDataSource(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "adding Kinesis Analytics Application (%s) reference data source: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			} else if len(n.([]any)) == 0 {
				// Delete existing reference data source.
				mOldReferenceDataSource := o.([]any)[0].(map[string]any)

				input := &kinesisanalytics.DeleteApplicationReferenceDataSourceInput{
					ApplicationName:             aws.String(applicationName),
					CurrentApplicationVersionId: aws.Int64(currentApplicationVersionID),
					ReferenceId:                 aws.String(mOldReferenceDataSource[names.AttrID].(string)),
				}

				_, err := waitIAMPropagation(ctx, func() (any, error) {
					return conn.DeleteApplicationReferenceDataSource(ctx, input)
				})

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "deleting Kinesis Analytics Application (%s) reference data source: %s", d.Id(), err)
				}

				if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
					return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
				}

				currentApplicationVersionID += 1
			} else {
				// Update existing reference data source.
				referenceDataSourceUpdate := expandReferenceDataSourceUpdate(n.([]any))

				input.ApplicationUpdate.ReferenceDataSourceUpdates = []awstypes.ReferenceDataSourceUpdate{referenceDataSourceUpdate}

				updateApplication = true
			}
		}

		if updateApplication {
			input.CurrentApplicationVersionId = aws.Int64(currentApplicationVersionID)

			_, err := waitIAMPropagation(ctx, func() (any, error) {
				return conn.UpdateApplication(ctx, input)
			})

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating Kinesis Analytics Application (%s): %s", d.Id(), err)
			}

			if _, err := waitApplicationUpdated(ctx, conn, applicationName); err != nil {
				return sdkdiag.AppendErrorf(diags, "waiting for Kinesis Analytics Application (%s) update: %s", d.Id(), err)
			}
		}
	}

	if d.HasChange("start_application") {
		application, err := findApplicationDetailByName(ctx, conn, d.Get(names.AttrName).(string))

		if err != nil {
			return sdkdiag.AppendErrorf(diags, "reading Kinesis Analytics Application (%s): %s", d.Id(), err)
		}

		if _, ok := d.GetOk("start_application"); ok {
			if v, ok := d.GetOk("inputs"); ok && len(v.([]any)) > 0 && v.([]any)[0] != nil {
				tfMap := v.([]any)[0].(map[string]any)

				var inputStartingPosition string

				if v, ok := tfMap["starting_position_configuration"].([]any); ok && len(v) > 0 && v[0] != nil {
					tfMap := v[0].(map[string]any)

					if v, ok := tfMap["starting_position"].(string); ok && v != "" {
						inputStartingPosition = v
					}
				}

				if err := startApplication(ctx, conn, application, inputStartingPosition); err != nil {
					return sdkdiag.AppendFromErr(diags, err)
				}
			}
		} else {
			if err := stopApplication(ctx, conn, application); err != nil {
				return sdkdiag.AppendFromErr(diags, err)
			}
		}
	}

	return append(diags, resourceApplicationRead(ctx, d, meta)...)
}
