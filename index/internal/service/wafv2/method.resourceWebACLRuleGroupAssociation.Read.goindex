package github.com/hashicorp/terraform-provider-aws/internal/service/wafv2
import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/wafv2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/wafv2/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int32validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/fwdiag"
	intflex "github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	fwvalidators "github.com/hashicorp/terraform-provider-aws/internal/framework/validators"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (r *resourceWebACLRuleGroupAssociation) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state resourceWebACLRuleGroupAssociationModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	conn := r.Meta().WAFV2Client(ctx)

	// Use attributes directly instead of parsing ID
	webACLARN := state.WebACLARN.ValueString()
	ruleName := state.RuleName.ValueString()

	// Parse Web ACL ARN to get ID, name, and scope
	webACLID, webACLName, webACLScope, err := parseWebACLARN(webACLARN)
	if err != nil {
		resp.Diagnostics.AddError(
			"Reading WAFv2 Web ACL Rule Group Association",
			fmt.Sprintf("Error parsing Web ACL ARN: %s", err),
		)
		return
	}

	// Get the Web ACL and check if the rule group is associated
	webACL, err := findWebACLByThreePartKey(ctx, conn, webACLID, webACLName, webACLScope)
	if err != nil {
		if retry.NotFound(err) {
			resp.Diagnostics.Append(fwdiag.NewResourceNotFoundWarningDiagnostic(err))
			resp.State.RemoveResource(ctx)
			return
		}

		resp.Diagnostics.AddError(
			"Reading WAFv2 Web ACL Rule Group Association",
			fmt.Sprintf("Error reading Web ACL: %s", err),
		)
		return
	}

	// Find the rule group in the Web ACL rules
	found := false
	for _, rule := range webACL.WebACL.Rules {
		if aws.ToString(rule.Name) != ruleName {
			continue
		}

		// Check if this rule matches our rule group configuration from state
		if rule.Statement != nil {
			var matchesRuleGroup bool
			var ruleActionOverrides fwtypes.ListNestedObjectValueOf[ruleActionOverrideModel]

			// Check if we have a custom rule group in state
			if !state.RuleGroupReference.IsNull() && !state.RuleGroupReference.IsUnknown() && rule.Statement.RuleGroupReferenceStatement != nil {
				// Get the ARN from state for comparison
				ruleGroupRefs := state.RuleGroupReference.Elements()
				if len(ruleGroupRefs) > 0 {
					var ruleGroupRefModel ruleGroupReferenceModel
					resp.Diagnostics.Append(ruleGroupRefs[0].(fwtypes.ObjectValueOf[ruleGroupReferenceModel]).As(ctx, &ruleGroupRefModel, basetypes.ObjectAsOptions{})...)
					if resp.Diagnostics.HasError() {
						return
					}

					if aws.ToString(rule.Statement.RuleGroupReferenceStatement.ARN) == ruleGroupRefModel.ARN.ValueString() {
						matchesRuleGroup = true
						// Handle rule action overrides with autoflex
						if rule.Statement.RuleGroupReferenceStatement.RuleActionOverrides != nil {
							resp.Diagnostics.Append(fwflex.Flatten(ctx, rule.Statement.RuleGroupReferenceStatement.RuleActionOverrides, &ruleActionOverrides)...)
							if resp.Diagnostics.HasError() {
								return
							}
						} else {
							ruleActionOverrides = fwtypes.NewListNestedObjectValueOfNull[ruleActionOverrideModel](ctx)
						}

						// Update the rule group reference nested structure
						ruleGroupRefModel.RuleActionOverride = ruleActionOverrides
						listValue, diags := fwtypes.NewListNestedObjectValueOfSlice(ctx, []*ruleGroupReferenceModel{&ruleGroupRefModel}, nil)
						resp.Diagnostics.Append(diags...)
						if resp.Diagnostics.HasError() {
							return
						}
						state.RuleGroupReference = listValue
						state.ManagedRuleGroup = fwtypes.NewListNestedObjectValueOfNull[managedRuleGroupModel](ctx)
					}
				}
			} else if !state.ManagedRuleGroup.IsNull() && !state.ManagedRuleGroup.IsUnknown() && rule.Statement.ManagedRuleGroupStatement != nil {
				// Check if we have a managed rule group in state
				managedRuleGroups := state.ManagedRuleGroup.Elements()
				if len(managedRuleGroups) > 0 {
					var managedRuleGroupRef managedRuleGroupModel
					resp.Diagnostics.Append(managedRuleGroups[0].(fwtypes.ObjectValueOf[managedRuleGroupModel]).As(ctx, &managedRuleGroupRef, basetypes.ObjectAsOptions{})...)
					if resp.Diagnostics.HasError() {
						return
					}

					managedStmt := rule.Statement.ManagedRuleGroupStatement
					// Check if this matches our managed rule group from state
					if aws.ToString(managedStmt.Name) == managedRuleGroupRef.Name.ValueString() &&
						aws.ToString(managedStmt.VendorName) == managedRuleGroupRef.VendorName.ValueString() {
						// Check version match (both can be empty/null)
						stateVersion := managedRuleGroupRef.Version.ValueString()
						ruleVersion := aws.ToString(managedStmt.Version)
						if stateVersion == ruleVersion {
							matchesRuleGroup = true
							// Handle rule action overrides with autoflex
							if managedStmt.RuleActionOverrides != nil {
								resp.Diagnostics.Append(fwflex.Flatten(ctx, managedStmt.RuleActionOverrides, &ruleActionOverrides)...)
								if resp.Diagnostics.HasError() {
									return
								}
							} else {
								ruleActionOverrides = fwtypes.NewListNestedObjectValueOfNull[ruleActionOverrideModel](ctx)
							}

							// Update the managed rule group nested structure
							managedRuleGroupRef.RuleActionOverride = ruleActionOverrides
							listValue, diags := fwtypes.NewListNestedObjectValueOfSlice(ctx, []*managedRuleGroupModel{&managedRuleGroupRef}, nil)
							resp.Diagnostics.Append(diags...)
							if resp.Diagnostics.HasError() {
								return
							}
							state.ManagedRuleGroup = listValue
							state.RuleGroupReference = fwtypes.NewListNestedObjectValueOfNull[ruleGroupReferenceModel](ctx)
						}
					}
				}
			}

			if matchesRuleGroup {
				found = true
				state.Priority = types.Int32Value(rule.Priority)

				// Determine override action
				overrideAction := overrideActionNone
				if rule.OverrideAction != nil {
					if rule.OverrideAction.Count != nil {
						overrideAction = overrideActionCount
					} else if rule.OverrideAction.None != nil {
						overrideAction = overrideActionNone
					}
				}
				state.OverrideAction = types.StringValue(overrideAction)
				break
			}
		}
	}

	if !found {
		resp.Diagnostics.AddWarning(
			"Rule Group Association Not Found",
			"Rule group association was not found in Web ACL, removing from state",
		)
		resp.State.RemoveResource(ctx)
		return
	}

	// Update state with current values (WebACLARN and RuleName should already be set from current state)
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
