package github.com/hashicorp/terraform-provider-aws/internal/service/wafv2
import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/wafv2"
	awstypes "github.com/aws/aws-sdk-go-v2/service/wafv2/types"
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/int32validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/fwdiag"
	intflex "github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	fwvalidators "github.com/hashicorp/terraform-provider-aws/internal/framework/validators"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (r *resourceWebACLRuleGroupAssociation) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	parts, err := intflex.ExpandResourceId(req.ID, webACLRuleGroupAssociationResourceIDPartCount, true)
	if err != nil {
		resp.Diagnostics.AddError(
			"Unexpected Import Identifier",
			fmt.Sprintf("Expected import identifier with format: web_acl_arn,rule_name,rule_group_type,rule_group_identifier. Got: %q", req.ID),
		)
		return
	}

	webACLARN := parts[0]
	ruleName := parts[1]
	ruleGroupType := parts[2]
	ruleGroupIdentifier := parts[3]

	// Parse Web ACL ARN to get ID, name, and scope
	_, _, _, err = parseWebACLARN(webACLARN)
	if err != nil {
		resp.Diagnostics.AddError(
			"Invalid Web ACL ARN",
			fmt.Sprintf("Error parsing Web ACL ARN: %s", err),
		)
		return
	}

	// Set basic attributes
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("web_acl_arn"), webACLARN)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("rule_name"), ruleName)...)

	// Set the appropriate rule group nested structure based on type
	switch ruleGroupType {
	case "custom":
		// Custom rule group (ARN format)
		if !arn.IsARN(ruleGroupIdentifier) {
			resp.Diagnostics.AddError(
				"Invalid Custom Rule Group Identifier",
				"Custom rule group identifier should be an ARN",
			)
			return
		}

		ruleGroupRefModel := &ruleGroupReferenceModel{
			ARN:                types.StringValue(ruleGroupIdentifier),
			RuleActionOverride: fwtypes.NewListNestedObjectValueOfNull[ruleActionOverrideModel](ctx),
		}

		listValue, diags := fwtypes.NewListNestedObjectValueOfSlice(ctx, []*ruleGroupReferenceModel{ruleGroupRefModel}, nil)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("rule_group_reference"), listValue)...)
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("managed_rule_group"), fwtypes.NewListNestedObjectValueOfNull[managedRuleGroupModel](ctx))...)
	case "managed":
		// Managed rule group (vendorName:ruleName[:version] format)
		identifierParts := strings.Split(ruleGroupIdentifier, ":")
		if len(identifierParts) < 2 {
			resp.Diagnostics.AddError(
				"Invalid Managed Rule Group Identifier",
				"Managed rule group identifier should be in format 'vendorName:ruleName[:version]'",
			)
			return
		}

		vendorName := identifierParts[0]
		ruleGroupName := identifierParts[1]
		var version string
		if len(identifierParts) > 2 {
			version = identifierParts[2]
		}

		managedRuleGroupRef := &managedRuleGroupModel{
			Name:               types.StringValue(ruleGroupName),
			VendorName:         types.StringValue(vendorName),
			RuleActionOverride: fwtypes.NewListNestedObjectValueOfNull[ruleActionOverrideModel](ctx),
		}
		if version != "" {
			managedRuleGroupRef.Version = types.StringValue(version)
		} else {
			managedRuleGroupRef.Version = types.StringNull()
		}

		listValue, diags := fwtypes.NewListNestedObjectValueOfSlice(ctx, []*managedRuleGroupModel{managedRuleGroupRef}, nil)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("managed_rule_group"), listValue)...)
		resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("rule_group_reference"), fwtypes.NewListNestedObjectValueOfNull[ruleGroupReferenceModel](ctx))...)
	default:
		resp.Diagnostics.AddError(
			"Invalid Rule Group Type",
			fmt.Sprintf("Rule group type must be 'custom' or 'managed', got: %s", ruleGroupType),
		)
		return
	}
}
