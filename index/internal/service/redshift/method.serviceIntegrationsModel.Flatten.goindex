package github.com/hashicorp/terraform-provider-aws/internal/service/redshift
import (
	"context"
	"errors"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/service/redshift"
	awstypes "github.com/aws/aws-sdk-go-v2/service/redshift/types"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/fwdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/smerr"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (m *serviceIntegrationsModel) Flatten(ctx context.Context, v any) diag.Diagnostics {
	var diags diag.Diagnostics

	switch t := v.(type) {
	case awstypes.ServiceIntegrationsUnionMemberLakeFormation:
		var data lakeFormationModel
		if len(t.Value) > 0 {
			var lfQueryData lakeFormationQueryModel

			// Type switch on the LakeFormationScopeUnion to get LakeFormationQuery
			switch scopeUnion := t.Value[0].(type) {
			case *awstypes.LakeFormationScopeUnionMemberLakeFormationQuery:
				// Flatten the LakeFormationQuery value into the model
				diags.Append(fwflex.Flatten(ctx, scopeUnion.Value, &lfQueryData)...)
				if diags.HasError() {
					return diags
				}

				// Set the LakeFormationQuery in the parent model
				data.LakeFormationQuery = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, &lfQueryData)
			}
		}
		m.LakeFormation = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, &data)

	case awstypes.ServiceIntegrationsUnionMemberRedshift:
		var data redshiftModel

		// Handle the nested RedshiftScope union
		if len(t.Value) > 0 {
			var connectData connectModel

			// Type switch on the RedshiftScopeUnion to get Connect
			switch scopeUnion := t.Value[0].(type) {
			case *awstypes.RedshiftScopeUnionMemberConnect:
				// Flatten the Connect value into the model
				diags.Append(fwflex.Flatten(ctx, scopeUnion.Value, &connectData)...)
				if diags.HasError() {
					return diags
				}

				// Set the Connect in the parent model
				data.Connect = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, &connectData)
			}
		}
		m.Redshift = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, &data)

	case awstypes.ServiceIntegrationsUnionMemberS3AccessGrants:
		var data s3AccessGrantsModel

		// Handle the nested S3AccessGrantsScope union
		if len(t.Value) > 0 {
			var readWriteAccessData readWriteAccessModel

			// Type switch on the S3AccessGrantsScopeUnion to get ReadWriteAccess
			switch scopeUnion := t.Value[0].(type) {
			case *awstypes.S3AccessGrantsScopeUnionMemberReadWriteAccess:
				// Flatten the ReadWriteAccess value into the model
				diags.Append(fwflex.Flatten(ctx, scopeUnion.Value, &readWriteAccessData)...)
				if diags.HasError() {
					return diags
				}

				// Set the ReadWriteAccess in the parent model
				data.ReadWriteAccess = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, &readWriteAccessData)
			}
		}
		m.S3AccessGrants = fwtypes.NewListNestedObjectValueOfPtrMust(ctx, &data)
	}

	return diags
}
