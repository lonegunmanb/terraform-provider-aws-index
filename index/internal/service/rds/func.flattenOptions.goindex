package github.com/hashicorp/terraform-provider-aws/internal/service/rds
import (
	"context"
	"log"
	"slices"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/rds"
	"github.com/aws/aws-sdk-go-v2/service/rds/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func flattenOptions(apiObjects []types.Option, configuredObjects []types.OptionConfiguration) []any {
	tfList := make([]any, 0)

	for _, apiObject := range apiObjects {
		if apiObject.OptionName == nil {
			continue
		}

		optionName := aws.ToString(apiObject.OptionName)
		var configuredOption *types.OptionConfiguration
		if v := tfslices.Filter(configuredObjects, func(v types.OptionConfiguration) bool {
			return aws.ToString(v.OptionName) == optionName
		}); len(v) > 0 {
			configuredOption = &v[0]
		}

		optionSettings := make([]any, 0)
		for _, apiOptionSetting := range apiObject.OptionSettings {
			// The RDS API responds with all settings. Omit settings that match default value,
			// but only if unconfigured. This is to prevent operators from continually needing
			// to continually update their Terraform configurations to match new option settings
			// when added by the API.
			optionSettingName := aws.ToString(apiOptionSetting.Name)
			var configuredOptionSetting *types.OptionSetting

			if configuredOption != nil {
				if v := tfslices.Filter(configuredOption.OptionSettings, func(v types.OptionSetting) bool {
					return aws.ToString(v.Name) == optionSettingName
				}); len(v) > 0 {
					configuredOptionSetting = &v[0]
				}
			}

			optionSettingValue := aws.ToString(apiOptionSetting.Value)
			if configuredOptionSetting == nil && optionSettingValue == aws.ToString(apiOptionSetting.DefaultValue) {
				continue
			}

			optionSetting := map[string]any{
				names.AttrName:  optionSettingName,
				names.AttrValue: optionSettingValue,
			}

			// Some values, like passwords, are sent back from the API as ****.
			// Set the response to match the configuration to prevent an unexpected difference.
			if configuredOptionSetting != nil && optionSettingValue == "****" {
				optionSetting[names.AttrValue] = aws.ToString(configuredOptionSetting.Value)
			}

			optionSettings = append(optionSettings, optionSetting)
		}

		tfMap := map[string]any{
			"db_security_group_memberships": tfslices.ApplyToAll(apiObject.DBSecurityGroupMemberships, func(v types.DBSecurityGroupMembership) string {
				return aws.ToString(v.DBSecurityGroupName)
			}),
			"option_name":     optionName,
			"option_settings": optionSettings,
			"vpc_security_group_memberships": tfslices.ApplyToAll(apiObject.VpcSecurityGroupMemberships, func(v types.VpcSecurityGroupMembership) string {
				return aws.ToString(v.VpcSecurityGroupId)
			}),
		}

		if apiObject.OptionVersion != nil && configuredOption != nil && configuredOption.OptionVersion != nil {
			tfMap[names.AttrVersion] = aws.ToString(apiObject.OptionVersion)
		}

		if apiObject.Port != nil && configuredOption != nil && configuredOption.Port != nil {
			tfMap[names.AttrPort] = aws.ToInt32(apiObject.Port)
		}

		tfList = append(tfList, tfMap)
	}

	return tfList
}
