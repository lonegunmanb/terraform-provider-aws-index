package github.com/hashicorp/terraform-provider-aws/internal/service/rds
import (
	"context"
	"errors"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/aws/arn"
	"github.com/aws/aws-sdk-go-v2/service/rds"
	"github.com/aws/aws-sdk-go-v2/service/rds/types"
	"github.com/hashicorp/aws-sdk-go-base/v2/tfawserr"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/enum"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func resourceInstanceUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	var diags diag.Diagnostics
	conn := meta.(*conns.AWSClient).RDSClient(ctx)
	deadline := inttypes.NewDeadline(d.Timeout(schema.TimeoutUpdate))

	// Separate request to promote a database.
	if d.HasChange("replicate_source_db") {
		if d.Get("replicate_source_db").(string) == "" {
			input := &rds.PromoteReadReplicaInput{
				BackupRetentionPeriod: aws.Int32(int32(d.Get("backup_retention_period").(int))),
				DBInstanceIdentifier:  aws.String(d.Get(names.AttrIdentifier).(string)),
			}

			if attr, ok := d.GetOk("backup_window"); ok {
				input.PreferredBackupWindow = aws.String(attr.(string))
			}

			_, err := conn.PromoteReadReplica(ctx, input)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "promoting RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			if _, err := waitDBInstanceAvailable(ctx, conn, d.Id(), deadline.Remaining()); err != nil {
				return sdkdiag.AppendErrorf(diags, "promoting RDS DB Instance (%s): waiting for completion: %s", d.Get(names.AttrIdentifier).(string), err)
			}
		} else {
			return sdkdiag.AppendErrorf(diags, "cannot elect new source database for replication")
		}
	}

	// Having allowing_major_version_upgrade by itself should not trigger ModifyDBInstance
	// as it results in "InvalidParameterCombination: No modifications were requested".
	if d.HasChangesExcept(
		names.AttrAllowMajorVersionUpgrade,
		"blue_green_update",
		"delete_automated_backups",
		names.AttrFinalSnapshotIdentifier,
		"replicate_source_db",
		"skip_final_snapshot",
		names.AttrTags, names.AttrTagsAll,
	) {
		if d.Get("blue_green_update.0.enabled").(bool) && d.HasChangesExcept(
			names.AttrAllowMajorVersionUpgrade,
			"blue_green_update",
			"delete_automated_backups",
			names.AttrFinalSnapshotIdentifier,
			"replicate_source_db",
			"skip_final_snapshot",
			names.AttrTags, names.AttrTagsAll,
			names.AttrDeletionProtection,
			names.AttrPassword,
		) {
			orchestrator := newBlueGreenOrchestrator(conn)
			defer orchestrator.CleanUp(ctx)

			handler := newInstanceHandler(conn)

			err := handler.precondition(ctx, d)
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			createIn := handler.createBlueGreenInput(d)

			log.Printf("[DEBUG] Updating RDS DB Instance (%s): Creating Blue/Green Deployment", d.Get(names.AttrIdentifier).(string))

			dep, err := orchestrator.CreateDeployment(ctx, createIn)
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			deploymentIdentifier := dep.BlueGreenDeploymentIdentifier
			defer func() {
				log.Printf("[DEBUG] Updating RDS DB Instance (%s): Deleting Blue/Green Deployment", d.Get(names.AttrIdentifier).(string))

				if dep == nil {
					log.Printf("[DEBUG] Updating RDS DB Instance (%s): Deleting Blue/Green Deployment: deployment disappeared", d.Get(names.AttrIdentifier).(string))
					return
				}

				// Ensure that the Blue/Green Deployment is always cleaned up
				input := &rds.DeleteBlueGreenDeploymentInput{
					BlueGreenDeploymentIdentifier: deploymentIdentifier,
				}
				if aws.ToString(dep.Status) != "SWITCHOVER_COMPLETED" {
					input.DeleteTarget = aws.Bool(true)
				}

				_, err = conn.DeleteBlueGreenDeployment(ctx, input)

				if err != nil {
					diags = sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): deleting Blue/Green Deployment: %s", d.Get(names.AttrIdentifier).(string), err)
					return
				}

				orchestrator.AddCleanupWaiter(func(ctx context.Context, conn *rds.Client, optFns ...tfresource.OptionsFunc) {
					if _, err := waitBlueGreenDeploymentDeleted(ctx, conn, aws.ToString(deploymentIdentifier), deadline.Remaining(), optFns...); err != nil {
						diags = sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): deleting Blue/Green Deployment: waiting for completion: %s", d.Get(names.AttrIdentifier).(string), err)
					}
				})
			}()

			dep, err = orchestrator.waitForDeploymentAvailable(ctx, aws.ToString(dep.BlueGreenDeploymentIdentifier), deadline.Remaining())
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			targetARN, err := parseDBInstanceARN(aws.ToString(dep.Target))
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): creating Blue/Green Deployment: waiting for Green environment: %s", d.Get(names.AttrIdentifier).(string), err)
			}

			if _, err := waitDBInstanceAvailable(ctx, conn, targetARN.Identifier, deadline.Remaining()); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): creating Blue/Green Deployment: waiting for Green environment: %s", d.Get(names.AttrIdentifier).(string), err)
			}

			if err := handler.modifyTarget(ctx, targetARN.Identifier, d, deadline.Remaining(), fmt.Sprintf("Updating RDS DB Instance (%s)", d.Get(names.AttrIdentifier).(string))); err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			log.Printf("[DEBUG] Updating RDS DB Instance (%s): Switching over Blue/Green Deployment", d.Get(names.AttrIdentifier).(string))

			dep, err = orchestrator.Switchover(ctx, aws.ToString(dep.BlueGreenDeploymentIdentifier), deadline.Remaining())
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			target, err := findDBInstanceByID(ctx, conn, d.Get(names.AttrIdentifier).(string))
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}

			// id changes here
			d.SetId(aws.ToString(target.DbiResourceId))
			d.Set(names.AttrResourceID, target.DbiResourceId)

			log.Printf("[DEBUG] Updating RDS DB Instance (%s): Deleting Blue/Green Deployment source", d.Get(names.AttrIdentifier).(string))

			sourceARN, err := parseDBInstanceARN(aws.ToString(dep.Source))
			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): deleting Blue/Green Deployment source: %s", d.Get(names.AttrIdentifier).(string), err)
			}

			if d.Get(names.AttrDeletionProtection).(bool) {
				input := &rds.ModifyDBInstanceInput{
					ApplyImmediately:     aws.Bool(true),
					DBInstanceIdentifier: aws.String(sourceARN.Identifier),
					DeletionProtection:   aws.Bool(false),
				}

				err := dbInstanceModify(ctx, conn, d.Id(), input, deadline.Remaining())

				if err != nil {
					return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): deleting Blue/Green Deployment source: disabling deletion protection: %s", d.Get(names.AttrIdentifier).(string), err)
				}
			}

			input := &rds.DeleteDBInstanceInput{
				DBInstanceIdentifier: aws.String(sourceARN.Identifier),
				SkipFinalSnapshot:    aws.Bool(true),
			}

			const (
				timeout = 5 * time.Minute
			)
			_, err = tfresource.RetryWhen(ctx, timeout,
				func() (any, error) {
					return conn.DeleteDBInstance(ctx, input)
				},
				func(err error) (bool, error) {
					// Retry for IAM eventual consistency.
					if tfawserr.ErrMessageContains(err, errCodeInvalidParameterValue, "IAM role ARN value is invalid or does not include the required permissions") {
						return true, err
					}

					if tfawserr.ErrMessageContains(err, errCodeInvalidParameterCombination, "disable deletion pro") {
						return true, err
					}

					return false, err
				},
			)

			if err != nil {
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): deleting Blue/Green Deployment source: %s", d.Get(names.AttrIdentifier).(string), err)
			}

			orchestrator.AddCleanupWaiter(func(ctx context.Context, conn *rds.Client, optFns ...tfresource.OptionsFunc) {
				if _, err := waitDBInstanceDeleted(ctx, conn, sourceARN.Identifier, deadline.Remaining(), optFns...); err != nil {
					diags = sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): deleting Blue/Green Deployment source: waiting for completion: %s", d.Get(names.AttrIdentifier).(string), err)
				}
			})

			if diags.HasError() {
				return diags
			}
		} else {
			oldID := d.Get(names.AttrIdentifier).(string)
			if d.HasChange(names.AttrIdentifier) {
				o, _ := d.GetChange(names.AttrIdentifier)
				oldID = o.(string)
			}

			applyImmediately := d.Get(names.AttrApplyImmediately).(bool)
			input := &rds.ModifyDBInstanceInput{
				ApplyImmediately:     aws.Bool(applyImmediately),
				DBInstanceIdentifier: aws.String(oldID),
			}

			if !applyImmediately {
				log.Println("[INFO] Only settings updating, instance changes will be applied in next maintenance window")
			}

			dbInstancePopulateModify(input, d)

			if d.HasChange(names.AttrEngineVersion) {
				input.EngineVersion = aws.String(d.Get(names.AttrEngineVersion).(string))
				input.AllowMajorVersionUpgrade = aws.Bool(d.Get(names.AttrAllowMajorVersionUpgrade).(bool))
				// if we were to make life easier for practitioners, we could loop through
				// replicas at this point to update them first, prior to dbInstanceModify()
				// for the source
			}

			if d.HasChange(names.AttrParameterGroupName) {
				input.DBParameterGroupName = aws.String(d.Get(names.AttrParameterGroupName).(string))
			}

			err := dbInstanceModify(ctx, conn, d.Id(), input, deadline.Remaining())

			if err != nil {
				// Handle virtual attribute
				if input.ManageMasterUserPassword != nil {
					// Attempted change, but update error as it's a stopped instance, so revert to original value
					old, _ := d.GetChange("manage_master_user_password")
					d.Set("manage_master_user_password", old.(bool))
				}
				return sdkdiag.AppendErrorf(diags, "updating RDS DB Instance (%s): %s", d.Get(names.AttrIdentifier).(string), err)
			}
		}
	}

	return append(diags, resourceInstanceRead(ctx, d, meta)...)
}
