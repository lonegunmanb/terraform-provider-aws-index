package github.com/hashicorp/terraform-provider-aws/internal/service/wafregional
import (
	"context"
	"fmt"
	"log"
	"slices"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/wafregional"
	awstypes "github.com/aws/aws-sdk-go-v2/service/wafregional/types"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	sdkretry "github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/retry"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func flattenByteMatchTuples(in []awstypes.ByteMatchTuple) []any {
	tuples := make([]any, len(in))

	for i, tuple := range in {
		fieldToMatchMap := map[string]any{
			"data":         aws.ToString(tuple.FieldToMatch.Data),
			names.AttrType: tuple.FieldToMatch.Type,
		}

		m := map[string]any{
			"field_to_match":        []map[string]any{fieldToMatchMap},
			"positional_constraint": tuple.PositionalConstraint,
			"target_string":         string(tuple.TargetString),
			"text_transformation":   tuple.TextTransformation,
		}
		tuples[i] = m
	}

	return tuples
}
