package github.com/hashicorp/terraform-provider-aws/internal/acctest
import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/xml"
	"fmt"
	"io"
	"math/rand" // nosemgrep: go.lang.security.audit.crypto.math_random.math-random-used -- Deterministic PRNG required for VCR test reproducibility
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strconv"
	"strings"
	"testing"

	cleanhttp "github.com/hashicorp/go-cleanhttp"
	"github.com/hashicorp/terraform-plugin-go/tfprotov5"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	sdkacctest "github.com/hashicorp/terraform-plugin-testing/helper/acctest"
	"github.com/hashicorp/terraform-plugin-testing/helper/resource"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	tfjson "github.com/hashicorp/terraform-provider-aws/internal/json"
	"github.com/hashicorp/terraform-provider-aws/internal/provider"
	"github.com/hashicorp/terraform-provider-aws/internal/vcr"
	"gopkg.in/dnaeon/go-vcr.v4/pkg/cassette"
	"gopkg.in/dnaeon/go-vcr.v4/pkg/recorder"
)
func vcrProviderConfigureContextFunc(provider *schema.Provider, configureContextFunc schema.ConfigureContextFunc, t *testing.T) schema.ConfigureContextFunc {
	return func(ctx context.Context, d *schema.ResourceData) (any, diag.Diagnostics) {
		var diags diag.Diagnostics
		testName := t.Name()

		providerMetas.Lock()
		meta, ok := providerMetas[testName]
		providerMetas.Unlock()

		if ok {
			return meta, nil
		}

		vcrMode, err := vcr.Mode()
		if err != nil {
			return nil, sdkdiag.AppendFromErr(diags, err)
		}

		// Real transport config, cribbed from aws-sdk-go-base.
		httpClient := cleanhttp.DefaultPooledClient()
		transport := httpClient.Transport.(*http.Transport)
		transport.MaxIdleConnsPerHost = 10
		if transport.TLSClientConfig == nil {
			transport.TLSClientConfig = &tls.Config{
				MinVersion: tls.VersionTLS13,
			}
		}

		cassetteName := filepath.Join(vcr.Path(), vcrFileName(testName))

		// Create a VCR recorder around a default HTTP client.
		r, err := recorder.New(cassetteName,
			recorder.WithHook(vcrSensitiveHeaderHook, recorder.AfterCaptureHook),
			recorder.WithMatcher(vcrMatcherFunc(ctx)),
			recorder.WithMode(vcrMode),
			recorder.WithRealTransport(httpClient.Transport),
			recorder.WithSkipRequestLatency(true),
		)

		if err != nil {
			return nil, sdkdiag.AppendFromErr(diags, err)
		}

		// Use the wrapped HTTP Client for AWS APIs.
		// As the HTTP client is used in the provider's ConfigureContextFunc
		// we must do this setup before calling the ConfigureContextFunc.
		httpClient.Transport = r
		if v, ok := provider.Meta().(*conns.AWSClient); ok {
			meta = v
		} else {
			meta = new(conns.AWSClient)
		}
		meta.SetHTTPClient(ctx, httpClient)
		provider.SetMeta(meta)

		if v, ds := configureContextFunc(ctx, d); ds.HasError() {
			return nil, append(diags, ds...)
		} else {
			meta = v.(*conns.AWSClient)
		}

		s, err := vcrRandomnessSource(t)
		if err != nil {
			return nil, sdkdiag.AppendFromErr(diags, err)
		}
		meta.SetRandomnessSource(s.source)

		providerMetas.Lock()
		providerMetas[testName] = meta
		providerMetas.Unlock()

		return meta, diags
	}
}
