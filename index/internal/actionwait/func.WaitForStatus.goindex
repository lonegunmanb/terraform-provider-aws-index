package github.com/hashicorp/terraform-provider-aws/internal/actionwait
import (
	"context"
	"errors"
	"slices"
	"time"

	"github.com/hashicorp/terraform-provider-aws/internal/backoff"
)
func WaitForStatus[T any](ctx context.Context, fetch FetchFunc[T], opts Options[T]) (FetchResult[T], error) { //nolint:cyclop // complexity driven by classification/state machine; readability preferred
	if err := validateOptions(opts); err != nil {
		var zero FetchResult[T]
		return zero, err
	}

	normalizeOptions(&opts)

	start := time.Now()
	deadline := start.Add(opts.Timeout)
	var lastProgress time.Time
	var attempt uint
	var successStreak int
	var last FetchResult[T]

	// Precompute allowed states for unexpected classification (success + transitional + failure)
	// Failure states are excluded from Allowed to ensure they classify distinctly.
	allowedTransient := append([]Status{}, opts.SuccessStates...)
	allowedTransient = append(allowedTransient, opts.TransitionalStates...)

	for {
		// Early return: context cancelled
		if ctx.Err() != nil {
			return last, ctx.Err()
		}

		// Early return: timeout exceeded
		if time.Now().After(deadline) {
			return last, &TimeoutError{LastStatus: last.Status, Timeout: opts.Timeout}
		}

		// Fetch current status
		fr, err := fetch(ctx)
		if err != nil {
			return fr, err // Early return: fetch error
		}
		last = fr

		// Classify status and determine if we should terminate
		isTerminal, classifyErr := classifyStatus(fr, opts, &successStreak, allowedTransient)
		if isTerminal {
			return fr, classifyErr // Early return: terminal state (success or failure)
		}

		// Handle progress reporting
		handleProgressReport(opts, fr, start, deadline, attempt, &lastProgress)

		// Sleep until next attempt, with context cancellation check
		if err := sleepWithContext(ctx, opts.Interval.NextPoll(attempt)); err != nil {
			return last, err // Early return: context cancelled during sleep
		}

		attempt++
	}
}
