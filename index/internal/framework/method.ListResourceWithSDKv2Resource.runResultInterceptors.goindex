package github.com/hashicorp/terraform-provider-aws/internal/framework
import (
	"context"
	"slices"
	"unique"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/list"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/terraform"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/provider/framework/listresource"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	tfunique "github.com/hashicorp/terraform-provider-aws/internal/unique"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (l *ListResourceWithSDKv2Resource) runResultInterceptors(ctx context.Context, when listresource.When, awsClient *conns.AWSClient, d *schema.ResourceData, includeResource bool) diag.Diagnostics {
	var diags diag.Diagnostics
	params := listresource.InterceptorParamsSDK{
		C:               awsClient,
		IncludeResource: includeResource,
		ResourceData:    d,
		When:            when,
	}

	switch when {
	case listresource.Before:
		for interceptor := range slices.Values(l.interceptors) {
			diags.Append(interceptor.Read(ctx, params)...)
			if diags.HasError() {
				return diags
			}
		}
	case listresource.After:
		for interceptor := range tfslices.BackwardValues(l.interceptors) {
			diags.Append(interceptor.Read(ctx, params)...)
			if diags.HasError() {
				return diags
			}
		}
	}

	return diags
}
