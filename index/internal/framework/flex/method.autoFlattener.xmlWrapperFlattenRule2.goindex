package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"time"

	smithydocument "github.com/aws/smithy-go/document"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
	tfsmithy "github.com/hashicorp/terraform-provider-aws/internal/smithy"
	"github.com/shopspring/decimal"
)
func (flattener *autoFlattener) xmlWrapperFlattenRule2(ctx context.Context, vFrom reflect.Value, tTo fwtypes.NestedObjectCollectionType, vTo reflect.Value, opts tagOptions) diag.Diagnostics {
	var diags diag.Diagnostics

	tflog.SubsystemTrace(ctx, subsystemName, "xmlWrapperFlattenRule2 ENTRY", map[string]any{
		"source_type": vFrom.Type().String(),
	})

	// Check if wrapper Items field is empty/nil
	wrapperFieldName := getXMLWrapperSliceFieldName(vFrom.Type())
	itemsField := vFrom.FieldByName(wrapperFieldName)

	itemsLen := 0
	if itemsField.IsValid() && !itemsField.IsNil() {
		itemsLen = itemsField.Len()
	}

	tflog.SubsystemTrace(ctx, subsystemName, "Checking Items field", map[string]any{
		"wrapper_field_name": wrapperFieldName,
		"items_valid":        itemsField.IsValid(),
		"items_len":          itemsLen,
	})

	if itemsField.IsValid() {
		itemsEmpty := itemsField.IsNil() || (itemsField.Kind() == reflect.Slice && itemsField.Len() == 0)

		tflog.SubsystemTrace(ctx, subsystemName, "Items empty check", map[string]any{
			"items_empty": itemsEmpty,
		})

		// If Items is empty AND all other fields (except Quantity) are nil or zero,
		// return null instead of creating a block with all default values
		if itemsEmpty {
			allOtherFieldsZero := true
			for i := 0; i < vFrom.NumField(); i++ {
				sourceField := vFrom.Field(i)
				fieldName := vFrom.Type().Field(i).Name

				// Skip Items and Quantity fields
				if fieldName == wrapperFieldName || fieldName == xmlWrapperFieldQuantity {
					continue
				}

				// For pointers: nil is zero, non-nil pointer to zero value is also considered zero
				// For non-pointers: use IsZero()
				isFieldZero := false
				if sourceField.Kind() == reflect.Pointer {
					if sourceField.IsNil() {
						isFieldZero = true
					} else if sourceField.Elem().IsZero() {
						isFieldZero = true
					}
				} else {
					isFieldZero = sourceField.IsZero()
				}

				tflog.SubsystemTrace(ctx, subsystemName, "Checking field zero status", map[string]any{
					"field_name":    fieldName,
					"is_field_zero": isFieldZero,
					"field_kind":    sourceField.Kind().String(),
					"field_is_nil":  sourceField.Kind() == reflect.Pointer && sourceField.IsNil(),
				})

				if !isFieldZero {
					allOtherFieldsZero = false
					break
				}
			}

			tflog.SubsystemTrace(ctx, subsystemName, "Zero value check result", map[string]any{
				"all_other_fields_zero": allOtherFieldsZero,
			})

			if allOtherFieldsZero {
				// Check if target field has omitempty - only return null if it does
				if opts.OmitEmpty() {
					tflog.SubsystemTrace(ctx, subsystemName, "XML wrapper Items is empty and all other fields are zero, returning null for Rule 2 (omitempty)")
					nullVal, d := tTo.NullValue(ctx)
					diags.Append(d...)
					if !diags.HasError() {
						vTo.Set(reflect.ValueOf(nullVal))
					}
					return diags
				}
				tflog.SubsystemTrace(ctx, subsystemName, "XML wrapper Items is empty and all other fields are zero, but no omitempty - creating zero-value struct for Rule 2")
			}
		}
	}

	nestedObjPtr, d := tTo.NewObjectPtr(ctx)
	diags.Append(d...)
	if diags.HasError() {
		return diags
	}

	nestedObjValue := reflect.ValueOf(nestedObjPtr).Elem()

	// Map Items field - find target field by xmlwrapper tag
	if itemsField := vFrom.FieldByName(wrapperFieldName); itemsField.IsValid() {
		for i := 0; i < nestedObjValue.NumField(); i++ {
			targetField := nestedObjValue.Field(i)
			targetFieldType := nestedObjValue.Type().Field(i)
			_, fieldOpts := autoflexTags(targetFieldType)
			if fieldOpts.XMLWrapperField() == wrapperFieldName {
				if targetField.CanAddr() {
					if targetAttr, ok := targetField.Addr().Interface().(attr.Value); ok {
						diags.Append(autoFlattenConvert(ctx, itemsField.Interface(), targetAttr, flattener)...)
					}
				}
				break
			}
		}
	}

	// Map all other fields (skip Items and Quantity)
	for i := 0; i < vFrom.NumField(); i++ {
		sourceField := vFrom.Field(i)
		fieldName := vFrom.Type().Field(i).Name

		if fieldName == wrapperFieldName || fieldName == xmlWrapperFieldQuantity {
			continue
		}

		if targetField := nestedObjValue.FieldByName(fieldName); targetField.IsValid() && targetField.CanAddr() {
			if targetAttr, ok := targetField.Addr().Interface().(attr.Value); ok {
				diags.Append(autoFlattenConvert(ctx, sourceField.Interface(), targetAttr, flattener)...)
			}
		}
	}

	ptrType := reflect.TypeOf(nestedObjPtr)
	objectSlice := reflect.MakeSlice(reflect.SliceOf(ptrType), 1, 1)
	objectSlice.Index(0).Set(reflect.ValueOf(nestedObjPtr))

	targetValue, d := tTo.ValueFromObjectSlice(ctx, objectSlice.Interface())
	diags.Append(d...)
	if !diags.HasError() {
		vTo.Set(reflect.ValueOf(targetValue))
	}

	return diags
}
