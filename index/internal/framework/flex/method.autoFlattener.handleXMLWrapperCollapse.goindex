package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"time"

	smithydocument "github.com/aws/smithy-go/document"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
	tfsmithy "github.com/hashicorp/terraform-provider-aws/internal/smithy"
	"github.com/shopspring/decimal"
)
func (flattener autoFlattener) handleXMLWrapperCollapse(ctx context.Context, sourcePath path.Path, valFrom reflect.Value, targetPath path.Path, valTo reflect.Value, typeFrom, typeTo reflect.Type, processedFields map[string]bool) diag.Diagnostics {
	var diags diag.Diagnostics

	// Look for source fields that are complex XML wrapper structures that should be split
	for i := 0; i < typeFrom.NumField(); i++ {
		fromField := typeFrom.Field(i)
		fromFieldName := fromField.Name
		fromFieldType := fromField.Type
		fromFieldVal := valFrom.Field(i)

		// Skip already processed fields
		if processedFields[fromFieldName] {
			continue
		}

		// Check if this is a pointer to a struct or direct struct that could be split
		var sourceStructType reflect.Type
		var sourceStructVal reflect.Value
		isNil := false

		if fromFieldType.Kind() == reflect.Pointer && fromFieldType.Elem().Kind() == reflect.Struct {
			if fromFieldVal.IsNil() {
				isNil = true
				sourceStructType = fromFieldType.Elem()
				sourceStructVal = reflect.Zero(sourceStructType)
			} else {
				sourceStructType = fromFieldType.Elem()
				sourceStructVal = fromFieldVal.Elem()
			}
		} else if fromFieldType.Kind() == reflect.Struct {
			sourceStructType = fromFieldType
			sourceStructVal = fromFieldVal
		} else {
			continue
		}

		// Check if this source struct should be split into multiple target fields
		if !flattener.isXMLWrapperSplitSource(sourceStructType) {
			continue
		}

		// Before splitting, check if there's a direct field match in the target
		// If the target has a field with the same name that can accept this XML wrapper,
		// skip the split and let normal field matching handle it
		if targetField, ok := (&fuzzyFieldFinder{}).findField(ctx, fromFieldName, typeFrom, typeTo, flattener); ok {
			if targetFieldVal := valTo.FieldByIndex(targetField.Index); targetFieldVal.CanSet() {
				// Check if target field is a NestedObjectCollection that can accept this wrapper
				if targetAttr, ok := targetFieldVal.Interface().(attr.Value); ok {
					if _, isNestedObjCollection := targetAttr.Type(ctx).(fwtypes.NestedObjectCollectionType); isNestedObjCollection {
						// Skip split - let normal field matching handle this as a direct wrapper-to-wrapper mapping
						tflog.SubsystemTrace(ctx, subsystemName, "Skipping XML wrapper split - direct field match found", map[string]any{
							logAttrKeySourceFieldname: fromFieldName,
							logAttrKeyTargetFieldname: targetField.Name,
						})
						continue
					}
				}
			}
		}

		tflog.SubsystemTrace(ctx, subsystemName, "Found XML wrapper split source", map[string]any{
			logAttrKeySourceFieldname: fromFieldName,
			logAttrKeySourceType:      sourceStructType.String(),
			"is_nil":                  isNil,
		})

		// Handle the XML wrapper split
		diags.Append(flattener.handleXMLWrapperSplit(ctx, sourcePath.AtName(fromFieldName), sourceStructVal, targetPath, valTo, sourceStructType, typeTo, isNil)...)
		if diags.HasError() {
			return diags
		}

		// Mark the source field as processed
		processedFields[fromFieldName] = true
	}

	return diags
}
