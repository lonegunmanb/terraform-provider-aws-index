package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
)
func mapBlockKey(ctx context.Context, from any) (reflect.Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	valFrom := reflect.ValueOf(from)
	if kind := valFrom.Kind(); kind == reflect.Pointer {
		valFrom = valFrom.Elem()
	}

	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeySourceType, fullTypeName(valueType(valFrom)))

	for field := range tfreflect.ExportedStructFields(valFrom.Type()) {
		// go from StringValue to string
		if field.Name == mapBlockKeyFieldName {
			fieldVal := valFrom.FieldByIndex(field.Index)

			if v, ok := fieldVal.Interface().(basetypes.StringValuable); ok {
				v, d := v.ToStringValue(ctx)
				diags.Append(d...)
				if d.HasError() {
					return reflect.Zero(reflect.TypeFor[string]()), diags
				}
				return reflect.ValueOf(v.ValueString()), diags
			}

			// this is not ideal but perhaps better than a panic?
			// return reflect.ValueOf(fmt.Sprintf("%s", valFrom.Field(i))), diags

			return fieldVal, diags
		}
	}

	tflog.SubsystemError(ctx, subsystemName, "Source has no map block key")
	diags.Append(diagExpandingNoMapBlockKey(valFrom.Type()))

	return reflect.Zero(reflect.TypeFor[string]()), diags
}
