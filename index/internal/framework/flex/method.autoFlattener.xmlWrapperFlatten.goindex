package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"time"

	smithydocument "github.com/aws/smithy-go/document"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
	tfsmithy "github.com/hashicorp/terraform-provider-aws/internal/smithy"
	"github.com/shopspring/decimal"
)
func (flattener *autoFlattener) xmlWrapperFlatten(ctx context.Context, vFrom reflect.Value, tTo attr.Type, vTo reflect.Value, opts tagOptions) diag.Diagnostics {
	wrapperField := opts.XMLWrapperField()
	tflog.SubsystemTrace(ctx, subsystemName, "Starting XML wrapper flatten", map[string]any{
		"source_type":   vFrom.Type().String(),
		"target_type":   tTo.String(),
		"wrapper_field": wrapperField,
	})

	// Check if target is a NestedObjectCollection (Rule 2 pattern)
	if nestedObjType, ok := tTo.(fwtypes.NestedObjectCollectionType); ok {
		tflog.SubsystemTrace(ctx, subsystemName, "Target is NestedObjectCollectionType - checking for Rule 2", map[string]any{
			"target_type": tTo.String(),
		})

		// Rule 2 detection: check if source AWS struct has more than 2 fields
		// (Items, Quantity, plus additional fields like Enabled)
		sourceStructType := vFrom.Type()
		if sourceStructType.Kind() == reflect.Ptr {
			sourceStructType = sourceStructType.Elem()
		}

		isRule2 := false
		if sourceStructType.Kind() == reflect.Struct {
			// Count fields, excluding noSmithyDocumentSerde
			fieldCount := 0
			for i := 0; i < sourceStructType.NumField(); i++ {
				fieldName := sourceStructType.Field(i).Name
				if fieldName != "noSmithyDocumentSerde" {
					fieldCount++
				}
			}
			isRule2 = fieldCount > 2
		}

		tflog.SubsystemTrace(ctx, subsystemName, "Rule 2 detection result", map[string]any{
			"is_rule2":    isRule2,
			"field_count": sourceStructType.NumField(),
			"source_type": sourceStructType.String(),
		})

		if isRule2 {
			tflog.SubsystemTrace(ctx, subsystemName, "Using Rule 2 flatten - calling xmlWrapperFlattenRule2")
			return flattener.xmlWrapperFlattenRule2(ctx, vFrom, nestedObjType, vTo, opts)
		}
		tflog.SubsystemTrace(ctx, subsystemName, "NOT Rule 2 - continuing with Rule 1")
	}

	// Rule 1: Flatten Items field directly to collection
	return flattener.xmlWrapperFlattenRule1(ctx, vFrom, tTo, vTo)
}
