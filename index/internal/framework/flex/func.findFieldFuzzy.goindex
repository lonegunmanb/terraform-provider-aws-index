package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"reflect"
	"strings"

	pluralize "github.com/gertd/go-pluralize"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
)
func findFieldFuzzy(ctx context.Context, fieldNameFrom string, typeFrom reflect.Type, typeTo reflect.Type, flexer autoFlexer) (reflect.StructField, bool) {
	// first precedence is exact match (case sensitive)
	if fieldTo, ok := typeTo.FieldByName(fieldNameFrom); ok {
		return fieldTo, true
	}

	// If a "from" field fuzzy matches a "to" field, we are certain the fuzzy match
	// is NOT correct if "from" also contains a field by the fuzzy matched name.
	// For example, if "from" has "Value" and "Values", "Values" should *never*
	// fuzzy match "Value" in "to" since "from" also has "Value". We check "from"
	// to make sure fuzzy matches are not in "from".

	// second precedence is exact match (case insensitive)
	opts := flexer.getOptions()
	for field := range tfreflect.ExportedStructFields(typeTo) {
		fieldNameTo := field.Name
		if opts.isIgnoredField(fieldNameTo) {
			continue
		}
		if fieldTo, ok := typeTo.FieldByName(fieldNameTo); ok && strings.EqualFold(fieldNameFrom, fieldNameTo) && !fieldExistsInStruct(fieldNameTo, typeFrom) {
			// probably could assume validity here since reflect gave the field name
			return fieldTo, true
		}
	}

	// third precedence is singular/plural
	fieldNameTo := plural.Plural(fieldNameFrom)
	if plural.IsSingular(fieldNameFrom) && !fieldExistsInStruct(fieldNameTo, typeFrom) {
		if fieldTo, ok := typeTo.FieldByName(fieldNameTo); ok {
			return fieldTo, true
		}
	}

	fieldNameTo = plural.Singular(fieldNameFrom)
	if plural.IsPlural(fieldNameFrom) && !fieldExistsInStruct(fieldNameTo, typeFrom) {
		if fieldTo, ok := typeTo.FieldByName(fieldNameTo); ok {
			return fieldTo, true
		}
	}

	// fourth precedence is using field name prefix
	if v := opts.fieldNamePrefix; v != "" {
		v = strings.ReplaceAll(v, " ", "")
		if ctx.Value(fieldNamePrefixRecurse) == nil {
			// so it will only recurse once
			ctx = context.WithValue(ctx, fieldNamePrefixRecurse, true)
			if trimmed, ok := strings.CutPrefix(fieldNameFrom, v); ok {
				return findFieldFuzzy(ctx, trimmed, typeFrom, typeTo, flexer)
			}
			return findFieldFuzzy(ctx, v+fieldNameFrom, typeFrom, typeTo, flexer)
		}
	}

	// fifth precedence is using field name suffix
	if v := opts.fieldNameSuffix; v != "" {
		v = strings.ReplaceAll(v, " ", "")
		if ctx.Value(fieldNameSuffixRecurse) == nil {
			// so it will only recurse once
			ctx = context.WithValue(ctx, fieldNameSuffixRecurse, true)
			if strings.HasSuffix(fieldNameFrom, v) {
				return findFieldFuzzy(ctx, strings.TrimSuffix(fieldNameFrom, v), typeFrom, typeTo, flexer)
			}
			return findFieldFuzzy(ctx, fieldNameFrom+v, typeFrom, typeTo, flexer)
		}
	}

	// no finds, fuzzy or otherwise - return zero value
	return reflect.StructField{}, false
}
