package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"time"

	smithydocument "github.com/aws/smithy-go/document"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
	tfsmithy "github.com/hashicorp/terraform-provider-aws/internal/smithy"
	"github.com/shopspring/decimal"
)
func flattenStruct(ctx context.Context, sourcePath path.Path, from any, targetPath path.Path, to any, flexer autoFlexer) diag.Diagnostics {
	var diags diag.Diagnostics

	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeySourcePath, sourcePath.String())
	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeyTargetPath, targetPath.String())

	ctx, valFrom, valTo, d := autoFlexValues(ctx, from, to)
	diags.Append(d...)
	if diags.HasError() {
		return diags
	}

	if toFlattener, ok := to.(Flattener); ok {
		tflog.SubsystemInfo(ctx, subsystemName, "Target implements flex.Flattener")
		diags.Append(flattenFlattener(ctx, valFrom, toFlattener)...)
		return diags
	}

	typeFrom := valFrom.Type()
	typeTo := valTo.Type()

	// Special handling: Check if the entire source struct is an XML wrapper
	// and should be flattened to a target field with wrapper tag
	if isXMLWrapperStruct(typeFrom) {
		for toField := range tfreflect.ExportedStructFields(typeTo) {
			toFieldName := toField.Name
			_, toOpts := autoflexTags(toField)
			if wrapperField := toOpts.WrapperField(); wrapperField != "" {
				toFieldVal := valTo.FieldByIndex(toField.Index)
				if !toFieldVal.CanSet() {
					continue
				}

				tflog.SubsystemTrace(ctx, subsystemName, "Converting entire XML wrapper struct to collection field", map[string]any{
					logAttrKeySourceType:      typeFrom.String(),
					logAttrKeyTargetFieldname: toFieldName,
					"wrapper_field":           wrapperField,
				})

				valTo, ok := toFieldVal.Interface().(attr.Value)
				if !ok {
					tflog.SubsystemError(ctx, subsystemName, "Target field does not implement attr.Value")
					diags.Append(diagFlatteningTargetDoesNotImplementAttrValue(reflect.TypeOf(toFieldVal.Interface())))
					return diags
				}

				if f, ok := flexer.(*autoFlattener); ok {
					diags.Append(f.xmlWrapperFlatten(ctx, valFrom, valTo.Type(ctx), toFieldVal, wrapperField)...)
				} else {
					diags.Append(DiagFlatteningIncompatibleTypes(valFrom.Type(), reflect.TypeOf(toFieldVal.Interface())))
				}
				if diags.HasError() {
					return diags
				}
				// Successfully handled as XML wrapper, don't process individual fields
				return diags
			}
		}
	}

	for fromField := range flattenSourceFields(ctx, typeFrom, flexer.getOptions()) {
		fromFieldName := fromField.Name

		toField, ok := (&fuzzyFieldFinder{}).findField(ctx, fromFieldName, typeFrom, typeTo, flexer)
		if !ok {
			// Corresponding field not found in to.
			tflog.SubsystemDebug(ctx, subsystemName, "No corresponding field", map[string]any{
				logAttrKeySourceFieldname: fromFieldName,
			})
			continue
		}
		toFieldName := toField.Name
		toNameOverride, toOpts := autoflexTags(toField)
		toFieldVal := valTo.FieldByIndex(toField.Index)
		if toNameOverride == "-" {
			tflog.SubsystemTrace(ctx, subsystemName, "Skipping ignored target field", map[string]any{
				logAttrKeySourceFieldname: fromFieldName,
				logAttrKeyTargetFieldname: toFieldName,
			})
			continue
		}
		if toOpts.NoFlatten() {
			tflog.SubsystemTrace(ctx, subsystemName, "Skipping noflatten target field", map[string]any{
				logAttrKeySourceFieldname: fromFieldName,
				logAttrKeyTargetFieldname: toFieldName,
			})
			continue
		}
		if !toFieldVal.CanSet() {
			// Corresponding field value can't be changed.
			tflog.SubsystemDebug(ctx, subsystemName, "Field cannot be set", map[string]any{
				logAttrKeySourceFieldname: fromFieldName,
				logAttrKeyTargetFieldname: toFieldName,
			})
			continue
		}

		tflog.SubsystemTrace(ctx, subsystemName, "Matched fields", map[string]any{
			logAttrKeySourceFieldname: fromFieldName,
			logAttrKeyTargetFieldname: toFieldName,
		})

		// Check if target has wrapper tag and source is an XML wrapper struct
		if wrapperField := toOpts.WrapperField(); wrapperField != "" {
			fromFieldVal := valFrom.FieldByIndex(fromField.Index)
			if isXMLWrapperStruct(fromFieldVal.Type()) {
				tflog.SubsystemTrace(ctx, subsystemName, "Converting XML wrapper struct to collection", map[string]any{
					logAttrKeySourceFieldname: fromFieldName,
					logAttrKeyTargetFieldname: toFieldName,
					"wrapper_field":           wrapperField,
				})

				valTo, ok := toFieldVal.Interface().(attr.Value)
				if !ok {
					tflog.SubsystemError(ctx, subsystemName, "Target field does not implement attr.Value")
					diags.Append(diagFlatteningTargetDoesNotImplementAttrValue(reflect.TypeOf(toFieldVal.Interface())))
					break
				}

				if f, ok := flexer.(*autoFlattener); ok {
					diags.Append(f.xmlWrapperFlatten(ctx, fromFieldVal, valTo.Type(ctx), toFieldVal, wrapperField)...)
				} else {
					diags.Append(DiagFlatteningIncompatibleTypes(fromFieldVal.Type(), reflect.TypeOf(toFieldVal.Interface())))
				}
				if diags.HasError() {
					break
				}
				continue
			}
		}

		opts := fieldOpts{
			legacy:    toOpts.Legacy(),
			omitempty: toOpts.OmitEmpty(),
		}

		diags.Append(flexer.convert(ctx, sourcePath.AtName(fromFieldName), valFrom.FieldByIndex(fromField.Index), targetPath.AtName(toFieldName), toFieldVal, opts)...)
		if diags.HasError() {
			break
		}
	}

	return diags
}
