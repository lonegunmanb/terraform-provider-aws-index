package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
)
func (expander autoExpander) nestedObjectCollectionToXMLWrapper(ctx context.Context, _ path.Path, vFrom fwtypes.NestedObjectCollectionValue, _ path.Path, vTo reflect.Value) diag.Diagnostics {
	var diags diag.Diagnostics

	tflog.SubsystemTrace(ctx, subsystemName, "Expanding NestedObjectCollection to XML wrapper", map[string]any{
		"source_type": vFrom.Type(ctx).String(),
		"target_type": vTo.Type().String(),
	})

	// Get the nested Objects as a slice
	from, d := vFrom.ToObjectSlice(ctx)
	diags.Append(d...)
	if diags.HasError() {
		return diags
	}

	// Get reflect value of the slice
	fromSlice := reflect.ValueOf(from)
	if fromSlice.Kind() != reflect.Slice {
		diags.AddError("Invalid source", "ToObjectSlice did not return a slice")
		return diags
	}

	// Get the Items and Quantity fields from target struct
	itemsField := vTo.FieldByName("Items")
	quantityField := vTo.FieldByName("Quantity")

	if !itemsField.IsValid() || !quantityField.IsValid() {
		tflog.SubsystemError(ctx, subsystemName, "XML wrapper struct missing required fields")
		diags.Append(diagExpandingIncompatibleTypes(reflect.TypeOf(vFrom), vTo.Type()))
		return diags
	}

	// Create the Items slice
	itemsSliceType := itemsField.Type()
	itemsCount := fromSlice.Len()
	itemsSlice := reflect.MakeSlice(itemsSliceType, itemsCount, itemsCount)

	tflog.SubsystemTrace(ctx, subsystemName, "Converting nested objects to items", map[string]any{
		"items_count": itemsCount,
		"items_type":  itemsSliceType.String(),
	})

	// Convert each nested object
	for i := range itemsCount {
		sourceItem := fromSlice.Index(i)
		targetItem := itemsSlice.Index(i)

		// Create new instance for the target item
		targetItemType := itemsSliceType.Elem()
		if targetItemType.Kind() == reflect.Pointer {
			// For []*struct
			newItem := reflect.New(targetItemType.Elem())
			diags.Append(autoExpandConvert(ctx, sourceItem.Interface(), newItem.Interface(), expander)...)
			if diags.HasError() {
				return diags
			}
			targetItem.Set(newItem)
		} else {
			// For []struct - need to set the value directly
			newItem := reflect.New(targetItemType)
			diags.Append(autoExpandConvert(ctx, sourceItem.Interface(), newItem.Interface(), expander)...)
			if diags.HasError() {
				return diags
			}
			targetItem.Set(newItem.Elem())
		}
	}

	// Set the Items field
	if itemsField.CanSet() {
		itemsField.Set(itemsSlice)
	}

	// Set the Quantity field
	if quantityField.CanSet() && quantityField.Type().Kind() == reflect.Pointer {
		quantity := int32(itemsCount)
		quantityPtr := reflect.New(quantityField.Type().Elem())
		quantityPtr.Elem().Set(reflect.ValueOf(quantity))
		quantityField.Set(quantityPtr)
	}

	tflog.SubsystemTrace(ctx, subsystemName, "Successfully expanded NestedObjectCollection to XML wrapper", map[string]any{
		"items_count": itemsCount,
	})

	return diags
}
