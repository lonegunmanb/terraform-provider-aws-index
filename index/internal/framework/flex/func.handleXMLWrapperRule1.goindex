package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"time"

	smithydocument "github.com/aws/smithy-go/document"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
	tfsmithy "github.com/hashicorp/terraform-provider-aws/internal/smithy"
	"github.com/shopspring/decimal"
)
func handleXMLWrapperRule1(ctx context.Context, valFrom, valTo reflect.Value, typeFrom, typeTo reflect.Type, flexer autoFlexer) (bool, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Skip if target is a struct - that's Rule 2 where we map fields individually
	if typeTo.Kind() == reflect.Struct {
		return false, diags
	}

	for toField := range tfreflect.ExportedStructFields(typeTo) {
		toFieldName := toField.Name
		_, toOpts := autoflexTags(toField)
		if wrapperField := toOpts.XMLWrapperField(); wrapperField != "" {
			toFieldVal := valTo.FieldByIndex(toField.Index)
			if !toFieldVal.CanSet() {
				continue
			}

			tflog.SubsystemTrace(ctx, subsystemName, "Converting entire XML wrapper struct to collection field (Rule 1)", map[string]any{
				logAttrKeySourceType:      typeFrom.String(),
				logAttrKeyTargetFieldname: toFieldName,
				"wrapper_field":           wrapperField,
			})

			attrVal, ok := toFieldVal.Interface().(attr.Value)
			if !ok {
				tflog.SubsystemError(ctx, subsystemName, "Target field does not implement attr.Value")
				diags.Append(diagFlatteningTargetDoesNotImplementAttrValue(reflect.TypeOf(toFieldVal.Interface())))
				return true, diags
			}

			if f, ok := flexer.(*autoFlattener); ok {
				diags.Append(f.xmlWrapperFlatten(ctx, valFrom, attrVal.Type(ctx), toFieldVal, toOpts)...)
			} else {
				diags.Append(DiagFlatteningIncompatibleTypes(valFrom.Type(), reflect.TypeOf(toFieldVal.Interface())))
			}
			return true, diags
		}
	}

	return false, diags
}
