package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"sync"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
)
func (expander *autoExpander) expandRule1XMLWrapper(ctx context.Context, fromSlice reflect.Value, vTo reflect.Value, wrapperField string) diag.Diagnostics {
	var diags diag.Diagnostics

	tflog.SubsystemTrace(ctx, subsystemName, "Expanding Rule 1 XML wrapper (direct collection)")

	// Get the wrapper fields from target struct
	itemsField := expander.getCachedFieldValue(vTo, wrapperField)
	quantityField := expander.getCachedFieldValue(vTo, xmlWrapperFieldQuantity)

	if !itemsField.IsValid() || !quantityField.IsValid() {
		diags.Append(diagExpandingIncompatibleTypes(fromSlice.Type(), vTo.Type()))
		return diags
	}

	// Create the Items slice
	itemsSliceType := itemsField.Type()
	itemsCount := fromSlice.Len()
	itemsSlice := reflect.MakeSlice(itemsSliceType, itemsCount, itemsCount)

	tflog.SubsystemTrace(ctx, subsystemName, "Converting nested objects to items", map[string]any{
		"items_count": itemsCount,
		"items_type":  itemsSliceType.String(),
	})

	// Convert each nested object
	for i := range itemsCount {
		sourceItem := fromSlice.Index(i)
		targetItem := itemsSlice.Index(i)

		// Create new instance for the target item
		targetItemType := itemsSliceType.Elem()
		if targetItemType.Kind() == reflect.Pointer {
			// For []*struct
			newItem := reflect.New(targetItemType.Elem())
			diags.Append(autoExpandConvert(ctx, sourceItem.Interface(), newItem.Interface(), expander)...)
			if diags.HasError() {
				return diags
			}
			targetItem.Set(newItem)
		} else if targetItemType.Kind() == reflect.Struct {
			// For []struct - need to set the value directly
			newItem := reflect.New(targetItemType)
			diags.Append(autoExpandConvert(ctx, sourceItem.Interface(), newItem.Interface(), expander)...)
			if diags.HasError() {
				return diags
			}
			targetItem.Set(newItem.Elem())
		} else {
			// For primitive types ([]int32, []string, etc.) - direct conversion
			diags.Append(autoExpandConvert(ctx, sourceItem.Interface(), targetItem.Addr().Interface(), expander)...)
			if diags.HasError() {
				return diags
			}
		}
	}

	// Set the Items field
	if itemsField.CanSet() {
		itemsField.Set(itemsSlice)
	}

	// Set the Quantity field
	if quantityField.CanSet() && quantityField.Type().Kind() == reflect.Pointer {
		quantity := int32(itemsCount)
		quantityPtr := reflect.New(quantityField.Type().Elem())
		quantityPtr.Elem().Set(reflect.ValueOf(quantity))
		quantityField.Set(quantityPtr)
	}

	return diags
}
