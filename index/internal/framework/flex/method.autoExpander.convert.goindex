package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"

	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
)
func (expander autoExpander) convert(ctx context.Context, sourcePath path.Path, valFrom reflect.Value, targetPath path.Path, vTo reflect.Value, fieldOpts fieldOpts) diag.Diagnostics {
	var diags diag.Diagnostics

	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeySourcePath, sourcePath.String())
	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeyTargetPath, targetPath.String())

	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeySourceType, fullTypeName(valueType(valFrom)))
	ctx = tflog.SubsystemSetField(ctx, subsystemName, logAttrKeyTargetType, fullTypeName(valueType(vTo)))

	if valFrom.Kind() == reflect.Invalid {
		tflog.SubsystemError(ctx, subsystemName, "Source is nil")
		diags.Append(diagExpandingSourceIsNil(valueType(valFrom)))
		return diags
	}

	tflog.SubsystemInfo(ctx, subsystemName, "Converting")

	if fromExpander, ok := valFrom.Interface().(Expander); ok {
		tflog.SubsystemInfo(ctx, subsystemName, "Source implements flex.Expander")
		diags.Append(expandExpander(ctx, fromExpander, vTo)...)
		return diags
	}

	if fromTypedExpander, ok := valFrom.Interface().(TypedExpander); ok {
		tflog.SubsystemInfo(ctx, subsystemName, "Source implements flex.TypedExpander")
		diags.Append(expandTypedExpander(ctx, fromTypedExpander, vTo)...)
		return diags
	}

	vFrom, ok := valFrom.Interface().(attr.Value)
	if !ok {
		tflog.SubsystemError(ctx, subsystemName, "Source does not implement attr.Value")
		diags.Append(diagExpandingSourceDoesNotImplementAttrValue(reflect.TypeOf(valFrom.Interface())))
		return diags
	}

	// No need to set the target value if there's no source value.
	if vFrom.IsNull() {
		tflog.SubsystemTrace(ctx, subsystemName, "Expanding null value")
		return diags
	}
	if vFrom.IsUnknown() {
		tflog.SubsystemTrace(ctx, subsystemName, "Expanding unknown value")
		return diags
	}

	switch vFrom := vFrom.(type) {
	// Primitive types.
	case basetypes.BoolValuable:
		diags.Append(expander.bool(ctx, vFrom, vTo, fieldOpts)...)
		return diags

	case basetypes.Float64Valuable:
		diags.Append(expander.float64(ctx, vFrom, vTo, fieldOpts)...)
		return diags

	case basetypes.Float32Valuable:
		diags.Append(expander.float32(ctx, vFrom, vTo, fieldOpts)...)
		return diags

	case basetypes.Int64Valuable:
		diags.Append(expander.int64(ctx, vFrom, vTo, fieldOpts)...)
		return diags

	case basetypes.Int32Valuable:
		diags.Append(expander.int32(ctx, vFrom, vTo, fieldOpts)...)
		return diags

	case basetypes.StringValuable:
		diags.Append(expander.string(ctx, vFrom, vTo, fieldOpts)...)
		return diags

	// Aggregate types.
	case basetypes.ObjectValuable:
		diags.Append(expander.object(ctx, sourcePath, vFrom, targetPath, vTo)...)
		return diags

	case basetypes.ListValuable:
		diags.Append(expander.list(ctx, sourcePath, vFrom, targetPath, vTo)...)
		return diags

	case basetypes.MapValuable:
		diags.Append(expander.map_(ctx, vFrom, vTo)...)
		return diags

	case basetypes.SetValuable:
		diags.Append(expander.set(ctx, sourcePath, vFrom, targetPath, vTo)...)
		return diags
	}

	tflog.SubsystemError(ctx, subsystemName, "AutoFlex Expand; incompatible types", map[string]any{
		"from": vFrom.Type(ctx),
		"to":   vTo.Kind(),
	})

	return diags
}
