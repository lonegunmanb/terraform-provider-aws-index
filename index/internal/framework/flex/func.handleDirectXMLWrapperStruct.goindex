package github.com/hashicorp/terraform-provider-aws/internal/framework/flex
import (
	"context"
	"fmt"
	"iter"
	"reflect"
	"strings"
	"time"

	smithydocument "github.com/aws/smithy-go/document"
	"github.com/hashicorp/terraform-plugin-framework-timetypes/timetypes"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tfreflect "github.com/hashicorp/terraform-provider-aws/internal/reflect"
	tfsmithy "github.com/hashicorp/terraform-provider-aws/internal/smithy"
	"github.com/shopspring/decimal"
)
func handleDirectXMLWrapperStruct(ctx context.Context, valFrom, valTo reflect.Value, typeFrom, typeTo reflect.Type, flexer autoFlexer) diag.Diagnostics {
	var diags diag.Diagnostics

	wrapperFieldName := getXMLWrapperSliceFieldName(typeFrom)
	sourceItemsField := valFrom.FieldByName(wrapperFieldName)
	if !sourceItemsField.IsValid() {
		tflog.SubsystemError(ctx, subsystemName, "Source Items field not valid", map[string]any{
			"wrapper_field_name": wrapperFieldName,
		})
		return diags
	}

	tflog.SubsystemTrace(ctx, subsystemName, "Processing direct XML wrapper", map[string]any{
		"wrapper_field_name": wrapperFieldName,
		"source_type":        typeFrom.String(),
		"target_type":        typeTo.String(),
	})

	// Find target fields with matching xmlwrapper tags and map the source Items field to them
	for toField := range tfreflect.ExportedStructFields(typeTo) {
		toFieldName := toField.Name
		_, toOpts := autoflexTags(toField)

		tflog.SubsystemTrace(ctx, subsystemName, "Checking target field", map[string]any{
			"target_field":   toFieldName,
			"xmlwrapper_tag": toOpts.XMLWrapperField(),
		})

		// Check if this target field expects the wrapper field from source
		if toOpts.XMLWrapperField() == wrapperFieldName {
			toFieldVal := valTo.FieldByName(toFieldName)
			if !toFieldVal.IsValid() || !toFieldVal.CanSet() {
				tflog.SubsystemError(ctx, subsystemName, "Target field not valid or settable")
				continue
			}

			tflog.SubsystemTrace(ctx, subsystemName, "Found matching xmlwrapper field", map[string]any{
				"source_field": wrapperFieldName,
				"target_field": toFieldName,
			})

			// Get the target field as attr.Value for XML wrapper flattening
			if toAttr, ok := toFieldVal.Interface().(attr.Value); ok {
				if f, ok := flexer.(*autoFlattener); ok {
					tflog.SubsystemTrace(ctx, subsystemName, "Calling xmlWrapperFlatten")
					// Use XML wrapper flattening to convert the source Items field to the target collection
					diags.Append(f.xmlWrapperFlatten(ctx, valFrom, toAttr.Type(ctx), toFieldVal, toOpts)...)
				} else {
					tflog.SubsystemError(ctx, subsystemName, "Flexer is not autoFlattener")
					diags.Append(DiagFlatteningIncompatibleTypes(typeFrom, toField.Type))
				}
			} else {
				tflog.SubsystemError(ctx, subsystemName, "Target field does not implement attr.Value")
			}
		}
	}

	return diags
}
