package github.com/hashicorp/terraform-provider-aws/internal/generate/common
import (
	"errors"
	"fmt"
	"slices"
	"strconv"
	"strings"

	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	namesgen "github.com/hashicorp/terraform-provider-aws/names/generate"
)
func ParseResourceIdentity(annotationName string, args Args, implementation Implementation, d *ResourceIdentity, goImports *[]GoImport) (errs error) {
	switch annotationName {
	case "ArnIdentity":
		d.isARNIdentity = true
		if len(args.Positional) == 0 {
			d.identityAttributeName = "arn"
		} else {
			d.identityAttributeName = args.Positional[0]
		}

		parseIdentityDuplicateAttrNames(args, implementation, d)

		for k := range args.Keyword {
			errs = errors.Join(errs, fmt.Errorf("annotation \"@ArnIdentity\": unexpected keyword parameter %q", k))
		}

	case "CustomInherentRegionIdentity":
		d.isCustomInherentRegionIdentity = true

		if len(args.Positional) < 2 {
			errs = errors.Join(errs, errors.New("annotation \"@CustomInherentRegionIdentity\": missing required positional parameters"))
		}

		d.identityAttributeName = args.Positional[0]

		parseIdentityDuplicateAttrNames(args, implementation, d)

		for k := range args.Keyword {
			errs = errors.Join(errs, fmt.Errorf("annotation \"@CustomInherentRegionIdentity\": unexpected keyword parameter %q", k))
		}

		attr := args.Positional[1]
		if funcName, importSpec, err := ParseIdentifierSpec(attr); err != nil {
			errs = errors.Join(errs, fmt.Errorf("%q: %w", attr, err))
		} else {
			d.CustomInherentRegionParser = funcName
			if importSpec != nil {
				*goImports = append(*goImports, *importSpec)
			}
		}

	case "IdentityAttribute":
		if len(args.Positional) == 0 {
			errs = errors.Join(errs, errors.New("no Identity attribute name"))
		}

		identityAttribute := IdentityAttribute{
			Name_: args.Positional[0],
		}

		for k := range args.Keyword {
			switch k {
			// Needs to be handled differently than in `parseIdentityDuplicateAttrNames`
			case "identityDuplicateAttributes":
				attr := args.Keyword[k]
				attrs := strings.Split(attr, ";")
				// Sort `id` to first position, the rest alphabetically
				slices.SortFunc(attrs, func(a, b string) int {
					if a == "id" {
						return -1
					} else if b == "id" {
						return 1
					} else {
						return strings.Compare(a, b)
					}
				})
				d.IdentityDuplicateAttrNames = slices.Compact(attrs)

			case "optional":
				attr := args.Keyword[k]
				if b, err := ParseBoolAttr("optional", attr); err != nil {
					errs = errors.Join(errs, err)
				} else {
					identityAttribute.Optional = b
				}

			case "resourceAttributeName":
				identityAttribute.ResourceAttributeName_ = args.Keyword[k]

			case "testNotNull":
				attr := args.Keyword[k]
				if b, err := ParseBoolAttr("testNotNull", attr); err != nil {
					errs = errors.Join(errs, err)
				} else {
					identityAttribute.TestNotNull = b
				}

			default:
				errs = errors.Join(errs, fmt.Errorf("annotation \"@IdentityAttribute\": unexpected keyword parameter %q", k))
			}
		}

		d.IdentityAttributes = append(d.IdentityAttributes, identityAttribute)

	case "IdentityVersion":
		attr := args.Positional[0]
		if i, err := strconv.ParseInt(attr, 10, 64); err != nil {
			return fmt.Errorf("invalid IdentityVersion value: %q. Should be integer value.", attr)
		} else {
			d.IdentityVersion = i
		}

		for k := range args.Keyword {
			switch k {
			case "sdkV2IdentityUpgraders":
				attr := args.Keyword[k]
				attrs := strings.Split(attr, ";")
				d.SDKv2IdentityUpgraders = attrs

			default:
				errs = errors.Join(errs, fmt.Errorf("annotation \"@IdentityVersion\": unexpected keyword parameter %q", k))
			}
		}

	case "ImportIDHandler":
		attr := args.Positional[0]
		if typeName, importSpec, err := ParseIdentifierSpec(attr); err != nil {
			errs = errors.Join(errs, err)
		} else {
			d.ImportIDHandler = typeName
			if importSpec != nil {
				*goImports = append(*goImports, *importSpec)
			}
		}

		for k := range args.Keyword {
			switch k {
			case "setIDAttribute":
				attr := args.Keyword[k]
				if b, err := strconv.ParseBool(attr); err != nil {
					errs = errors.Join(errs, err)
				} else {
					d.SetIDAttribute = b
				}

			default:
				errs = errors.Join(errs, fmt.Errorf("annotation \"@ImportIDHandler\": unexpected keyword parameter %q", k))
			}
		}

	case "MutableIdentity":
		d.MutableIdentity = true

	case "SingletonIdentity":
		d.isSingletonIdentity = true

		// FIXME: Not actually for Global, but the value is never used
		d.identityAttributeName = "region"

		parseIdentityDuplicateAttrNames(args, implementation, d)

		for k := range args.Keyword {
			switch k {
			default:
				errs = errors.Join(errs, fmt.Errorf("annotation \"@SingletonIdentity\": unexpected keyword parameter %q", k))
			}
		}

	// TODO: allow underscore?
	case "V60SDKv2Fix":
		d.HasV6_0NullValuesError = true

		for k := range args.Keyword {
			switch k {
			case "v60RefreshError":
				attr := args.Keyword[k]
				if b, err := strconv.ParseBool(attr); err != nil {
					errs = errors.Join(errs, err)
				} else {
					d.HasV6_0RefreshError = b
				}

			default:
				errs = errors.Join(errs, fmt.Errorf("annotation \"@V60SDKv2Fix\": unexpected keyword parameter %q", k))
			}
		}
	}

	return errs
}
