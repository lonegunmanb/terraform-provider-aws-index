package github.com/hashicorp/terraform-provider-aws/internal/retry
import (
	"context"
	"errors"
	"slices"
	"time"

	"github.com/hashicorp/terraform-provider-aws/internal/backoff"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	"github.com/hashicorp/terraform-provider-aws/internal/vcr"
	"gopkg.in/dnaeon/go-vcr.v4/pkg/recorder"
)
func (conf *StateChangeConfOf[T, S]) WaitForStateContext(ctx context.Context) (T, error) {
	// Set a default for times to check for not found.
	if conf.NotFoundChecks == 0 {
		conf.NotFoundChecks = 20
	}
	if conf.ContinuousTargetOccurence == 0 {
		conf.ContinuousTargetOccurence = 1
	}

	// Set a default Delay using the StateChangeConf values
	delay := backoff.SDKv2HelperRetryCompatibleDelay(conf.Delay, conf.PollInterval, conf.MinTimeout)

	// When VCR testing in replay mode, override the default Delay
	if inContext, ok := conns.FromContext(ctx); ok && inContext.VCREnabled() {
		if mode, _ := vcr.Mode(); mode == recorder.ModeReplayOnly {
			delay = backoff.ZeroDelay
		}
	}

	var (
		t                             T
		currentState                  S
		err                           error
		notFoundTick, targetOccurence int
		l                             *backoff.Loop
	)
	for l = backoff.NewLoopWithOptions(conf.Timeout, backoff.WithDelay(delay)); l.Continue(ctx); {
		t, currentState, err = conf.refreshWithTimeout(ctx, l.Remaining())

		if errors.Is(err, context.DeadlineExceeded) {
			break
		}

		if err != nil {
			return t, err
		}

		if any(t) == nil {
			// If we're waiting for the absence of a thing, then return.
			if len(conf.Target) == 0 {
				targetOccurence++
				if conf.ContinuousTargetOccurence == targetOccurence {
					return t, err
				}

				continue
			}

			// If we didn't find the resource, check if we have been
			// not finding it for a while, and if so, report an error.
			notFoundTick++
			if notFoundTick > conf.NotFoundChecks {
				return t, &NotFoundError{
					LastError: err,
					Retries:   notFoundTick,
				}
			}
		} else {
			// Reset the counter for when a resource isn't found.
			notFoundTick = 0
			found := false

			if slices.Contains(conf.Target, currentState) {
				found = true
				targetOccurence++
				if conf.ContinuousTargetOccurence == targetOccurence {
					return t, err
				}
			}

			if slices.Contains(conf.Pending, currentState) {
				found = true
				targetOccurence = 0
			}

			if !found && len(conf.Pending) > 0 {
				return t, &UnexpectedStateError{
					LastError:     err,
					State:         string(currentState),
					ExpectedState: tfslices.Strings(conf.Target),
				}
			}

			// Wait between refreshes using exponential backoff, except when
			// waiting for the target state to reoccur.
			if v, ok := delay.(backoff.DelayWithSetIncrementDelay); ok {
				v.SetIncrementDelay(targetOccurence == 0)
			}
		}
	}

	// Timed out or Context canceled.
	if l.Remaining() == 0 {
		var zero T

		return zero, &TimeoutError{
			LastError:     err,
			LastState:     string(currentState),
			Timeout:       conf.Timeout,
			ExpectedState: tfslices.Strings(conf.Target),
		}
	}

	return t, context.Cause(ctx)
}
