package github.com/hashicorp/terraform-provider-aws/internal/tags
import (
	"context"
	"fmt"
	"maps"
	"net/url"
	"reflect"
	"slices"
	"strconv"
	"strings"

	"github.com/hashicorp/go-cty/cty"
	fwdiag "github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func GetAnyAttr(value cty.Value, attr string, shouldReturnSetElement func(string, cty.Value) bool) (cty.Value, error) {
	// Base case: if attr is empty, return the current value
	if attr == "" {
		return value, nil
	}

	// Split the attr string into the first part and the rest
	var part, rest string
	if dotIndex := strings.Index(attr, "."); dotIndex != -1 {
		part = attr[:dotIndex]
		rest = attr[dotIndex+1:]
	} else {
		part = attr
		rest = ""
	}

	// Handle indexed attribute
	if strings.Contains(part, "[") && strings.Contains(part, "]") {
		attrNameEnd := strings.Index(part, "[")
		indexStart := attrNameEnd + 1
		indexEnd := strings.Index(part, "]")

		if attrNameEnd == -1 || indexEnd == -1 {
			return cty.NilVal, fmt.Errorf("invalid indexed attribute format: %s", part)
		}

		attrName := part[:attrNameEnd]
		indexStr := part[indexStart:indexEnd]

		if !value.Type().HasAttribute(attrName) {
			return cty.NilVal, fmt.Errorf("attribute %s not found", attrName)
		}

		value = value.GetAttr(attrName)

		if value.Type().IsSetType() {
			it := value.ElementIterator()
			for it.Next() {
				_, v := it.Element()
				if shouldReturnSetElement(indexStr, v) {
					return GetAnyAttr(v, rest, shouldReturnSetElement)
				}
			}
			return cty.NilVal, fmt.Errorf("set element not found for attribute %s", attrName)
		}

		if !value.Type().IsListType() && !value.Type().IsTupleType() {
			return cty.NilVal, fmt.Errorf("attribute %s is not a list, tuple, or set", attrName)
		}

		index, err := strconv.Atoi(indexStr)
		if err != nil {
			return cty.NilVal, fmt.Errorf("invalid index: %s", indexStr)
		}

		if index >= value.LengthInt() {
			return cty.NilVal, fmt.Errorf("index %d out of range for attribute %s", index, attrName)
		}

		return GetAnyAttr(value.Index(cty.NumberIntVal(int64(index))), rest, shouldReturnSetElement)
	}

	// Handle regular attribute
	if !value.Type().HasAttribute(part) {
		return cty.NilVal, fmt.Errorf("attribute %s not found", part)
	}

	return GetAnyAttr(value.GetAttr(part), rest, shouldReturnSetElement)
}
