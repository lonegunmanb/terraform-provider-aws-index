package github.com/hashicorp/terraform-provider-aws/internal/provider/framework/listresource
import (
	"context"
	"fmt"
	"reflect"
	"unique"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/list"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/provider/interceptors"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	inttypes "github.com/hashicorp/terraform-provider-aws/internal/types"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (r defaultObjectInterceptor) Read(ctx context.Context, params InterceptorParams) diag.Diagnostics {
	var diags diag.Diagnostics
	switch params.When {
	case Before:
		if reflect.ValueOf(params.Data).Kind() != reflect.Ptr {
			diags.AddError(
				"Internal Error",
				"data object must be a pointer")
			return diags
		}

		objData := dereferencePointer(reflect.ValueOf(params.Data))

		for tfName, fieldName := range tfFieldToStructFieldMap() {
			field := objData.FieldByName(fieldName)
			if !field.IsValid() {
				continue
			}

			if !implementsAttrValue(field) {
				diags.AddError(
					"Internal Error",
					"An unexpected error occurred. "+
						"This is always an error in the provider. "+
						"Please report the following to the provider developer:\n\n"+
						fmt.Sprintf("Expected field %s to implement attr.Value, got: %T", fieldName, objData.FieldByName(fieldName).Interface()),
				)
				return diags
			}

			switch field.Interface().(attr.Value).Type(ctx).(type) {
			case basetypes.MapTypable:
				if field.Type() == reflect.TypeFor[tftags.Map]() {
					field.Set(reflect.ValueOf(tftags.NewMapValueNull()))
				}
			case basetypes.ObjectTypable:
				if field.Type() == reflect.TypeFor[timeouts.Value]() {
					timeoutsType, d := params.Result.Resource.Schema.TypeAtPath(ctx, path.Root(tfName))
					diags.Append(d...)
					if diags.HasError() {
						return diags
					}
					nullObj, d := newNullObject(timeoutsType)
					diags.Append(d...)
					if diags.HasError() {
						return diags
					}

					t := timeouts.Value{}
					t.Object = nullObj
					field.Set(reflect.ValueOf(t))
				}
			}
		}

		return diags
	}

	return diags
}
