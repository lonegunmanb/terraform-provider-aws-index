package github.com/hashicorp/terraform-provider-aws/internal/provider/framework
import (
	"context"
	"errors"
	"fmt"
	"iter"
	"log"
	"slices"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/ephemeral"
	"github.com/hashicorp/terraform-plugin-framework/function"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/provider"
	"github.com/hashicorp/terraform-plugin-framework/provider/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	fwflex "github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tffunction "github.com/hashicorp/terraform-provider-aws/internal/function"
	"github.com/hashicorp/terraform-provider-aws/internal/logging"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	tfunique "github.com/hashicorp/terraform-provider-aws/internal/unique"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (p *frameworkProvider) initialize(ctx context.Context) error {
	log.Printf("Initializing Terraform AWS Provider (Framework-style)...")

	var errs []error

	for sp := range p.servicePackages {
		servicePackageName := sp.ServicePackageName()

		for _, v := range sp.FrameworkDataSources(ctx) {
			typeName := v.TypeName
			inner, err := v.Factory(ctx)

			if err != nil {
				errs = append(errs, fmt.Errorf("creating data source (%s): %w", typeName, err))
				continue
			}

			var isRegionOverrideEnabled bool
			if v := v.Region; !tfunique.IsHandleNil(v) && v.Value().IsOverrideEnabled {
				isRegionOverrideEnabled = true
			}

			var interceptors interceptorInvocations

			if isRegionOverrideEnabled {
				v := v.Region.Value()

				interceptors = append(interceptors, dataSourceInjectRegionAttribute())
				if v.IsValidateOverrideInPartition {
					interceptors = append(interceptors, dataSourceValidateRegion())
				}
				interceptors = append(interceptors, dataSourceSetRegionInState())
			}

			if !tfunique.IsHandleNil(v.Tags) {
				interceptors = append(interceptors, dataSourceTransparentTagging(v.Tags))
			}

			opts := wrappedDataSourceOptions{
				// bootstrapContext is run on all wrapped methods before any interceptors.
				bootstrapContext: func(ctx context.Context, getAttribute getAttributeFunc, c *conns.AWSClient) (context.Context, diag.Diagnostics) {
					var diags diag.Diagnostics
					var overrideRegion string

					if isRegionOverrideEnabled && getAttribute != nil {
						var target types.String
						diags.Append(getAttribute(ctx, path.Root(names.AttrRegion), &target)...)
						if diags.HasError() {
							return ctx, diags
						}

						overrideRegion = target.ValueString()
					}

					ctx = conns.NewResourceContext(ctx, servicePackageName, v.Name, overrideRegion)
					if c != nil {
						ctx = tftags.NewContext(ctx, c.DefaultTagsConfig(ctx), c.IgnoreTagsConfig(ctx))
						ctx = c.RegisterLogger(ctx)
						ctx = fwflex.RegisterLogger(ctx)
					}

					return ctx, diags
				},
				interceptors: interceptors,
				typeName:     typeName,
			}
			p.dataSources = append(p.dataSources, func() datasource.DataSource {
				return newWrappedDataSource(inner, opts)
			})
		}

		if v, ok := sp.(conns.ServicePackageWithEphemeralResources); ok {
			for _, v := range v.EphemeralResources(ctx) {
				typeName := v.TypeName
				inner, err := v.Factory(ctx)

				if err != nil {
					errs = append(errs, fmt.Errorf("creating ephemeral resource (%s): %w", typeName, err))
					continue
				}

				var isRegionOverrideEnabled bool
				if v := v.Region; !tfunique.IsHandleNil(v) && v.Value().IsOverrideEnabled {
					isRegionOverrideEnabled = true
				}

				var interceptors interceptorInvocations

				if isRegionOverrideEnabled {
					v := v.Region.Value()

					interceptors = append(interceptors, ephemeralResourceInjectRegionAttribute())
					if v.IsValidateOverrideInPartition {
						interceptors = append(interceptors, ephemeralResourceValidateRegion())
					}
					interceptors = append(interceptors, ephemeralResourceSetRegionInResult())
				}

				opts := wrappedEphemeralResourceOptions{
					// bootstrapContext is run on all wrapped methods before any interceptors.
					bootstrapContext: func(ctx context.Context, getAttribute getAttributeFunc, c *conns.AWSClient) (context.Context, diag.Diagnostics) {
						var diags diag.Diagnostics
						var overrideRegion string

						if isRegionOverrideEnabled && getAttribute != nil {
							var target types.String
							diags.Append(getAttribute(ctx, path.Root(names.AttrRegion), &target)...)
							if diags.HasError() {
								return ctx, diags
							}

							overrideRegion = target.ValueString()
						}

						ctx = conns.NewResourceContext(ctx, servicePackageName, v.Name, overrideRegion)
						if c != nil {
							ctx = c.RegisterLogger(ctx)
							ctx = fwflex.RegisterLogger(ctx)
							ctx = logging.MaskSensitiveValuesByKey(ctx, logging.HTTPKeyRequestBody, logging.HTTPKeyResponseBody)
						}
						return ctx, diags
					},
					interceptors: interceptors,
					typeName:     v.TypeName,
				}
				p.ephemeralResources = append(p.ephemeralResources, func() ephemeral.EphemeralResource {
					return newWrappedEphemeralResource(inner, opts)
				})
			}
		}

		for _, res := range sp.FrameworkResources(ctx) {
			typeName := res.TypeName
			inner, err := res.Factory(ctx)

			if err != nil {
				errs = append(errs, fmt.Errorf("creating resource (%s): %w", typeName, err))
				continue
			}

			var isRegionOverrideEnabled bool
			if v := res.Region; !tfunique.IsHandleNil(v) && v.Value().IsOverrideEnabled {
				isRegionOverrideEnabled = true
			}

			var interceptors interceptorInvocations

			if isRegionOverrideEnabled {
				v := res.Region.Value()

				interceptors = append(interceptors, resourceInjectRegionAttribute())
				if v.IsValidateOverrideInPartition {
					interceptors = append(interceptors, resourceValidateRegion())
				}
				interceptors = append(interceptors, resourceDefaultRegion())
				interceptors = append(interceptors, resourceForceNewIfRegionChanges())
				interceptors = append(interceptors, resourceSetRegionInState())
				if res.Identity.HasInherentRegion() {
					interceptors = append(interceptors, resourceImportRegionNoDefault())
				} else {
					interceptors = append(interceptors, resourceImportRegion())
				}
			}

			if !tfunique.IsHandleNil(res.Tags) {
				interceptors = append(interceptors, resourceTransparentTagging(res.Tags))
			}

			if res.Import.WrappedImport {
				switch v := inner.(type) {
				case framework.ImportByIdentityer:
					v.SetIdentitySpec(res.Identity)

				default:
					errs = append(errs, fmt.Errorf("resource type %s: cannot configure importer", typeName))
					continue
				}
			}

			opts := wrappedResourceOptions{
				// bootstrapContext is run on all wrapped methods before any interceptors.
				bootstrapContext: func(ctx context.Context, getAttribute getAttributeFunc, c *conns.AWSClient) (context.Context, diag.Diagnostics) {
					var diags diag.Diagnostics
					var overrideRegion string

					if isRegionOverrideEnabled && getAttribute != nil {
						var target types.String
						diags.Append(getAttribute(ctx, path.Root(names.AttrRegion), &target)...)
						if diags.HasError() {
							return ctx, diags
						}

						overrideRegion = target.ValueString()
					}

					ctx = conns.NewResourceContext(ctx, servicePackageName, res.Name, overrideRegion)
					if c != nil {
						ctx = tftags.NewContext(ctx, c.DefaultTagsConfig(ctx), c.IgnoreTagsConfig(ctx))
						ctx = c.RegisterLogger(ctx)
						ctx = fwflex.RegisterLogger(ctx)
					}

					return ctx, diags
				},
				interceptors: interceptors,
				typeName:     typeName,
			}
			if len(res.Identity.Attributes) > 0 {
				opts.identity = res.Identity
				opts.interceptors = append(opts.interceptors, newIdentityInterceptor(res.Identity.Attributes))
			}

			p.resources = append(p.resources, func() resource.Resource {
				return newWrappedResource(inner, opts)
			})
		}
	}

	return errors.Join(errs...)
}
