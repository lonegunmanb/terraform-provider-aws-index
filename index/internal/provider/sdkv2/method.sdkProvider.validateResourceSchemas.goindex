package github.com/hashicorp/terraform-provider-aws/internal/provider/sdkv2
import (
	"context"
	"errors"
	"fmt"
	"iter"
	"log"
	"maps"
	"os"
	"slices"
	"strings"
	"time"

	"github.com/YakDriver/regexache"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/feature/ec2/imds"
	awsbase "github.com/hashicorp/aws-sdk-go-base/v2"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/flex"
	"github.com/hashicorp/terraform-provider-aws/internal/provider/sdkv2/internal/attribute"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2/types/nullable"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	tfunique "github.com/hashicorp/terraform-provider-aws/internal/unique"
	"github.com/hashicorp/terraform-provider-aws/internal/verify"
	"github.com/hashicorp/terraform-provider-aws/names"
)
func (p *sdkProvider) validateResourceSchemas(ctx context.Context) error {
	var errs []error

	for _, sp := range p.servicePackages {
		for _, v := range sp.SDKDataSources(ctx) {
			typeName := v.TypeName
			r := v.Factory()
			s := r.SchemaMap()

			if v := v.Region; !tfunique.IsHandleNil(v) && v.Value().IsOverrideEnabled {
				if _, ok := s[names.AttrRegion]; ok {
					errs = append(errs, fmt.Errorf("`%s` attribute is defined: %s data source", names.AttrRegion, typeName))
					continue
				}
			}

			if !tfunique.IsHandleNil(v.Tags) {
				// The data source has opted in to transparent tagging.
				// Ensure that the schema look OK.
				if v, ok := s[names.AttrTags]; ok {
					if !v.Computed {
						errs = append(errs, fmt.Errorf("`%s` attribute must be Computed: %s data source", names.AttrTags, typeName))
						continue
					}
				} else {
					errs = append(errs, fmt.Errorf("no `%s` attribute defined in schema: %s data source", names.AttrTags, typeName))
					continue
				}
			}
		}

		for _, resource := range sp.SDKResources(ctx) {
			typeName := resource.TypeName
			r := resource.Factory()
			s := r.SchemaMap()

			if v := resource.Region; !tfunique.IsHandleNil(v) && v.Value().IsOverrideEnabled {
				if _, ok := s[names.AttrRegion]; ok {
					errs = append(errs, fmt.Errorf("`%s` attribute is defined: %s resource", names.AttrRegion, typeName))
					continue
				}
			}

			if !tfunique.IsHandleNil(resource.Tags) {
				// The resource has opted in to transparent tagging.
				// Ensure that the schema look OK.
				if v, ok := s[names.AttrTags]; ok {
					if v.Computed {
						errs = append(errs, fmt.Errorf("`%s` attribute cannot be Computed: %s resource", names.AttrTags, typeName))
						continue
					}
				} else {
					errs = append(errs, fmt.Errorf("no `%s` attribute defined in schema: %s resource", names.AttrTags, typeName))
					continue
				}
				if v, ok := s[names.AttrTagsAll]; ok {
					if !v.Computed {
						errs = append(errs, fmt.Errorf("`%s` attribute must be Computed: %s resource", names.AttrTags, typeName))
						continue
					}
				} else {
					errs = append(errs, fmt.Errorf("no `%s` attribute defined in schema: %s resource", names.AttrTagsAll, typeName))
					continue
				}
			}

			if resource.Identity.IsCustomInherentRegion {
				if resource.Identity.IsGlobalResource {
					errs = append(errs, fmt.Errorf("`IsCustomInherentRegion` is not supported for Global resources: %s resource", typeName))
					continue
				}
			}
		}
	}

	return errors.Join(errs...)
}
