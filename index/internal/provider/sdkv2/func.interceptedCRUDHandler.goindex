package github.com/hashicorp/terraform-provider-aws/internal/provider/sdkv2
import (
	"context"
	"errors"
	"slices"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-aws/internal/conns"
	"github.com/hashicorp/terraform-provider-aws/internal/errs/sdkdiag"
	"github.com/hashicorp/terraform-provider-aws/internal/sdkv2"
	tfslices "github.com/hashicorp/terraform-provider-aws/internal/slices"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
)
func interceptedCRUDHandler[F ~func(context.Context, *schema.ResourceData, any) diag.Diagnostics](bootstrapContext contextFunc, interceptorInvocations interceptorInvocations, f F, why why) F {
	// We don't run CRUD interceptors if the resource has not defined a corresponding handler function.
	if f == nil {
		return nil
	}

	return func(ctx context.Context, rd *schema.ResourceData, meta any) diag.Diagnostics {
		var diags diag.Diagnostics

		ctx, err := bootstrapContext(ctx, rd.GetOk, meta)
		if err != nil {
			return sdkdiag.AppendFromErr(diags, err)
		}

		var interceptors []crudInterceptorInvocation
		for _, v := range interceptorInvocations.why(why) {
			if interceptor, ok := v.interceptor.(crudInterceptor); ok {
				interceptors = append(interceptors, crudInterceptorInvocation{
					when:        v.when,
					why:         v.why,
					interceptor: interceptor,
				})
			}
		}

		opts := crudInterceptorOptions{
			c:   meta.(awsClient),
			d:   rd,
			why: why,
		}

		// Before interceptors are run first to last.
		opts.when = Before
		for v := range slices.Values(interceptors) {
			if v.when&opts.when != 0 {
				diags = append(diags, v.interceptor.run(ctx, opts)...)

				// Short circuit if any Before interceptor errors.
				if diags.HasError() {
					return diags
				}
			}
		}

		d := f(ctx, rd, meta)
		diags = append(diags, d...)

		// All other interceptors are run last to first.
		if d.HasError() {
			opts.when = OnError
		} else {
			opts.when = After
		}
		for v := range tfslices.BackwardValues(interceptors) {
			if v.when&opts.when != 0 {
				diags = append(diags, v.interceptor.run(ctx, opts)...)
			}
		}

		opts.when = Finally
		for v := range tfslices.BackwardValues(interceptors) {
			if v.when&opts.when != 0 {
				diags = append(diags, v.interceptor.run(ctx, opts)...)
			}
		}

		return diags
	}
}
